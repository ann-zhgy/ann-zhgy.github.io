[{"title":"一致哈希算法","url":"/2023/10/792acd6.html","content":"> 场景：数据分区存储\n\n<!-- more -->\n\n# 哈希算法\n\n通过哈希算法，每个 key 都可以寻址到对应的服务器，比如，查询 key 是 key-01，计算公式为 hash(key-01) % 3，经过计算寻址到了编号为1的服务器节点A\n\n但如果服务器数量发生变化，基于新的服务器数量来执行哈希算法的时候，就会出现路由寻址失败的情况，Proxy无法找到之前寻址到的那个服务器节点，这是为什么呢？\n\n想象一下，假如3个节点不能满足业务需要了，这时我们增加了一个节点，节点的数量从3变化为4，那么之前的hash(key-01) % 3 = 1，就变成了hash(key-01) % 4 = X，因为取模运算发生了变化，所以这个X大概率不是1（可能X为2），这时你再查询，就会找不到数据了，因为key-01对应的数据，存储在节点A上，而不是节点B\n\n同样的道理，如果我们需要下线1个服务器节点（也就是缩容），也会存在类似的可能查询不到数据的问题。\n\n使用哈希算法选址时，如果数据节点的数量变化了，就必须对所有已经有的数据进行 rehash，使数据可以按照规则分布在各个节点上，但是在生产中，数据迁移的成本是很高的\n\n# 一致性哈希算法寻址\n\n一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算。你可以想象下，一致哈希算法，将整个哈希值空间组织成一个虚拟的圆环，各个节点映射在圆环的不同位置\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20231012143647\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20231012143647.png\" style=\"width: 100%;\">\n</div>\n\n当需要对指定key的值进行读写的时候，你可以通过下面2步进行寻址：\n\n* 将key作为参数执行c-hash()计算哈希值，并确定此key在环上的位置；\n* 从这个位置沿着哈希环顺时针“行走”，遇到的第一节点就是key对应的节点。\n\n当我们新添加了一个节点4，放在了节点2和节点3中间，那么我们仅需要平衡节点3的数据即可，即：仅需要对节点3的数据进行迁移\n\n所以：使用了一致哈希算法后，扩容或缩容的时候，都只需要重定位环空间中的一小部分数据。**也就是说，一致哈希算法具有较好的容错性和可扩展性。**\n\n# 虚拟节点\n\n一致性哈希算法并不会保证节点均匀的分布在哈希环上，所以可能会带来一个问题：客户端访问请求集中在少数的节点上，出现了有些机器高负载，有些机器低负载现象。\n\n如果想要节点在哈希环上分布的均匀，就需要有足够多的节点，节点越多，在哈希环上分布的越均匀，但是实际上我们并不会有那么多的节点，所以就引入了**虚拟节点**。\n\n具体做法是：**不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系**。\n\n比如对每个节点分别设置 3 个虚拟节点：\n\n* 对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03\n* 对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03\n* 对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03\n\n引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20231012150947\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20231012150947.png\" style=\"width: 100%;\">\n</div>\n\n当节点的数量多了之后，哈希环将不得不分布的更加均匀。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。\n\n上面为了方便你理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。\n\n另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。 **当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高** 。\n\n比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。\n\n而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。\n\n因此， **带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景** 。\n","tags":["Raft"],"categories":["分布式算法"]},{"title":"分布式算法 ——05-Raft 算法 - 分布式算法学习路径","url":"/2023/10/a4140eb6.html","content":"> **Raft算法是现在分布式系统开发首选的共识算法。**比如：etcd、consul。**从本质上说，Raft算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。**\n\n<!-- more -->\n\n# 简介\n\n不同于Paxos算法直接从分布式一致性问题出发推导出来，Raft算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题: **Leader选举(Leader election)**、**日志同步(Log replication)**、**安全性(Safety)**、**日志压缩(Log compaction)**、**成员变更(Membership change)**等。同时，Raft算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。\n\n## 角色\n\nRaft将系统中的角色分为 `领导者(Leader)`、`跟从者(Follower)`和 `候选人(Candidate)`:\n\n* `Leader`: 接受客户端请求，并向 Follower 同步请求日志，当日志同步到大多数节点上后告诉 Follower 提交日志。\n* `Follower`: 接受并持久化 Leader 同步的日志，在 Leader 告之日志可以提交之后，提交日志。\n* `Candidate`: Leader 选举过程中的临时角色，由 Follower 转换而来，发起投票参与竞选 Leader\n\nRaft 是强领导者模型，任何时刻都只能有一个领导者，剩下的都是 Follower。Followwer 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求\n\n## 角色状态转换\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20231010160738\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20231010160738.png\" style=\"width: 100%;\">\n</div>\n\nFollower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。\n\n## 任期\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20231010160712\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20231010160712.png\" style=\"width: 100%;\">\n</div>\n\nRaft算法将时间分为一个个的任期(term)，每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。\n\nRaft 算法保证一个任期内最多只有一个 Leader\n\n## 日志\n\n* `entry`：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为 `<term,index,cmd>`，其中 cmd 是可以应用到状态机的操作。\n* `log`：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。\n\n## Raft 和 Multi Paxos 的异同\n\n### 相似概念\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20231010162523\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20231010162523.png\" style=\"width: 100%;\">\n</div>\n\n### 不同概念\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20231010162559\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20231010162559.png\" style=\"width: 100%;\">\n</div>\n\n# Leader 选举\n\nRaft 使用心跳(heartbeat)来触发 Leader 选举。当服务器启动时，初始化为 Follower。Leader 向所有 Followers 周期性发送 heartbeat。如果 Follower 在选举超时时间内没有收到 Leader 的 heartbeat，就会等待一段随机的时间后发起一次 Leader 选举。\n\nFollower 将当前 term 加一然后转换为 Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下几种情况：\n\n* 赢得多数选票，成功选举为 Leader\n* 收到了 Leader 的消息，表示有其他节点成为 Leader\n* 没有收到服务器赢得多数的选票，Leader 选举失败，等待选举时间超时并进入下一轮选举\n\n选举出 Leader 后，Leader 通过定期向所有 Followers 发送心跳信息维持其统治。若Follower 一段时间未收到 Leader 的心跳则认为 Leader 可能已经挂了，再次发起 Leader 选举过程。\n\n# 日志同步\n\nLeader 选出后，就开始接收客户端的请求。\n\nLeader 收到客户端请求后，会生成一个 entry，包含 `<index,term,cmd>`，在将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以称为这个 entry 是 committed 的，并且向客户端返回执行结果。\n\nRaft 保证以下两个性质：\n\n* 在两个日志里，有两个 entry 拥有相同的 index 和 term，那么他们一定拥有相同的 cmd\n* 在两个日志里，有两个 entry 拥有相同的 index 和 term，那么他们前面的 entry 也一定相同\n\n通过“仅有 Leader 可以生成 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。\n\n一般情况下，Leader 和 Follower 的日志保持一致，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。\n\n这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。\n\n`Leader` 给每一个 `Follower` 维护了一个 `nextIndex`，它表示 `Leader` 将要发送给该追随者的下一条日志条目的索引。当一个 `Leader` 开始掌权时，它会将 `nextIndex` 初始化为它的最新的日志条目索引数+1。如果一个 `Follower` 的日志和 `Leader` 的不一致，`AppendEntries` 一致性检查会在下一次 `AppendEntries RPC` 时返回失败。在失败之后，`Leader` 会将 `nextIndex` 递减然后重试 `AppendEntries RPC`。最终 `nextIndex` 会达到一个 `Leader` 和 `Follower` 日志一致的地方。这时，`AppendEntries` 会返回成功，`Follower` 中冲突的日志条目都被移除了，并且添加所缺少的上了 `Leader` 的日志条目。一旦 `AppendEntries` 返回成功，`Follower` 和 `Leader` 的日志就一致了，这样的状态会保持到该任期结束。\n\n# 日志压缩\n\n在实际的系统中，不能让日志无限增长，否则系统重启会消耗很长的时间进行回放，从而影响可用性。Raft 采用对整个系统进行 snapshot 来解决，snapshot 之前的日志都可以丢弃\n\n每个副本独立的对自己的系统状态进行 snapshot，并且对已经提交的日志记录进行 snapshot\n\nSnapshot 包含以下内容：\n\n* 日志元数据：最后一条已经提交的 log entry 的 log index 和 term。这两个值在 snapshot 的第一条 log entry 的 AppendEntries RPC 的完整性检查的时候会被用上。\n* 系统当前状态\n\n当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC。\n\n做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。\n\n# 安全性\n\n## 选举机制\n\nLeader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。\n\n每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。\n\n判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。\n\n## 节点崩溃\n\n如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。\n\n如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。\n\n## 时间与可用性\n\nraft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：\n\n`broadcastTime << electionTimeout << MTBF`\n\n* `broadcastTime`：向其他节点并发发送消息的平均响应时间；\n* `electionTimeout`：选举超时时间；\n* `MTBF(mean time between failures)`：单台机器的平均健康时间；\n\n`broadcastTime`应该比 `electionTimeout`小一个数量级，为的是使 `Leader`能够持续发送心跳信息（heartbeat）来阻止 `Follower`开始选举；\n\n`electionTimeout`也要比 `MTBF`小几个数量级，为的是使得系统稳定运行。当 `Leader`崩溃时，大约会在整个 `electionTimeout`的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。\n\n由于 `broadcastTime`和 `MTBF`是由系统决定的属性，因此需要决定 `electionTimeout`的时间。\n\n一般来说，broadcastTime 一般为 `0.5～20ms`，electionTimeout 可以设置为 `10～500ms`，MTBF 一般为一两个月。\n","tags":["Raft"],"categories":["分布式算法"]},{"title":"Paxos 算法","url":"/2023/09/5bf1141f.html","content":"> Paxos 算法 是分布式中非常著名的算法，在过去几十年里，它基本上是分布式共识的代名词，因为当前最常用的一批共识算法都是基于它改进的。\n\nPaxos算法包含2个部分：\n\n* 一个是Basic Paxos算法，描述的是多节点之间如何就某个值（提案Value）达成共识；\n* 另一个是Multi-Paxos思想，描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。\n\n<!-- more -->\n\n# Basic Paxos\n\n> Basic Paxos 算法中存在一些比较重要的概念：提案、准备（Prepare）请求、接受（Accept）请求、角色等等，其中最重要的就是“角色”。因为角色是对Basic Paxos中最核心的三个功能的抽象，比如，由接受者（Acceptor）对提议的值进行投票，并存储接受的值。\n\n## 三种角色\n\n在Basic Paxos中，有提议者（Proposer）、接受者（Acceptor）、学习者（Learner）三种角色：\n\n* **提议者（Proposer）** ：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。\n* **接受者（Acceptor）** ：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史。\n* **学习者（Learner）**：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230925163959\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230925163959.png\" style=\"width: 100%;\">\n</div>\n\n> 可以理解为人大代表(Proposer)在人大向其它代表(Acceptors)提案，通过后让老百姓(Learner)落实。\n\n## 如何达成共识？\n\n### 三个阶段\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230925175645\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230925175645.png\" style=\"width: 100%;\">\n</div>\n\n1. 准备（Parpare）阶段：提议者（Proposer）向接受者（Acceptor）发出准备（Parpare）请求，接受者（Acceptor）针对收到的准备（Parpare）请求进行承诺（Promise）\n\n   1. `Prepare`：Proposer 发送提案：提议者生成全局唯一递增的提案号（Proposal ID），向所有的 Acceptors 发送提案，此时 Proposer 无需携带提案的内容，只需要携带提案号（Proposal ID）即可。\n   2. `Promise`：Acceptors 应答提案：Acceptors 接收到提案之后，做出“两个承诺，一个应答”\n      * 两个承诺\n        * 不再应答提案号（Proposal ID）**小于等于**当前请求的 Prepare 请求\n        * 不在应答提案号（Proposal ID）**小于**当前请求的 Propose 请求\n      * 应答：不违背以前作出的承诺下，回复已经 Accept 过的提案中提案号（Proposal ID）最大的那个提案的的 Value 和 Proposal ID，没有则返回空值。\n2. 接受（Accept）阶段：提议者（Proposer）收到多数投票员（Acceptors）的承诺（Promise）后，向投票员（Acceptors）发出提案（Propose）请求，投票员（Acceptors）针对收到的提议（Propose）请求进行接受（Accept）处理。\n\n   1. `Propose`：Proposer 收到多数 Acceptors 的 Promise 应答后，从应答种选择提案号（Proposal ID）最大的提案的 Value，作为本次要发起的提案。如果所有应答的提案 Value 均为空值，则可以自己随意决定提案 Value。然后携带当前 Proposal ID，向所有 Acceptors 发送 Propose 请求。\n   2. `Accept`：Acceptor 收到 Propose 请求后，在不违背自己之前作出的承诺下，接受并持久化当前 Proposal ID 和提案 Value。\n3. 学习（Learn）阶段：提议者（Proposer）在收到多数投票员（Acceptors）的 Accept 之后，标志着本次 Accept 成功，决议形成，将形成的决议发送给所有 学习者（Learners）。\n\n### 伪代码\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230925175747\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230925175747.png\" style=\"width: 100%;\">\n</div>\n\n> 图片引自：https://pdai.tech/md/algorithm/alg-domain-distribute-x-paxos.html#multi-paxos%E7%AE%97%E6%B3%95\n\n1. 获取一个 `Proposal ID` n，为了保证 `Proposal ID` 唯一，可采用 时间戳+Server ID 生成；\n2. Proposer 向所有 Acceptors 广播 Prepare(n) 请求；\n3. Acceptor 比较 n 和 minProposal，如果 n>minProposal，minProposal=n，并且将 acceptedProposal 和 acceptedValue 返回；\n4. Proposer 接收到过半数回复后，如果发现有 acceptedValue 返回，将所有回复中 acceptedProposal 最大的 acceptedValue 作为本次提案的 value，否则可以任意决定本次提案的 value；\n5. 到这里可以进入第二阶段，广播 Accept(n,value) 到所有节点；\n6. Acceptor 比较 n 和 minProposal，如果 n>=minProposal，则acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后，返回；否则，返回 minProposal。\n7. 提议者接收到过半数请求后，如果发现有返回值 result >n，表示有更新的提议，跳转到1；否则 value 达成一致。\n\n### Basic Paxos 活锁问题\n\n当某 Proposer 提交的 Proposal 被拒绝时，可能存在因为 Acceptor 承诺返回了更大编号的 Proposal，该 Proposer 提高 Proposal 编号继续提交的情况。一旦出现这种情况，两个 Proposer 都发现自己的编号过低转而提出更高编号的 Proposal，显而易见。这会导致死循环，该现象被称为**活锁**。用一句通俗的话来描述**活锁现象**：*你编号高，我再比你更高，反复如此，算法永远无法结束*。\n\n# Multi-Paxos\n\n> Basic-Paxos 可以针对某个值达成共识，一旦遇到一系列的值达成共识时就会出现问题\n>\n> Multi-Paxos 是一种思想，不是算法。Multi-Paxos 算法是通过 Multi-Paxos 思想实现的算法的统称（如 Raft 算法）\n\nBasic-Paxos 在针对某个值达成共识的时候，共分为**准备、接受、学习**三个阶段，其实在经过前两个阶段后就已经达成共识了，如果通过执行多次 Basic-Paxos 来实现一系列值的共识，会存在几个问题：\n\n* 如果多个提议者同时提交提案，可能出现因为提案编号冲突，在准备阶段没有提议者接受到大多数准备响应，协商失败，需要重新协商。比如：一个5节点的集群，如果3个节点作为提议者同时提案，就可能发生因为没有提议者接收大多数响应（比如1个提议者接收到1个准备响应，另外2个提议者分别接收到2个准备响应）而准备失败，需要重新协商。\n* 准备和接受阶段需要进行很多次 RPC 通讯，耗性能、延迟大。\n\n## 领导者\n\nMulti-Paxos 引入了**领导者**角色，使**领导者作为唯一的提议者**，这样就不存在多个提议者同时提交的情况，即：不存在提案冲突的情况\n\n* 选举领导者同样可以通过 Basic Paxos 实现\n\n---\n\n> 假设领导者是稳定的\n\n## 优化 Basic-Paxos 执行\n\n“当领导者处于稳定状态时，可以省掉准备阶段，直接进入接受阶段”。原来是一堆人需要商议，有了领导者之后，领导者直接拍板，就省去了准备这一阶段\n","tags":["Paxos"],"categories":["分布式算法"]},{"title":"CAP 理论 & ACID 理论 & BASE 理论","url":"/2023/09/765e4d48.html","content":"# CAP 理论\n\n> CAP理论是一个很好的思考框架，它对分布式系统的特性做了高度抽象，比如抽象成了一致性、可用性和分区容错性，并对特性间的冲突（也就是CAP不可能三角）做了总结。一旦掌握它，你就像拥有了引路人，自然而然就能根据业务场景的特点进行权衡，设计出适合的分区容错一致性模型\n> CAP 是一个**学术性理论**，它并没有考虑网络延时等问题，之后的**BASE定理**就是一个工程性的理论了\n\n<!-- more -->\n\n## CAP三指标\n\n> **CAP 是对数据瞬时状态的解释**\n\n* 一致性（Consistency）：客户端的每次操作，不管访问哪个节点，要么读到的是同一份数据，要么读取失败。强调的是数据正确，即对客户端而言，每次读都能读取到最新写入的数据\n* 可用性（Availability）：任何来自客户端的请求，必定能得到响应数据。**这个指标强调的是服务可用，但不保证数据正确。**\n* 分区容错性（Partition Tolerance）：当我们的系统使用分布式部署时，那个我们的数据（请求机器请求处理期间产生的数据）必定会在不同的节点进行处理，这个时候数据就产生了**网络分区**，即：处理数据的节点的数据必定会与其他节点不一致，而对于这种现象，我们必须容忍，没办法处理。\n\n## CAP不可能全部满足\n\nCAP不能三角最初是埃里克·布鲁尔（Eric Brewer）基于自己的工程实践，提出的一个猜想，后被赛斯·吉尔伯特（Seth Gilbert）和南希·林奇（Nancy Lynch）证明，证明过程可以参考论文[《Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant web services》](https://dl.acm.org/citation.cfm?id=564601)\n\n需要注意：证明过程中的 **一致性（Consistency）** 限定了是原子一致性\n\n* 基于对CAP三指标的含义的理解，我们也可以很容易的证明CAP不可能同时满足：单体应用可以同时满足 CA；分布式部署的应用一定存在数据分区现象，所以必须容忍 P 的存在\n\n## 如何使用CAP理论\n\n* **作为分布式系统，分区容错性（P）是一定存在并且已经实现的** 。\n* 当选择了一致性（C）的时候，一定会读到最新的数据，不会读到旧数据，但如果因为消息丢失、延迟过高发生了网络分区，那么这个时候，当集群节点接收到来自客户端的读请求时，为了不破坏一致性，可能会因为无法响应最新数据，而返回出错信息。\n* 当选择了可用性（A）的时候，系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点将无法返回最新的特定信息，它们将返回自己当前的相对新的信息。\n\n至于如何选择：如果读操作会读到旧数据，影响到了系统运行或业务运行（也就是说会有负面的影响），推荐选择C，否则选A。\n\n# ACID 理论\n\n> 此为事务的性质要求：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。\n\n在单机上实现并不难，比如可以通过锁、时间序列等机制保障操作的顺序执行，让系统实现ACID特性。但是设计分布式系统，就会比较难……其实，**ACID理论是对事务特性的抽象和总结，方便我们实现事务。即：如果实现了操作的ACID特性，那么就实现了事务。**\n\n## 分布式事务\n\n还是以苏秦为例，假如苏秦需要和赵魏韩确认是否可以攻打秦国\n\n### 二阶段提交\n\n1. 苏秦发送消息给赵，然后赵就作为一个**协调者（Coordinator）** 联系魏和韩，发起二阶段提交\n2. 赵发起二阶段提交之后，进入**提交请求阶段（投票阶段）**。然后等待魏和韩的回复\n3. 赵得到全部的回复结果（包括他自己的评估结果），进入**提交执行阶段（又称完成阶段）**，统计投票结果\n4. 赵按照“要么全部执行，要么放弃”的原则统计投票结果，然后将结果同步给魏和韩\n5. 接到通知后，如果结果是**全部执行**，赵魏韩执行事务，魏韩执行完毕后将事务的执行结果通知给赵\n6. 赵将结果返回给苏秦\n\n在这个例子中：\n\n* 你可以将“赵明天攻打秦国、魏明天攻打秦国、韩明天攻打秦国”，理解成一个分布式事务操作；\n* 将赵、魏、韩理解为分布式系统的三个节点，其中，赵是协调者（Coordinator），将苏秦理解为业务，也就是客户端；\n* 将消息理解为网络消息；\n* 将“明天能否攻打秦国，预留时间”，理解为评估事务中需要操作的对象和对象状态，是否准备好，能否提交新操作。\n\n需要注意的是，在第一个阶段，每个参与者投票表决事务是放弃还是提交。一旦参与者投票要求提交事务，那么就不允许放弃事务。也就是说，**在一个参与者投票要求提交事务之前，它必须保证能够执行提交协议中它自己那一部分，即使参与者出现故障或者中途被替换掉。** 这个特性，是我们需要在代码实现时保障的。\n\n在第二个阶段，事务的每个参与者执行最终统一的决定，提交事务或者放弃事务。这个约定，是为了实现ACID中的原子性。\n\n---\n\n[二阶段提交协议](https://courses.cs.washington.edu/courses/cse551/09au/papers/CSE550BHG-Ch7.pdf)最早是用来实现数据库的分布式事务的，不过现在最常用的协议是XA协议。这个协议是X/Open国际联盟基于二阶段提交协议提出的，也叫作X/Open Distributed Transaction Processing（DTP）模型，比如MySQL就是通过MySQL XA实现了分布式事务。\n\n但是不管是原始的二阶段提交协议，还是XA协议，都存在一些问题：\n\n* 在提交请求阶段，需要预留资源，在资源预留期间，其他人不能操作（比如，XA在第一阶段会将相关资源锁定）；\n* 数据库是独立的系统。\n\n因为上面这两点，我们无法根据业务特点弹性地调整锁的粒度，而这些都会影响数据库的并发性能。\n\n### TCC（try-conform-cancel）\n\n> TCC是Try（预留）、Confirm（确认）、Cancel（撤销） 3个操作的简称，它包含了预留、确认或撤销这2个阶段。\n\n1. 预留阶段：\n   * 注册确认操作和撤销操作：苏秦分别发送消息通知赵、魏、韩，让他们预留明天的时间和相关资源。然后苏秦实现确认操作（明天攻打秦国），和撤销操作（取消明天攻打秦国）。\n   * 苏秦收到赵、魏、韩的预留答复\n2. 如果预留阶段执行都没有问题，三国都确认可以攻打秦国，就进入确认阶段：\n   * 苏秦执行确认操作，通知赵、魏、韩明天攻打秦国。\n   * 收到确认操作的响应，完成分布式事务。\n3. 如果预留阶段执行出现了问题，比如魏说军队还在路上，没有就位，就进入撤销阶段：\n   * 苏秦执行撤销操作，通知赵、魏、韩取消明天攻打秦国的计划。\n   * 收到撤销操作的响应。\n\n---\n\nTCC本质上是补偿事务，**它的核心思想是针对每个操作都要注册一个与其对应的确认操作和补偿操作（也就是撤销操作）。** 它是一个业务层面的协议，也可以将TCC理解为编程模型，TCC的3个操作是需要在业务代码中编码实现的，为了实现一致性，确认操作和补偿操作必须是等幂的，因为这2个操作可能会失败重试。\n\nTCC不依赖于数据库的事务，而是在业务中实现了分布式事务，这样能减轻数据库的压力，但对业务代码的入侵性也更强，实现的复杂度也更高。所以，在需要分布式事务能力时，优先考虑现成的事务型数据库（比如MySQL XA），当现有的事务型数据库不能满足业务的需求时，再考虑基于TCC实现分布式事务。\n\n# BASE 理论\n\n> BASE 理论追求的是服务的可用性，其核心是**基本可用（Basically Available）** 和**最终一致性（Eventually consistent）**，而**软状态（Soft state）** 其实是实现服务可用性时，系统数据的一种过渡状态\n\n## 基本可用\n\n> 基本可用即：当分布式系统出现不可预知的故障时，允许损失部分功能的可用性（服务降级）来保障核心功能的可用性，从而实现基本可用\n\n### 流量削峰\n\n避免集中请求，按照实际需求将用户的请求错开。如：12306 不同地方的车票售票时间不同，这样，在春运期间，购买不同目的地的用户就会在不同时间买票，从而达到流量削峰的目的\n\n### 延迟响应\n\n在出现超出系统处理能力的突发流量时，将用户提交的请求放在队列中，通过牺牲响应时间的可用性，保障核心功能的运行。如：12306 在春运、国庆期间买票时，会出现排队中的现象，页面会显示排队中\n\n### 体验降级\n\n比如，系统突然出现了网络热点，好多用户涌进来了，产生了海量突发流量，于是系统过载了，大量图片因为网络超时原因无法显示，此时就可以使用小图片代替原始图片，通过降低图片的清晰度和大小提升系统的处理能力\n\n### 过载保护\n\n过载保护指的是流量激增时，将用户的请求放在请求队列中，如果请求等待超时了，就直接拒绝请求；或者是，当用来存储用户请求的队列满了之后，就清除队列中一定数量的排队请求，以此来保护系统不过载\n\n## 最终一致性\n\n最终一致性指的是系统的数据副本经过一段时间的处理合同后，最终可以达到一个一致的状态。即：在距离达到数据一致，有一定的延迟。\n\n强一致性实际上就是不存在数据延迟的最终一致性。现在的互联网系统，大多数都是需要数据的最终一致性的，只有实在无法使用最终一致性，才会使用强一致性或事务。\n","tags":["CAP、ACID、BASE"],"categories":["分布式算法"]},{"title":"idea jrebel 插件激活","url":"/2023/09/a00d3e8b.html","content":"# JRebel 激活\n\n## jrebel 激活服务器搭建\n\n1. 下载激活程序\n\n   [https://github.com/ilanyu/ReverseProxy/releases/download/v1.4/ReverseProxy_linux_amd64]()\n\n<!-- more -->\n\n2. 使用docker创建服务\n\n   * Dockerfile 文件\n\n     ```plaintext\n     FROM ubuntu:20.04\n\n     LABEL author=\"ann-zhgy\" \n     LABEL maintainer=\"wb_zhanggaoyu@meituan.com\"\n\n     WORKDIR /usr/share\n\n     ADD ReverseProxy_linux_amd64 /usr/share\n\n     RUN chmod 777 /usr/share/ReverseProxy_linux_amd64\n     CMD [ \"./ReverseProxy_linux_amd64\" ]\n     EXPOSE 8888\n     ```\n   * docker-compose 文件\n\n     ```yml\n     version: '3.7'\n     services:\n       jrebel-active: \n         build: \n           context: .\n           dockerfile: Dockerfile\n         ports:\n           - 8888:8888\n     ```\n   * 下载的文件、Dockerfile文件、docker-compose.yml 文件都需要在同一个文件夹内，ports 前面的那个端口找一个没有被占用的端口即可\n\n之后在idea激活jrebel即可\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230915154918\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230915154918.png\" style=\"width: 100%;\">\n</div>\n\n连接后面的字符串是 GUID 串，可以在 [https://www.iamwawa.cn/guid.html](https://www.iamwawa.cn/guid.html) 生成\n\n# idea 激活教程\n\n> [https://blog.idejihuo.com/jetbrains/intellij-idea-2023-1-3-activation-code-cracking-to-2099.html](https://blog.idejihuo.com/jetbrains/intellij-idea-2023-1-3-activation-code-cracking-to-2099.html)\n\n# MyBatisCodeHelperPro全版本激活教程（除非作者更改了激活方式）\n\n> 引用：http://www.ytxy.xyz/pages/e0c8bf/\n\n## 更新说明\n\n系统：macOS（Windows同理）\nIDE：IntelliJ IDEA 2023.1.5 （哪个版本都可以）\nMyBatisCodeHelper Pro 3.2.2（哪个版本都可以）\n\n## 环境准备\n\n1. 从插件市场下载MyBatisCodeHelper Pro\n2. 下载cfr的jar包\n\n   下载地址：[https://github.com/leibnitz27/cfr/releases](https://github.com/leibnitz27/cfr/releases)\n\n   下最新的就行\n\n## 正式教程\n\n### 找到MyBatisCodeHelper Pro的jar包\n\n1. Windows：在地址栏输入 `%appdata%\\JetBrains\\`找到idea安装目录，里面有个 `plugins`文件夹，然后里面有个文件夹 `MyBatisCodeHelper-Pro`\n2. MacOS：`/Users/用户名/Library/Application Support/JetBrains/IntelliJIdea2023.1/plugins/MyBatisCodeHelper-Pro`\n\n**MacOS的有一点特殊，注意用户名目录和你的idea版本号**\n\n然后进入到lib文件夹，找到 `MyBatisCodeHelper-Pro-obfuss.jar`。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230915153314\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230915153314.png\" style=\"width: 100%;\">\n</div>\n\n将它和刚刚下载的cfr的jar包拷贝到另一个地方，比如桌面，方便修改。\n\n### 反编译jar包\n\n1. 在刚刚两个jar包的目录打开终端（Windows是打开cmd，一个意思）。\n2. 执行命令： java -jar cfr-0.152.jar MyBatisCodeHelper-Pro-obfuss.jar --renamedupmembers true --hideutf false >> result.txt\n\n   需要注意cfr版本号，如果你跟我下载的不是一个版本，需要更改为指定版本。\n\n   过程会比较慢，耐心等待...\n\n   执行完毕文件夹中会出现一个result的文本文件\n\n### 修改前准备/介绍/目标\n\n用一个比较方便的工具打开上面的result.txt。\n\n* 搜索validTo，找到具有paidKey,valid,validTo的类，**不同插件版本，这个类的位置会不一样**\n\n  <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n    <img alt=\"20230915153751\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230915153751.png\" style=\"width: 100%;\">\n  </div>\n* valid为判断是否在有效期的变量，变量定义为下方的private Boolean c\n* validTo为有效时长变量，定义为下方的private Long a;\n* package com.ccnode.codegenerator.T.e是当前类所在的包，类名为e，由此可知当前类的绝对定位为com.ccnode.codegenerator.T.e.e\n\n将要用代码实现的目标，先演练）\n\n1. 修改 `变量c`，也就是代表是否有效的那个变量的get/set方法始终为 `true`\n\n   **(再次提醒：不同的插件版本变量名称也不一样，你要看清楚！)**\n2. 修改变量e，也就是那个代表有效期还剩多久的变量，get/set方法为固定值: `new Long(4797976044000L);`\n\n   **(再次提醒：不同的插件版本变量名称也不一样，你要看清楚！)**\n\n找到了要修改的类的绝对定位com.ccnode.codegenerator.T.e.e，以及要修改get/set方法，下面通过Javassist修改对于的class文件。以实现我们的目标。\n\n### 修改class文件\n\n1. 创建maven项目\n2. 引入 Javassist 依赖\n\n   ```java\n   <!-- javassist -->\n   <dependency>\n       <groupId>org.javassist</groupId>\n       <artifactId>javassist</artifactId>\n       <version>3.28.0-GA</version>\n   </dependency>\n   ```\n3. 代码实现\n\n   ```java\n   public class App {\n       public static void main(String[] args) {\n           try {\n               ClassPool pool = ClassPool.getDefault();\n               // 此处改为你实际的的 MyBatisCodeHelper-Pro-obfuss.jar 的路径\n               pool.insertClassPath(\"/Users/localhost/Library/Application Support/JetBrains/IntelliJIdea2023.1/plugins/MyBatisCodeHelper-Pro/lib/MyBatisCodeHelper-Pro-obfuss.jar\");\n               // 通过绝对定位，加载指定的类\n               CtClass cc = pool.get(\"com.ccnode.codegenerator.T.e.b\");\n\n               // 获取validTo的get方法\n               // public Long e()\n               CtMethod getValidToMethod = cc.getDeclaredMethod(\"e\");\n\n               // 获取validTo的set方法的参数：Long\n               CtClass[] params = new CtClass[] { pool.get(\"java.lang.Long\") };\n               // 获取validTo的set方法\n               // public void a(Long l2)\n               CtMethod setValidToMethod = cc.getDeclaredMethod(\"a\", params);\n\n               // 获取valid的set方法的参数：Boolean\n               CtClass[] params1 = new CtClass[] { pool.get(\"java.lang.Boolean\") };\n               // 获取Valid的set方法\n               // public void a(Boolean bl)\n               CtMethod setValidMethod = cc.getDeclaredMethod(\"a\", params1);\n\n               // 获取valid的get方法\n               // public Boolean b()\n               CtMethod getValidMethod = cc.getDeclaredMethod(\"b\");\n\n               // 修改validTo的get方法\n               // 直接返回4797976044000\n               StringBuilder builder = new StringBuilder();\n               builder.append(\"{\")\n                       .append(\"       return new Long(4797976044000L);\")\n                       .append(\"}\");\n               getValidToMethod.setBody(builder.toString());\n\n               // 修改validTo的set方法\n               // 直接设为4797976044000\n               StringBuilder builder1 = new StringBuilder();\n               builder1.append(\"{\")\n                       .append(\"        this.e = new Long(4797976044000L);\")\n                       .append(\"}\");\n               setValidToMethod.setBody(builder1.toString());\n\n               // 修改valid的set方法\n               // 设为True\n               String getValidMethodBuilder = \"{\" +\n                       \"       return Boolean.TRUE;\" +\n                       \"}\";\n               getValidMethod.setBody(getValidMethodBuilder);\n\n               // 修改valid的get方法\n               // 直接返回True\n               String setValidMethodBuilder = \"{\" +\n                       \"this.d = Boolean.TRUE;\" +\n                       \"}\";\n               setValidMethod.setBody(setValidMethodBuilder);\n\n               // 将修改后的Class b写入指定文件夹\n               cc.writeFile(\"/Users/localhost/Desktop/test\");\n           } catch (Exception e) {\n               e.printStackTrace();\n           }\n       }\n   }\n   ```\n\n   以下代码需要注意几点：\n\n   * `pool.insertClassPath(\"MyBatisCodeHelper-Pro-obfuss.jar\");` 需要填写 `MyBatisCodeHelper-Pro-obfuss.jar`在你本机实际的路径！\n   * `cc.writeFile(\"/Users/localhost/Desktop/test\");` 需要填写你能找到的输出路径\n   * 还有就是代码中体现的包名，类名，变量名，都要和上面咱们准备的时候一直，这个一定要注意！！！\n   * 代码都有注释！注意看！\n4. 运行上面的代码后会在你指定的文件夹中生成修改的Class b：可以打开看一下是不是修改成功了\n\n### 替换Class文件\n\n> 一定要先备份原来的 `jar` 包\n\n使用解压缩工具打开jar包，然后替换相对应的class文件即可，之后替换插件文件夹中的jar包\n\n## 查看是否成功\n\n重新打开IEDA，然后找到 激活界面， 随便输入点东西，点击激活，如果出现下面的界面，说明成功了：\n\n**一定要大退IDEA!!!一定要大退IDEA!!!一定要大退IDEA!!!**\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230915154817\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230915154817.png\" style=\"width: 100%;\">\n</div>\n","tags":["idea-jrebel插件激活","passwd-b"],"categories":["idea-jrebel插件激活"]},{"title":"拜占庭将军问题","url":"/2023/04/fc431d4d.html","content":"> 拜占庭将军问题（The Byzantine Generals Problem），它其实是借拜占庭将军的故事展现了分布式共识问题，还探讨和论证了解决的办法。\n\n<!-- more -->\n\n# 苏秦的困境\n\n战国时期，齐、楚、燕、韩、赵、魏、秦七雄并立，后来秦国的势力不断强大起来，成了其余六国的共同威胁。于是，这六个国家决定联合，全力抗秦，免得被秦国各个击破。一天，苏秦作为合纵长，挂六国相印，带着六国的军队叩关函谷，驻军在了秦国边境，为围攻秦国作准备。但是，因为各国军队分别驻扎在秦国边境的不同地方，所以军队之间只能通过信使互相联系，这时，苏秦面临了一个很严峻的问题：如何统一大家的作战计划？\n\n万一一些诸侯国在暗通秦国，发送误导性的作战信息，怎么办？如果信使被敌人截杀，甚至被敌人间谍替换，又该怎么办？这些都会导致自己的作战计划被扰乱，然后出现有的诸侯国在进攻，有的诸侯国在撤退的情况，而这时，秦国一定会趁机出兵，把他们逐一击破的。\n\n**所以，如何达成共识，制定统一的作战计划呢？苏秦他很愁。**\n\n这个故事，是拜占庭将军问题的一个简化表述，苏秦面临的就是典型的共识难题，也就是如何在可能有误导信息的情况下，采用合适的通讯机制，让多个将军达成共识，制定一致性的作战计划？\n\n# 二忠一叛难题\n\n先假设只有三个国家要攻打秦国，这三个国家有三个将军，分别叫齐、楚、燕。同时，又因为秦国很强大，所以只有半数以上的将军参与进攻，才能击败敌人，在这个期间，将军们彼此之间需要通过信使传递消息，然后协商一致之后，才能在同一时间点发动进攻。\n\n有一天，这三位将军各自一脸严肃地讨论明天是进攻还是撤退，并让信使传递信息，按照“少数服从多数”的原则投票表决，两个人意见一致就可以了，比如：\n\n1. 齐根据侦查情况决定撤退；\n2. 楚和燕根据侦查信息，决定进攻。\n\n那么按照原则，齐也会进攻。最终，3支军队同时进攻，大败秦军。（本身的决定也是影响最终决定的因素之一，比如齐准备撤退，楚燕准备进攻，按照少数服从多数原则，2进攻 > 1撤退，最终齐进攻）\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230505095625\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230505095625.png\" style=\"width: 100%;\">\n</div>\n\n---\n\n问题来了：如果有人暗通秦国，做了叛徒，就会出现作战不一致的情况\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230911103611\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230911103611.png\" style=\"width: 100%;\">\n</div>\n\n* 如上图所示，齐最终选择撤退，楚选择进攻，叛徒随机而变，最终的结果就是楚军失败，最终齐楚被秦逐一蚕食。这就是**二忠一叛**难题\n\n## 二忠一叛难题怎么解决\n\n### 解决办法一：口信消息型拜占庭问题之解\n\n三位将军分别拨出一部分军队交给苏秦带领，苏芩参与作战计划的讨论并执行命令。这样，原本的 3 位将军的作战讨论就变成了 4 位将军的作战讨论，这样可以增加讨论中忠诚将军的数量。\n\n按照上面的约定，如果没有命令，就执行预设的默认命令：“撤退\"。除此之外，还约定一些流程来发送作战信息、执行作战指令，比如，**进行两轮作战信息协商**。\n\n**第一轮：**\n\n* 先发送作战消息的将军作为指挥官，其他将军作为副官\n* 指挥官将其作战消息发送给每位副官\n* 每位副官，将从指挥官处收到左展信息，作为其作战指令；如果没有收到消息，使用“撤退\"作为作战指令\n\n**第二轮：**\n\n* 除了第一轮的指挥官外，剩余的3位将军将分别作为指挥官想另外两位见滚发送作战消息\n* 这三位将军将按照“少数服从多数\"的原则执行收到的作战指令\n\n**图示：**\n\n叛徒作为副将\n\n第一轮：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230911143342\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230911143342.png\" style=\"width: 100%;\">\n</div>\n\n第二轮：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230911144114\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230911144114.png\" style=\"width: 100%;\">\n</div>\n\n* 在叛徒作为副将捣乱的情况下，按照少数服从多数的原则，在第二轮投票统计中，齐楚燕都会选择进攻\n\n叛徒作为统领\n\n第一轮：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230911144557\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230911144557.png\" style=\"width: 100%;\">\n</div>\n\n第二轮：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230911144643\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230911144643.png\" style=\"width: 100%;\">\n</div>\n\n* 在叛徒作为统领时，在第二轮投票中，最终齐楚燕也是会选择进攻\n\n这个解决办法是兰伯特在论文《[The Byzantine Generals Problem](https://www.microsoft.com/en-us/research/publication/byzantine-generals-problem/)》中提到的口信消息型拜占庭问题之解：**如果叛将人数为 m，将军人数不能少于 3m + 1**，那么拜占庭将军问题就能解决了。\n\n---\n\n这个算法有个前提，也就是叛将人数 m，或者说能容忍的叛将数 m，是已知的。在这个算法中，叛将数 m 决定递归循环的次数（也就是说，叛将数 m 决定将军们要进行多少轮作战信息协商），即 $m+1$ 轮（所以，你看，只有楚是叛变的，那么就进行了两轮）。你也可以从另外一个角度理解：n 位将军，最多能容忍 $(n - 1) / 3$ 位叛将。关于这个公式，你只需要记住就好了，推导过程你可以参考论文。\n\n不过，这个算法虽然能解决拜占庭将军问题，但它有一个限制：如果叛将人数为m，那么将军总人数必须不小于 $3m + 1$。\n\n在二忠一叛的问题中，在存在1位叛将的情况下，必须增加1位将军，将3位将军协商共识，转换为4位将军协商共识，这样才能实现忠诚将军的一致性作战计划。\n\n### 解决办法二：签名消息型拜占庭问题之解\n\n苏秦还可以通过签名的方式，在不增加将军人数的情况下，解决二忠一叛的难题。首先，苏秦要通过印章、虎符等信物，实现这样几个特性：\n\n* 忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现；\n* 任何人都能验证将军签名的真伪。\n\n这时，如果忠诚的将军，比如齐先发起作战信息协商，一旦叛将小楚修改或伪造收到的作战信息，那么燕在接收到楚的作战信息的时候，会发现齐的作战信息被修改，楚已叛变，这时他将忽略来自楚的作战信息，最终执行齐发送的作战信息。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230912112238\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230912112238.png\" style=\"width: 100%;\">\n</div>\n\n如果是叛徒楚先发送误导的消息，那么，齐燕将按照一定的规则在排序后的所有接收到的指令中选取一个指令执行，最终执行一致的作战计划。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230912112916\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230912112916.png\" style=\"width: 100%;\">\n</div>\n\n这个解决办法，是兰伯特在论文中提到的签名消息型拜占庭问题之解。而通过签名机制约束叛将的叛变行为，任何叛变行为都会被发现，也就会实现无论有多少忠诚的将军和多少叛将，忠诚的将军们总能达成一致的作战计划。\n\n签名消息的拜占庭问题之解，也是需要进行m+1轮（其中m为叛将数，所以你看，只有楚、燕是叛变的，那么就进行了三轮协商）。你也可以从另外一个角度理解：n位将军，能容忍(n - 2) 位叛将（只有一位忠将没有意义，因为此时不需要达成共识了）。同时，这也是一个比较理论化的算法。\n\n---\n\n拜占庭问题是最为复杂的分布式故障的场景，因为其同时包含了故障场景和恶意场景。在存在恶意场景时，必须使用**拜占庭容错算法**；仅存在故障场景时，只需要使用**非拜占庭容错算法|故障容错算法**就可以了\n","tags":["拜占庭问题"],"categories":["分布式算法"]},{"title":"学习路径","url":"/2023/04/32213c97.html","content":"> 随着项目的发展，企业在实际生产中使用的是都是分布式进行部署，但是既然是分布式，那就会涉及到分布式不得不面对的问题：容错、可用、一致性\n\n<!-- more -->\n\n# 分布式算法的四度空间（四个重要指标）\n\n|            | 拜占庭容错 |  一致性  | 性能 | 可用性 |\n| :--------: | :--------: | :------: | :--: | :----: |\n|    2PC    |     否     |  强一致  |  低  |   低   |\n|    TCC    |     否     | 最终一致 |  低  |   低   |\n|   Paxos   |     否     |  强一致  |  中  |   中   |\n|    ZAB    |     否     | 最终一致 |  中  |   中   |\n|    Raft    |     否     |  强一致  |  中  |   中   |\n|   Gossip   |     否     | 最终一致 |  高  |   高   |\n| Quorum NWR |     否     |  强一致  |  中  |   中   |\n|    PBFT    |     是     |   N/A   |  低  |   中   |\n|    POW    |     是     |   N/A   |  低  |   中   |\n\n## 拜占庭容错\n\n拜占庭错误是莱斯利·兰伯特在《拜占庭将军问题》中提出的一个错误模型，描述了一个完全不可信的场景，除了存在故障行为，还存在恶意行为。顾名思义，拜占庭容错（Byzantine Fault Tolerance，BFT），就是指能容忍拜占庭错误了。\n\n斐拜占庭容错又叫做**故障容错（Crash Fault Tolerance，CFT）**，解决的是分布式系统中存在故障，但不存在恶意节点的共识问题，比如进程奔溃，服务器硬件故障等等。\n\n一般而言，在可信环境（比如企业内网）中，系统具有故障容错能力就可以了，常见的算法有二阶段提交协议（2PC）、TCC（Try-Confirm-Cancel）、Paxos算法、ZAB协议、Raft算法、Gossip协议、Quorum NWR算法。\n\n而在不可信的环境（比如有人做恶）中，这时系统需要具备拜占庭容错能力，常见的拜占庭容错算法有POW算法、PBFT算法。\n\n## 一致性\n\n分布式系统中，一致性分为三类：\n\n* 强一致性：保证写操作完成后，任何后续访问都能马上读取到更新后的值\n* 弱一致性：写操作完成后，系统不能保证后续访问都能读取到更新后的值\n* 最终一致性：保证如果对某个对象没有新的写操作了，最终后续访问都能读取到相同的最近更新的值\n\n但是，强一致性是有多重含义的：\n\n1. 在埃里克·布鲁尔的猜想中，CAP中的强一致性（也就是C）是指ACID的C，系统状态的一致性，而这种一致性，可以通过二阶段提交协议来实现。\n2. 在CAP定理中，CAP中的强一致性（也就是C）是指原子一致性（也就是线性一致性）。其中，Paxos、Raft能实现线性一致性，而ZooKeeper基于读性能的考虑，它通过ZAB协议提供的是最终一致性。\n\n一般而言，在需要系统状态的一致性时，你可以考虑采用二阶段提交协议、TCC。在需要数据访问是的强一致性时，你可考虑Raft算法。在可用性优先的系统，你可以采用Gossip协议来实现最终一致性，并实现Quorum NWR来提供强一致性。\n\n另外，很多人将Consensus（共识）当成了一致性，也就是称为Paxos、Raft为一致性算法，其实Paxos和Raft是共识算法。而之所以出现这个问题，是因为在很多中文文章中，将Consensus和Consistency都翻译成了一致性，其实这样是不合适的，因为共识（Consensus）和一致性（Consistency）是两个完全不同的概念。\n\n* 共识：各节点就指定值（Value）达成共识，而且达成共识后的值，就不再改变了。\n* 一致性：是指写操作完成后，能否从各节点上读到最新写入的数据，如果立即能读到，就是强一致性，如果最终能读到，就是最终一致性。\n\n提到共识算法，Paxos是一个必须要提及的话题，而且ZAB协议、Raft算法都可以看作是Paxos变种，所以，你需要了解Paxos算法。\n\n但因为Paxos算法的可理解性和可编程性痛点突出，所以在实际场景中，最常的共识算法是Raft，我们可以基于Raft实现强一致性系统\n\n## 可用性\n\n可用性说的是任何来自客户端的请求，不管访问哪个非故障节点，都能得到响应数据，但不保证是同一份最新数据，可用性强调的是服务可用。\n\n一般来讲，采用Gossip协议实现最终一致性系统，它的可用性是最高的，因为哪怕只有一个节点，集群还能在运行并提供服务。其次是Paxos算法、ZAB协议、Raft算法、Quorum NWR算法、PBFT算法、POW算法，它们能容忍一定数节点故障。\n\n最后是二阶段提交协议、TCC，只有当所有节点都在运行时，才能工作，可用性最低。\n\n## 性能\n\n一般来讲，采用Gossip协议的AP型分布式系统，具备水平扩展能力，读写性能是最高的。其次是Paxos算法、ZAB协议、Raft算法，因为它们都是领导者模型，写性能受限于领导者，读性能取决于一致性实现。最后是二阶段提交协议和TCC，因为在实现事务时，需要预留和锁定资源，性能相对低。\n","tags":["分布式算法学习路径"],"categories":["分布式算法"]},{"title":"动归 ——（四）动态规划是啥？","url":"/2023/04/61a8be5c.html","content":"# 动态规划是一种思想\n\n“动态规划算法\"，相信有很多人这个叫，但是更贴切的来说，动态规划是一种思想，指导我们解决问题的思想\n\n<!-- more -->\n\n## 算法？思想？\n\n我们知道**算法 + 数据结构**，这是一个紧密的组合，比如说要对一个无序数组排序，数据结构就是数组，可供选择的算法比如：快速排序、选择排序等\n\n所以，算法其实是一类问题的经验总结，是解决问题的套路。那么思想是什么呢？在学习《数据结构与算法》这门课时，应该都听过很多算法都是使用的**分治思想**，尤其是在归并排序中经常被提及。\n\n动态规划的思想在于：**你需要利用已经计算好的结果来推导你的计算，即：大规模问题的结果是由小规模问题的结果运算得来的**\n\n**算法是一种经验总结，而思想是用来指导我们解决问题的**\n\n# 动态规划问题的典型特点\n\n## 求“最”优解问题（最大值、最小值）\n\n除非碰到的问题是简单到找出一个数组中最大的值这样，对这种问题来说，你可以对数组进行排序，然后取数组头或尾部的元素，如果觉得麻烦，你也可以直接遍历得到最值。否则，你就得考虑使用动态规划来解决这个问题了。这样的问题一般都会让你求最大子数组、求最长递增子数组、求最长递增子序列或求最长公共子串、子序列等等。\n\n既然是要求最值，不妨先想一下核心问题是什么。其实在真的解决最值问题的时候，你应该按照这样的思考顺序来解决问题：\n\n* 优先考虑使用贪心算法的可能性；\n* 然后是暴力递归进行穷举（但这里的数据规模不大）；\n* 还是不行呢？选择动态规划！\n\n### 1. **乘积最大子数组**\n\n问题：给你一个整数数组 numbers，找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），返回该子数组的乘积。\n\n```\n示例1：\n输入: [2,7,-2,4]\n输出: 14\n解释: 子数组 [2,7] 有最大乘积 14。\n```\n\n```\n示例2：\n输入: [-5,0,3,-1]\n输出: 3\n解释: 结果不能为 15, 因为 [-5,3,-1] 不是子数组，是子序列。\n```\n\n首先，很明显这个题目当中包含一个“最”字，使用动态规划求解的概率就很大。这个问题的目的就是从数组中寻找一个最大的连续区间，确保这个区间的乘积最大。由于每个连续区间可以划分成两个更小的连续区间，而且大的连续区间的结果是两个小连续区间的乘积，因此这个问题还是求解满足条件的最大值，同样可以进行问题分解，而且属于求最值问题。同时，这个问题与求最大连续子序列和比较相似，唯一的区别就是你需要在这个问题里考虑正负号的问题，其它就相同了。\n\n### 2. **最长回文子串**\n\n问题：给定一个字符串s，找到s中最长的回文子串。你可以假设s的最大长度为1000。\n\n```\n示例1：\n输入: \"babad\"\n输出: \"bab\"\n```\n\n```\n示例2：\n输入: \"cbbd\"\n输出: \"bb\"\n```\n\n这个问题依然包含一个“最”字，同样由于求解的最长回文子串肯定包含一个更短的回文子串，因此我们依然可以使用动态规划来求解这个问题。\n\n### 3. **最长上升子序列**\n\n问题：给定一个无序的整数数组，找到其中最长上升子序列的长度。可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n\n```\n示例：\n输入: [10,9,2,5,3,7,66,18]\n输出: 4\n解释: 最长的上升子序列是 [2,3,7,66]，它的长度是 4。\n```\n\n这个问题依然是一个最优解问题，假设我们要求一个长度为5的字符串中的上升自序列，我们只需要知道长度为4的字符串最长上升子序列是多长，就可以根据剩下的数字确定最后的结果。\n\n## 求可行性（True或False）\n\n判断是否存在一条总和为x的路径（如果找到了，就是True；如果找不到，自然就是False），或者让你判断能否找到一条符合某种条件的路径，那么这类问题都可以归纳为求可行性问题，硬币找零就属于求可行性的一种\n\n### 1. **凑零兑换问题**\n\n问题：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。\n\n```\n示例1：\n输入: c1=1, c2=2, c3=5, c4=7, amount = 15\n输出: 3\n解释: 11 = 7 + 7 + 1。\n```\n\n```\n示例2：\n输入: c1=3, amount =7\n输出: -1\n解释: 3怎么也凑不到7这个值。\n```\n\n### 2. **字符串交错组成问题**\n\n问题：给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。\n\n```\n示例1：\n输入: s1=\"aabcc\",s2 =\"dbbca\",s3=\"aadbbcbcac\"\n输出: true\n解释: 可以交错组成。\n```\n\n```\n示例2：\n输入: s1=\"aabcc\",s2=\"dbbca\",s3=\"aadbbbaccc\"\n输出: false\n解释:无法交错组成。\n```\n\n## 求方案总数\n\n比如给定一个数据结构和限定条件，让你计算出一个方案的所有可能的路径，那么这种问题就属于求方案总数的问题。\n\n### 1. **硬币组合问题**\n\n问题：英国的英镑硬币有 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), 和 £2 (200p)。比如我们可以用以下方式来组成2英镑：1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p。问题是一共有多少种方式可以组成n英镑? 注意不能有重复，比如 1英镑+2个50P 和 50P+50P+1英镑是一样的。\n\n```\n示例1：\n输入: 2\n输出: 73682 \n```\n\n### 2. 路径规划问题\n\n问题：一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，共有多少路径？\n\n```\n示例1：\n输入: 2 2\n输出: 2\n```\n\n```\n示例1：\n输入: 3 3\n输出: 6\n```\n\n* 求方案总数的动态规划问题一般都指的是求“一个”方案的所有具体形式。如果是求“所有”方案的具体形式，那这种肯定不是动态规划问题，而是使用递归来遍历出所有方案的具体形式。\n\n# 有些问题并不是动态规划的问题\n\n## 数据不可排序\n\n### **最小的k个数**\n\n问题：输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n\n```\n示例1：\n输入：arr = [3,2,1], k = 2\n输出：[1,2] 或者 [2,1]\n```\n\n```\n示例2：\n输入：arr = [0,1,2,1], k = 1\n输出：[0]\n```\n\n我们发现虽然这个问题也是求“最”值，但其实只要通过排序就能解决\n\n## 数据不可交换（Non-swapable）\n\n还有一类问题，可以归类到我们总结的几类问题里去，但是不存在动态规划要求的重叠子问题（比如经典的八皇后问题），那么这类问题就无法通过动态规划求解\n\n### **全排列**\n\n问题：给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n```\n示例：\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n```\n\n这个问题虽然是求组合，但没有重叠子问题，更不存在最优化的要求\n\n# 由于本人对于动归看的很迷，所以暂时停止了，之后还会继续的\n","tags":["动态规划使用"],"categories":["动态规划"]},{"title":"动归 ——（三）前置 —— 贪心算法","url":"/2023/04/dd74b71d.html","content":"> 贪心算法是求解整体最优的真正思路源头，但是这个算法是有局限性的，它只能在局部最优的思想下工作，**那么当贪心算法失效了怎么办？**\n\n# 从最优化问题到递归\n\n> 贪心算法失效的很大一部分原因在于它算的是 **局部最优解**，所谓局部最优，就是只考虑当前的最大利益，所以在绝大多数情况下，贪心算法获取的是最优解的一个最大近似解\n\n<!-- more -->\n\n## 最优化问题的本质\n\n所谓最优化问题，就是指在某些约束条件下，决定可选择的变量应该取何值，使所选定的目标函数达到最优的问题。\n\n从数学意义上说，最优化方法是一种求极值的方法，即在一组约束为等式或不等式的条件下，使系统的目标函数达到极值，即最大值或最小值。\n\n如果只是从概念上来看最优化问题真的是玄而又玄，所以用硬币找零的例子，引出最优化的概念。\n\n在数学里一切都是函数，现在我们先把这个问题用函数形式来表示。为了易于理解，下面我们不会使用向量。\n\n我们假定需要给出$y$元硬币，硬币面额是5元和3元，求出需要的最少硬币数量。所谓的最少硬币数量就是5元硬币和3元硬币的总数，假定5元硬币数量为$x_{0}$，3元硬币数量为$x_{1}$，那么用函数表示就是：\n\n$$\nf(x_{0}, x_{1})=x_{0}+x_{1}\n$$\n\n这就是所谓的“目标函数”。\n\n但是这个函数现在是没有任何限制的，我们希望对此进行约束，使得5元硬币和3元硬币的面值综合为$y$。为此我们需要给出一个约束：\n\n$$\n5x_{0}+3x_{1}=y\n$$\n\n这个时候我们的问题就变成了，当满足这个约束条件的时候，求解函数中的变量$x_{0}$和$x_{1}$，使得目标函数$f(x_{0}, x_{1})$的取值最小。如果用数学的描述方法来说的话，就是下面这样：\n\n$$\n{argmin}_{(x_0,x_1)in S} (x_0+x_1)\n$$\n\n这个就是我们常见的$argmin$表示方式。它的意思是：当$(x_{0}, x_{1})$属于$S$这个集合的时候，希望知道$x_{0} + x_{1}$的最小值是多少。其中$S$集合的条件就是上面的约束。\n\n所以最优化问题在我们生活中是非常普遍的，只不过大多数问题可能都像硬币找零问题这样看起来普普通通，概念其实是不难理解的。\n\n回到硬币找零这个问题上。由于$(x_{0}, x_{1})$都是离散的值，因此所有满足上述约束的$(x_{0}, x_{1})$组合，就是我们最终所求的集合！而这个最优化问题的本质就是：从所有满足条件的组合$(x_{0},x_{1})$中找出一个组合，使得$x_{0}+x_{1}$的值最小。\n\n所以，你会发现在这种离散型的最优化问题中，本质就是从所有满足条件的组合（能够凑出$y$元）中选择出使得我们的目标函数（所有硬币数量之和）最小的那个组合。而这个所谓满足条件的组合不就是$argmin$公式中的那个集合$S$吗？\n\n因此，这种离散型的最优化问题就是去所有满足条件的组合里找出最优解的组合。我曾多次提到的**局部最优**就是在一定条件下的最优解，而**整体最优**就是我们真正希望得到的最优解。\n\n那么我们的视角就转到另一边了：如何去找到这个最优解呢？\n\n## 最优组合的求解策略：枚举与递归\n\n对于大多数问题来说，最直接暴力的方法就是穷举，但是基本上也是效率最低的方法\n\n在硬币找零问题中，假设现在需要给出25元的硬币，有两种组合，分别是(5, 0)和(2, 5)，也就是5个5元硬币，或者2个5元硬币加上5个3元硬币，那么硬币数量最小的组合肯定就是(5, 0)。\n\n所以最简单的方法就是找出所有满足条件的组合，也就是上面两个组合，然后去看这些组合中的最优解。\n\n现在问题来了，怎么获取那些组合呢？递归\n\n# 递归与问题表达\n\n其实最优化问题使用递归处理是很清晰的，递归是处理组合搜索的一种最直观的思路。那么，什么是递归？\n\n## 斐波那契数列\n\n斐波那契数列可以很好的展示递归的概念\n\n> 斐波那契数通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和：\n>\n> $$\n> F(n)=F(n-1)+F(n-2),n>1\n> $$\n>\n> ```\n> 示例 1：\n>\n> 输入：2\n> 输出：1\n> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1。\n> ```\n>\n> ```\n> 示例 2：\n>\n> 输入：3\n> 输出：2\n> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2.\n> ```\n\n这个问题最简单的实现：\n\n> `AbstraceFibonacci` 为了测试方便，抽取抽象类\n>\n> ```java\n> public abstract class AbstractFibonacci {\n>     @Getter(AccessLevel.PROTECTED)\n>     private int count;\n>\n>     /**\n>      * 获取计算结果\n>      * @param n 第几个斐波那契数\n>      * @return int\n>      */\n>     public int getFibonacciResult(int n) {\n>         if (n < 1) {\n>             throw new IllegalArgumentException();\n>         }\n>         startStatisticsCalcCount();\n>         preCalcHandle(n);\n>         return calcResult(n);\n>     }\n>\n>     /**\n>      * 获取计算的次数\n>      * @return int\n>      */\n>     public abstract int calcCount();\n>\n>     /**\n>      * 具体的计算的逻辑\n>      * @param n 第几个斐波那契数\n>      * @return int\n>      */\n>     protected abstract int calcResult(int n);\n>\n>     /**\n>      * 计算前处理\n>      * @param n 第几个斐波那契数\n>      */\n>     protected void preCalcHandle(int n) {}\n>\n>     /**\n>      * 计算次数自增\n>      */\n>     protected final void countAutoincrementOne() {\n>         count++;\n>     }\n>\n>     /**\n>      * 初始化计算次数，开始统计\n>      */\n>     private void startStatisticsCalcCount() {\n>         this.count = 0;\n>     }\n> }\n> ```\n\n* 循环实现\n\n  ```java\n  public class LoopFibonacci extends AbstractFibonacci {\n      @Override\n      public int calcResult(int n) {\n          if (n == 1) {\n              return 0;\n          }\n          if (n == 2) {\n              return 1;\n          }\n          int fib1 = 0, fib2 = 1, temp = 0;\n          for (int i = 3; i <= n; i++) {\n              countAutoincrementOne();\n              temp = fib1 + fib2;\n              fib1 = fib2;\n              fib2 = temp;\n          }\n          return temp;\n      }\n\n      @Override\n      public int calcCount() {\n          return getCount();\n      }\n  }\n  ```\n* 递归实现\n\n  ```java\n  public class RecursionFibonacci extends AbstractFibonacci {\n      @Override\n      public int calcResult(int n) {\n          if (n == 1) {\n              return 0;\n          }\n          if (n == 2) {\n              return 1;\n          }\n          countAutoincrementOne();\n          return calcResult(n - 2) + calcResult(n - 1);\n      }\n\n      @Override\n      public int calcCount() {\n          return getCount();\n      }\n  }\n  ```\n* 可以比较一下循环实现和递归实现的不同：递归的实现看起来更加符合题目，更容易理解；循环理解起来相对复杂\n\n---\n\n上文中最后的实现就使用到了递归\n\n# 深入理解递归\n\n## 堆栈与方法状态存储\n\n拿 `Java` 举例，程序运行时，JVM 为每个线程提供了一个虚拟机栈，当方法 A 调用方法 B 时，JVM 会先保存方法 A 在调用点的上下文信息，比如：局部变量、代码行数……之后将方法 B 需要的参数、返回类型等信息封装为一个栈帧压入到虚拟机栈中，因为栈是一个先进后出的结构，方法 B 执行完成后，方法 B 的栈帧就会弹栈，方法 A 再继续执行\n\n* 递归调用一定会有保存现场、封装栈帧等操作，所以一般来说效率是要比循环低很多的\n\n## 递归与回溯\n\n在求解最优化的问题时我们经常使用 **回溯** 这个策略，对于这类问题，回溯和递归一样重要\n\n## 斐波那契数列：递归存在的问题\n\n以递归版的斐波那契数列的递归实现为例，画出执行流程：n = 7\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20230417175449\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230417175449.png\" style=\"width: 100%;\">\n</div>\n\n从上面图片可以看出递归形式的斐波那契是包含很多重复计算的，上文的硬币求解问题一样，存在很多重复计算，这就是暴力穷举的弊端\n\n# 暴力递归的问题与优化\n\n## 问题\n\n暴力递归会穷举所有的情况，但是这种穷举法执行效率低下\n\n上图中看到的那些重复的节点其实就是重叠子的问题\n\n## 优化\n\n递归最重要的优化点就是如何避免重复计算\n\n### 备忘录\n\n所谓备忘录就是将递归的中间计算结果缓存起来，等到再次调用到相同计算时，直接获取结果\n\n1. 斐波那契数列 + 备忘录\n\n   ```java\n   public class RecursionFibonacciWithMemorandum extends AbstractFibonacci {\n       private int[] cache = {};\n\n       @Override\n       public int calcResult(int n) {\n           if (n == 1) {\n               return 0;\n           }\n           if (n == 2) {\n               return 1;\n           }\n           if (cache[n - 1] != -1) {\n               return cache[n - 1];\n           }\n           countAutoincrementOne();\n           int fibonacciN = calcResult(n - 2) + calcResult(n - 1);\n           cache[n - 1] = fibonacciN;\n           return fibonacciN;\n       }\n\n       @Override\n       public int calcCount() {\n           return getCount();\n       }\n\n       @Override\n       protected void preCalcHandle(int n) {\n           cache = new int[n];\n           Arrays.fill(cache, -1);\n       }\n   }\n   ```\n\n   我们可以比较一下三种实现计算次数的区别：\n\n   ```java\n   public static void main(String[] args) {\n       List<AbstractFibonacci> fibonacciList = Arrays.asList(new LoopFibonacci(), new RecursionFibonacci(), new RecursionFibonacciWithMemorandum());\n       fibonacciList.forEach(fibonacci -> {\n           System.out.println(\"------\" + fibonacci.getClass().getName() + \"------\");\n           System.out.println(\"result = \" + fibonacci.getFibonacciResult(21));\n           System.out.println(\"calcCount = \" + fibonacci.calcCount());\n        });\n    }\n   ```\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n       <img alt=\"20230417200313\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230417200313.png\" style=\"width: 100%;\">\n   </div>\n2. 硬币问题 + 备忘录\n\n   ```java\n   public class Demo03 extends AbstractCoinChange {\n       private final int[] cache;\n\n       public Demo03(int total, int[] parValue) {\n           super(total, parValue);\n           cache = new int[total];\n           Arrays.fill(cache, Integer.MIN_VALUE);\n       }\n\n       @Override\n       public int getMinCount() {\n           return getMinCount(getTotal(), 0);\n       }\n\n       private int getMinCount(int total, int parValueIndex) {\n           int parValueLength = getParValue().length;\n           if (parValueLength == parValueIndex) {\n               return NO_RESULT_CODE;\n           }\n           int currCoinValue = getParValue()[parValueIndex];\n           int currCoinValueMaxCount = total / currCoinValue;\n           for (int count = currCoinValueMaxCount; count >= 0; count--) {\n               int rest = total - currCoinValue * count;\n               // 如果余额为 0，说明组合完毕了，直接返回\n               if (rest == 0) {\n                   cache[total - 1] = count;\n                   return count;\n               }\n               if (cache[rest - 1] != Integer.MIN_VALUE) {\n                   return cache[rest - 1];\n               }\n               // 使用剩余的面额尝试组合\n               int restCount = getMinCount(rest, parValueIndex + 1);\n               // 如果没有返回 NO_RESULT_CODE，直接返回\n               if (restCount != NO_RESULT_CODE) {\n                   int result = count + restCount;\n                   cache[rest - 1] = result;\n                   return result;\n               }\n           }\n           return NO_RESULT_CODE;\n       }\n   }\n   ```\n\n   运行结果：\n\n   > ```java\n   > public static void main(String[] args) {\n   >     int total = 794729356;\n   >     int[] parValue = {25, 10, 8, 5, 3};\n   >     List<AbstractCoinChange> coinChangeList = Arrays.asList(new Demo01(total, parValue), new Demo02(total, parValue), new Demo03(total, parValue));\n   >     coinChangeList.forEach(coinChange -> {\n   >         System.out.println(\"------\" + coinChange.getClass().getName() + \"------\");\n   >         long start = System.currentTimeMillis();\n   >         int minCount = -1;\n   >         for (int i = 10000000; i > 0; i--) {\n   >             minCount = coinChange.getMinCount();\n   >         }\n   >         System.out.println(\"result = \" + minCount);\n   >         System.out.println(\"time = \" + (System.currentTimeMillis() - start));\n   >     });\n   > }\n   > ```\n   >\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n       <img alt=\"20230418102559\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic20230418102559.png\" style=\"width: 100%;\">\n   </div>\n\n   `Demo01` 是错误的实现，可以不用看，`Demo02` 是不包含备忘录的实现，`Demo03` 是包含备忘录的实现，可以看出其运行时间差距是很大的\n\n# 硬币问题\n\n我们提到过递归的运行效率通常要比循环慢得多，所以对于硬币问题，或许我们也可以找到使用循环解决的方法呢？\n\n## 递归和循环解决问题思路的不同\n\n我们可以对比斐波那契的两种实现方式：\n\n1. 递归：当使用递归实现时，可以很明显地看到斐波那契的计算公式及定义 $f(n) = f(n-1) + f(n-2)$，所以，使用递归其实是自顶向下的进行计算。我先计算 $f(n)$ 的值，但是我在计算 $f(n)$ 的值的时候发现我需要计算 $f(n-1)$ 和 $f(n-2)$ 的值，那我就去计算 $f(n-1)$ 和 $f(n-2)$ 的值，直到计算到 $f(1)$ 和 $f(2)$，因为 $f(1)$ 和 $f(2)$ 是计算斐波那契的最基础的两个值。\n2. 循环：当使用循环实现时，我们其实是先定义好的 $f(1)$ 和 $f(2)$，然后开始计算 $f(3)$，直到计算到 $f(n)$，所以使用循环其实是自底向上的进行计算\n\n所以，**当我们使用递归加备忘录时，我们需要查询子问题是否计算过，而我们使用循环时，我们是先处理的子问题，然后才处理的大问题，我们可以保证所有的子问题一定是处理过的**\n\n## 循环实现\n\n```java\npublic class Demo04 extends AbstractCoinChange {\n    public Demo04(int total, int[] parValue) {\n        super(total, parValue);\n    }\n\n    @Override\n    public int getMinCount() {\n        int[] result = new int[getTotal() + 1];\n        Arrays.fill(result, NO_RESULT_CODE);\n        result[0] = 0;\n        for (int i = 1; i <= getTotal(); i++) {\n            for (int value : getParValue()) {\n                if (i - value < 0) {\n                    continue;\n                }\n                if (result[i - value] == NO_RESULT_CODE) {\n                    continue;\n                }\n                result[i] = result[i - value] + 1;\n                break;\n            }\n        }\n        return result[getTotal()];\n    }\n}\n```\n\n* 其实在实际测试的时候我们会发现这种方式花费的时间会更长，个人理解应该是计算了很多不必要的计算，比如11块钱，本来计算一下 3、6、11就好了，但是这种方式从 0 到 11 全部计算了一遍，所以花费时间更长\n","tags":["贪心算法"],"categories":["动态规划"]},{"title":"动归 ——（二）前置 —— 贪心算法","url":"/2023/03/7311facc.html","content":"> **任何算法都有它的局限性，贪心算法也如此**\n\n<!-- more -->\n\n# 硬币找零问题\n\n> 问题：给定n种不同面值的硬币，分别记为c[0], c[1], c[2], … c[n]，同时还有一个总金额k，编写一个函数计算出**最少**需要几枚硬币凑出这个金额k？每种硬币的个数不限，且如果没有任何一种硬币组合能组成总金额时，返回 -1。\n>\n> ```plaintext\n> 示例 1：\n>\n> 输入：c[0]=1, c[1]=2, c[2]=5, k=12\n> 输出：3 \n> 解释：12 = 5 + 5 + 2\n> ```\n>\n> ```plaintext\n> 示例 2：\n>\n> 输入：c[0]=5, k=7\n> 输出：-1\n> 解释：只有一种面值为5的硬币，怎么都无法凑出总价值为7的零钱。\n> ```\n\n题目中有一个醒目的提示词，那就是“最少”。嗯，看起来这是一个求最值的问题，其实也好理解，如果题目不在这里设定这一条件，那么所求结果就不唯一了。\n\n所以，这是一个求最值的问题。那么求最值的核心问题是什么呢？嗯，无非就是 **穷举** ，显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币，那么最少的凑法，就是这道题目的答案。\n\n在面试中，一般来说穷举从来都不是一个好方法。除非你要的结果就是所有的不同组合，而不是一个最值。但即便是求所有的不同组合，在计算的过程中也仍然会出现重复计算的问题，我们将这种现象称之为 **重叠子问题** 。\n\n这个关键概念是动态规划当中的一个重要概念。但现在你只需要知道所谓重叠子问题就是：我们在罗列所有可能答案的过程中，可能存在重复计算的情况。\n\n# 贪心算法\n\n所谓贪心算法，就是指它的每一步计算作出的都是在当前看起来最好的选择，也就是说它所作出的选择只是在某种意义上的局部最优选择，并不从整体最优考虑。这两种选择的思路称作 **局部最优解** 和 **整体最优解**。\n\n因此，我们可以得到贪心算法的基本思路：\n\n1. 根据问题来建立数学模型，一般面试题会定义一个简单模型；\n2. 把待求解问题划分成若干个子问题，对每个子问题进行求解，得到子问题的局部最优解；\n3. 把子问题的局部最优解进行合并，得到最后基于局部最优解的一个解，即原问题的答案。\n\n---\n\n回到硬币找零的问题，尝试用贪心算法解决问题：从最大的面值开始兑换，最后得出的硬币总数很有可能就是最少的。\n\n使用一个例子试一试：我们从 c[0]=5, c[1]=3 且k=11 的情况下寻求最少硬币数。按照“贪心原则”，我们先挑选面值最大的，即为5的硬币放入钱包。接着，还有6元待解（即11-5 = 6）。这时，我们再次“贪心”，放入5元面值的硬币。\n\n> Java 实现\n\n> `AbstractCoinChange`：因为我们会有多个测试的实现，所以我们使用一个抽象类定义测试的入口，方便我们随时测试\n>\n> ```java\n> @Getter(AccessLevel.PROTECTED)\n> public abstract class AbstractCoinChange {\n>     protected static final int NO_RESULT_CODE = -1;\n>\n>     /**\n>      * 总值\n>      */\n>     private final int total;\n>\n>     /**\n>      * 面值\n>      */\n>     private final int[] parValue;\n>\n>     public AbstractCoinChange(int total, int[] parValue) {\n>         this.total = total;\n>         // 确保数组可以从大到小排序\n>         this.parValue = Arrays.stream(parValue)\n>                 .boxed()\n>                 .sorted(Comparator.comparing(Integer::intValue).reversed())\n>                 .mapToInt(Integer::intValue)\n>                 .toArray();\n>     }\n>\n>     // 具体算法实现，返回 -1 表示没有结果\n>     public abstract int getMinCount();\n> }\n> ```\n\n```java\npublic class Demo01 extends AbstractCoinChange {\n\n    public Demo01(int total, int[] parValue) {\n        super(total, parValue);\n    }\n\n    @Override\n    public int getMinCount() {\n        int total = getTotal();\n        int[] parValue = getParValue();\n        int result = 0;\n        for (int value : parValue) {\n            int currCount = total / value;\n            int rest = total - value * currCount;\n            result += currCount;\n            if (rest == 0) {\n                return result;\n            }\n            total = rest;\n        }\n\n        return NO_RESULT_CODE;\n    }\n}\n```\n\n这段代码就是简单地从最大的面值开始尝试，每次都会把当前面值的硬币尽量用光，然后才会尝试下一种面值的货币。\n\n但是，有没有发现一个问题？上面的例子中，最后剩余1块钱，但是我们可以轻易地知道 $11 = 5 + 3 + 3$，所以现在是有问题的。\n\n我们将第二次放入的5元硬币取出，放入面值是3元的硬币，就会发现得到的结果是符合要求的，所以我们需要对贪心做改进，使用回溯来解决 `Demo1` 过于贪心的问题\n\n> Java 实现\n\n```java\npublic class Demo02 extends AbstractCoinChange {\n    public Demo02(int total, int[] parValue) {\n        super(total, parValue);\n    }\n\n    @Override\n    public int getMinCount() {\n        int minCount = getMinCount(getTotal(), 0);\n        return minCount;\n    }\n\n    private int getMinCount(int total, int parValueIndex) {\n        int parValueLength = getParValue().length;\n        if (parValueLength == parValueIndex) {\n            return NO_RESULT_CODE;\n        }\n        int currCoinValue = getParValue()[parValueIndex];\n        int currCoinValueMaxCount = total / currCoinValue;\n        for (int count = currCoinValueMaxCount; count >= 0; count--) {\n            int rest = total - currCoinValue * count;\n            // 如果余额为 0，说明组合完毕了，直接返回\n            if (rest == 0) {\n                return count;\n            }\n            // 使用剩余的面额尝试组合\n            int restCount = getMinCount(rest, parValueIndex + 1);\n            // 如果没有返回 NO_RESULT_CODE，直接返回\n            if (restCount != NO_RESULT_CODE) {\n                return count + restCount;\n            }\n        }\n        return NO_RESULT_CODE;\n    }\n}\n```\n\n通过添加回溯，我们得到了符合题目要求的解法。\n\n# 贪心算法的局限性\n\n由于贪心算法是为了获取局部最优解，所以我们遇到了第一个解法的问题，局部最优没办法获取到结果。但是，局部最优这个思路是对的，整体最优就是多个局部最优的组合！\n\n贪心的思路就是我们最优化求解的根本思想，所有的方法只不过是针对贪心思路的改进和优化。回溯解决的是正确性问题，而动态规划则是解决时间复杂度的问题。\n","tags":["贪心算法"],"categories":["动态规划"]},{"title":"动归 ——（一）动态规划学习方法","url":"/2023/03/91e3fecf.html","content":"# 1、建立扎实的基础知识体系\n\n1. 先掌握基础的数据结构和算法，再来谈动态规划\n\n   > 动态规划不仅名字听起来十分高级，它也的确是一种高级的解决问题的思想。为了更好地理解这个思想，掌握基础数据结构就显得尤为重要了，比如高维数组这样的数据结构，就经常出现在动态规划解法当中。其次是算法，像是递归、搜索和迭代这些常见的算法，都会作为工具在动态规划解法中使用。\n   >\n\n<!-- more -->\n\n2. 锻炼编码能力\n\n   > 比如：是否该给循环添加等号？\n   >\n   > 1. 加等号？\n   >    `for (int i = 0; i <= MAX_COUNT; i++) { ... }`\n   > 2. 不加等号？\n   >    `for (int i = 0; i < MAX_COUNT; i++) { ... }`\n   > 3. 换个方法？\n   >    `for (int i = 0; i < MAX_COUNT + 1; i++) { ... }`\n   >\n   > 在练习的过程中一定要**注重细节！**\n   >\n\n# 2、透彻理解动态规划基本方法论\n\n1. 动态规划是一种思想，是一种高级方法。相比较而言，算法是一种经验总结和套路，是很容易落实到实践上的，但是思想是一种指导，**指导我们怎么解决问题**，所以这个东西是比较难落实到实践上来的\n2. 我们必须找一些规律来指导我们解决动态规划的问题。比如：寻找子问题、递归求解、重叠子问题与无后效性、状态存储。\n3. 在理解这些概念及其背后的深意之后，我们需要对其进行归纳总结。目的在于：你可以拥有一个清晰的判断标准：**哪些问题应该使用动态规划来解，而哪些不应该或不能使用动态规划来解。**避免盲目地使用动态规划来解题，弄清楚这个问题后，我们才能有的放矢地解决算法难题。\n\n# 3、掌握经典问题，总结解题思路\n\n* 掌握经典的动态规划问题特别重要，因为很多问题都是从这些经典问题延伸出来的\n\n# 4、及时总结，举一反三\n\n我们常说人工智能是人工智障，这么说并不过分，因为计算机真的很笨，它唯一能解决的问题就是穷举，穷举所有可能性。\n\n动态规划的思想是从一系列算法中演进而来的。贪心算法是求解整体最优的真正思路源头，我们从那里开始，考虑穷举的问题，最终通过优化形成了一个比较完美的总结。而这个总结，正是动态规划思想。\n\n所以你看，即便是高级如动态规划这样的思想，也是通过不断的总结而得到的。而经过我们前面这一系列的总结，便形成了下面这幅脑图，你可以通过这幅图对学习动态规划有一个全面的了解。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"1678937170805\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic1678937170805.png\" style=\"width: 100%;\">\n</div>","tags":["动态规划学习方法"],"categories":["动态规划"]},{"title":"Java12～17 新特","url":"/2023/03/ced4de58.html","content":"> ps: Java的新特性有一个预览版本，预览版本的新特性会在两个版本后更新到正式版，编译执行代码预览版本的特性的 Java 文件需要添加 `--enable-preview` 参数\n>\n> 本篇所有内容摘自：[https://pdai.tech/md/java/java8up/java12.html](https://pdai.tech/md/java/java8up/java12.html)\n\n# Java12\n\n## 新的 switch 语句支持（preview）\n\n<!-- more -->\n\n```java\nprivate static void outputSeasonByMonth1(int month) {\n    switch (month) {\n        case 3, 4, 5:\n            System.out.println(\"spring\");\n            break;\n        case 6, 7, 8:\n            System.out.println(\"summer\");\n            break;\n        case 9, 10, 11:\n            System.out.println(\"autumn\");\n            break;\n        case 12, 1, 2:\n            System.out.println(\"winter\");\n            break;\n        default:\n            System.out.println(\"wrong\");\n    }\n}\n\nprivate static void outputSeasonByMonth2(int month) {\n    switch (month) {\n        case 3, 4, 5 -> System.out.println(\"spring\");\n        case 6, 7, 8 -> System.out.println(\"summer\");\n        case 9, 10, 11 -> System.out.println(\"autumn\");\n        case 12, 1, 2 -> System.out.println(\"winter\");\n        default -> System.out.println(\"wrong\");\n    }\n}\n```\n\n* case 项支持合并在一起\n* case 的执行语句支持使用 lambda 的形式\n\n## Shenandoah 低暂停时间垃圾回收器（实验）\n\n> JDK 12 引入的回收算法（实验阶段），该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。\n>\n> ps: Shenandoah 只存在于 OpenJDK 中，可以使用 `-XX:+UseShenandoahGC` 命令行参数打开\n\n **Shenandoah适用于高吞吐和大内存场景，不适合高实时性场景** 。Shenandoah算法设计目标主要是响应性和一致可控的短暂停顿，对于垃圾回收生命周期中安全点停顿（TTSP)和内存增长监控的时间开销并无帮助。\n\nShenandoah算法为每个Java对象添加了一个间接指针，使得GC线程能够在Java线程运行时压缩堆。标记和压缩是同时执行的，因此我们只需要暂停Java线程在一致可控的时间内扫描线程堆栈以查找和更新对象图的根。\n\n# Java13\n\n## switch 支持返回结果（preview）\n\n```java\nprivate static String outputSeasonByMonth1(int month) {\n    return switch (month) {\n        case 3, 4, 5 -> \"spring\";\n        case 6, 7, 8 -> \"summer\";\n        case 9, 10, 11 -> \"autumn\";\n        case 12, 1, 2 -> \"winter\";\n        default -> \"wrong\";\n    };\n}\n\nprivate static String outputSeasonByMonth2(int month) {\n    return switch (month) {\n        case 3, 4, 5:\n            yield \"spring\";\n        case 6, 7, 8:\n            yield \"summer\";\n        case 9, 10, 11:\n            yield \"autumn\";\n        case 12, 1, 2:\n            yield \"winter\";\n        default:\n            yield \"wrong\";\n    };\n}\n```\n\n* 上述两种 `switch` 的写法都不需要添加 `break` 关键字来中断 `case`，所以也不会出现忘写 break 而出现 switch 穿透的问题\n* 如果是使用 case 后面添加代码块的方式，需要使用 `yield` 关键字返回当前 case 块需要返回的数据\n  * ps：`yield`：产出、提供 的意思\n\n## 文本块（preview）\n\n```java\nprivate static void textBlock() {\n    String text = \"\"\"\n            床前明月光，\n            疑是地上霜。\n            举头望明月，\n            低头思故乡。\n            \"\"\";\n    System.out.println(text);\n}\n```\n\n* 文本块可以省去我们手动添加 `\\n` 和拼接字符串的烦恼，可以联系 js 中使用 \\`\\` 包裹的字符串，除了不能使用 `${}` 来直接替换变量，其他的也差不多\n\n# Java14\n\n## switch 特性提升为正式版\n\nswitch 表达式的新特性使得 switch 语句在编码方式上简化不少，但是同时还是需要注意：\n\n* 需要保持与之前 switch 语句同样的 case 分支情况。\n* switch 表达式中不再需要显式地使用 return、break 或者 continue 来跳出当前分支。\n\n## NPE 提示增强，可以提示到是哪个变量引起的 NPE\n\n使用 `-XX:+ShowCodeDetailsInExceptionMessages` 开启\n\n## `instanceof` 模式匹配语法增强（preview）\n\n```java\nprivate static void instanceOfDemo(Object obj) {\n    if (obj instanceof Serializable serial) {\n        System.out.println(\"is serializable\");\n    } else if (obj instanceof String str && !str.isBlank()) {\n        System.out.println(\"is String\");\n        if (str.contains(\"aab\")) {\n            System.out.println(\"str contains aab\");\n        }\n    } else if (obj instanceof List<?> list) {\n        System.out.println(\"is List\");\n    }\n}\n```\n\n* `instanceof` 后面可以直接声明的变量，声明的变量是判断的类型，作用范围是之后的 `if` 块\n* 在 `&&` 运算符中，`&&` 前面使用 `instanceof` 声明的变量可以在 `&&` 之后使用，即：变量的作用范围延长了，但是这种延长不适用于 `||` 运算符，因为 `||` 运算符即使前面没有匹配成功，也会执行后面的判断，此时使用会产生问题\n\n## `Record` 类型（preview）\n\n> Record 类型允许在代码中使用紧凑的语法形式来声明类，而这些类能够作为不可变数据类型的封装持有者。Record 这一特性主要用在特定领域的类上；与枚举类型一样，Record 类型是一种受限形式的类型，主要用于存储、保存数据，并且没有其它额外自定义行为的场景下。\n\n```java\npublic record Person(String name) {\n    public String getName() {\n        return name;\n    }\n}\n```\n\nrecord 类型的实体反编译后会继承于 `java.lang.Record` 类【与枚举类型类似】，且拥有部分特征：\n\n* 有且仅有一个构造方法\n* 拥有获取成员属性的方法：`name()`\n* 重写了 `hashcode()` 和 `equals()`\n* 重写了 `toString()`\n* 类对象和属性均被 `final` 修饰，表示类不可被继承，属性不可被再次赋值\n\n同时，`Class` 中也引入了新的方法\n\n```java\nRecordComponent[] getRecordComponents() // 返回类中 Recode 类型的字段\nboolean isRecord() // 判断当前类是否是 Record 类型\n```\n\n## 文本块增强（preview）\n\n引入了 `\\` 和 `\\s`\n\n```java\nprivate static void textBlockEnhance() {\n    String str1 = \"\"\"\n            床前明月光，\\\n            疑是地上霜。\\\n            举头望明月，\\\n            低头思故乡。\n            \"\"\";\n    System.out.println(str1);\n    String str2 = \"\"\"\n            床前明月光，\\s\n            疑是地上霜。 \\s\n            举头望明月， \n            低头思故乡。\n            \"\"\";\n    System.out.println(str2);\n}\n```\n\n* `\\` 与各种配置文件中的用法一致，表示当前行没有结束\n* `\\s` 表示一行末尾的空格，因为文本块会删掉一行末尾的 `\\r\\n`，同时也会删除末尾的空格\n  * 注意：代码第 12 行的空格并不会在控制台打印出来\n\n---\n\n> 接下来的特性对于使用 `Java` 进行开发的开发人员关系不大\n\n## 打包工具（孵化版）\n\n用于将 Java 项目打包成可在 windows、macos、linux 系统直接运行的程序包\n\n在**Java 13**发布前的最后一刻被从外围移除的打包工具jpackage终于可以在Java 14中使用了。但是要注意，它只在Incubator版本中提供。\n\n这个打包工具应该可以让开发人员创建自主的Java应用程序，它以JavaFXjavapackager这个打包工具为基础。它的主要特点有如下三个：\n\n* 支持本地打包格式，为用户提供自然的安装体验；\n* 打包时可以指定启动参数；\n* 通过命令行或使用ToolProvider API的程序来启动。\n\n## 某个组合垃圾回收器被弃用\n\nJava 14 打算弃用 ParallelScavenge + SerialOld 垃圾收集器组合。\n\n支持这一改变的JEP 366清楚地表明，他们的目的不是要删除掉这个组合，而是要弃用它。\n\n弃用这种算法组合的原因是：它很少被使用，同时需要大量的维护工作。\n\n# Java15\n\n## 密封的类和接口（preview）\n\n密封的类和接口用于显示那些类可以继承当前类，限制了类的层次结构，是一个很实用的特性\n\n```java\n// 添加sealed修饰符，permits后面跟上只能被继承的子类名称\npublic sealed class Person permits Teacher, Worker, Student{ } //人\n \n// 子类可以被修饰为 final\nfinal class Teacher extends Person { }//教师\n \n// 子类可以被修饰为 non-sealed，此时 Worker类就成了普通类，谁都可以继承它\nnon-sealed class Worker extends Person { }  //工人\n// 任何类都可以继承Worker\nclass AnyClass extends Worker{}\n \n//子类可以被修饰为 sealed,同上\nsealed class Student extends Person permits MiddleSchoolStudent,GraduateStudent{ } //学生\n \n \nfinal class MiddleSchoolStudent extends Student { }  //中学生\n \nfinal class GraduateStudent extends Student { }  //研究生\n```\n\n# Java16\n\n## instanceof 模式匹配增强提升为正式版\n\n## Record 类型提升为正式版\n\n## 向量API（孵化版）\n\n> 向量 API 存在于 `jdk.incubator.vector` 包中，属于 `jdk.incubator.vector` 模块。向量计算也成为矢量计算，指的是充分运用多核CPU的特性，使多个计算**并行**进行，同时计算\n\n```java\n// 定义256bit的向量浮点运算\nstatic final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_256;\nvoid vectorComputation(float[] a, float[] b, float[] c) {\n    var i = 0;\n    var upperBound = SPECIES.loopBound(a.length);\n    for (; i < upperBound; i += SPECIES.length()) {\n        var va = FloatVector.fromArray(SPECIES, a, i);\n        var vb = FloatVector.fromArray(SPECIES, b, i);\n        var vc = va.mul(va).\n                add(vb.mul(vb)).\n                neg();\n        vc.intoArray(c, i);\n    }\n    for (; i < a.length; i++) {\n        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;\n    }\n}\n```\n\n# Java17\n\n## 密封类提升为正式版\n\n## 伪随机数生成器重构及增强\n\n```java\nRandomGenerator g = RandomGenerator.of(\"L64X128MixRandom\");\n```\n\n关于参数，建议看 javadoc 或注释\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"1678267319255\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic1678267319255.png\" style=\"width: 100%;\">\n</div>\n\n* 这一大坨就是可选的参数\n\n# 下一次更新将是 Java23 发布时\n\nJava19 开放了预览版的 虚拟线程，结构化并发也已进入孵化阶段，推测这两块新的 API 将是很大的亮点\n\n关于 Java 各个版本的新特性信息，可以关注 [https://openjdk.org/projects/jdk/20/](https://openjdk.org/projects/jdk/20/)\n","tags":["Java12～17新特性"],"categories":["Java新特性"]},{"title":"Java10、11 新特","url":"/2023/03/ca210e65.html","content":"# Java10\n\n## 局部变量类型推断\n\n```java\nvar obj = new Object();\nvar str = \"string\";\nvar num = 10010;\n```\n\n* 此特性仅用于局部变量\n\n# Java11\n\n## 支持通过 `java` 命令直接运行\n\n在之前的版本中，运行 `Java` 文件需要先编译，之后再运行\n\n```shell\njavac HelloWorld.java\njava HelloWorld\n```\n\n<!-- more -->\n\n在 Java11 中，可以通过 `java` 命令直接运行Java文件\n\n```shell\njava HelloWorld.java\n```\n\n## String 中新增的方法\n\n> 通过代码及运行结果直接看吧，还包括 `line()` 等方法，如果需要，建议自行查阅 API 文档\n\n```java\npublic static void main(String[] args) {\n    char c = '\\u2000';\n    String str = c + \"abc\" + c;\n    System.out.printf(\"[%s]\\n\", str.trim());\n    System.out.printf(\"[%s]\\n\", str.strip());\n    System.out.printf(\"[%s]\\n\", str.stripLeading());\n    System.out.printf(\"[%s]\\n\", str.stripTrailing());\n\n    String name = \" \";\n    System.out.println(name.isBlank());\n\n    String desc = \"ann-zhgy\";\n    System.out.println(desc.repeat(3));\n}\n```\n\n运行结果：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"1678181355478\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic1678181355478.png\" style=\"width: 100%;\">\n</div>\n\n## var 可以修饰 Lambda 局部变量\n\n```java\nFunction functionInterface = (var a) -> a == null ? Optional.empty() : a;\n```\n\n* 感觉很鸡肋\n\n## 集合转对应类型数组\n\n```java\nList<String> sampleList = Arrays.asList(\"张三\", \"java 11\");\n// array = {\"张三\", \"java 11\"};\n// 11 之前最简单的写法 \n// String[] array = sampleList.toArray(new String[0]);\nString[] array = sampleList.toArray(String[]::new);\n```\n\n## Java11 最值得关注的特性：ZGC\n\n> ZGC 是 Java11 中最值得关注的特性，没有之一\n\n关于 ZGC 的详细介绍，建议查看 [Java11 ZGC 和 Java12 Shenandoah 介绍：苟日新、日日新、又日新](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2032%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/15%20Java11%20ZGC%20%E5%92%8C%20Java12%20Shenandoah%20%E4%BB%8B%E7%BB%8D%EF%BC%9A%E8%8B%9F%E6%97%A5%E6%96%B0%E3%80%81%E6%97%A5%E6%97%A5%E6%96%B0%E3%80%81%E5%8F%88%E6%97%A5%E6%96%B0.md)\n","tags":["Java10、11新特性"],"categories":["Java新特性"]},{"title":"Java 项目开发相关的 tips","url":"/2023/03/8a1412e9.html","content":"> 1. 开写之前，建议先阅读一下阿里 孤尽【大漠孤烟直，白日依山尽】老师出品的 Java 代码开发规范：[https://edu.aliyun.com/article/103](https://edu.aliyun.com/article/103)\n> 2. 本篇基于极客时间郑晔老师的课程《代码之丑》\n> 3. 本片提出的一些建议并不是仅适用于 Java\n\n**代码是给人看的，所以需要注意阅读性**\n\n<!-- more -->\n\n## 1、变量命名\n\n* 命名要能够描述出这段代码在做的事情，一个好的名字应该描述意图，而非细节！\n* 用技术术语命名是一个很不好的习惯，比如：xxxMap、xxxList、xxxSet。技术代码的出现代表着它缺少一个应有的模型\n* 编写可维护的代码要使用业务语言，建立团队的词汇表\n* 对于英语，最低限度的要求是写出来的代码像是在用英语表达\n  * 类名是一个名词，表示一类对象\n  * 方法名是一个动词或动宾短语，表示一个动作，一个行为\n\n## 2、重复代码\n\n* 大量的重复代码，可以通过idea看到警告的重复的代码，最直接的diss点就是：封装、继承、多态中的封装是啥。在编码时，要注意一定不要复制粘贴\n* 关于 if-else：如果 `if` 和 `else` 中的代码长得比较像，这点代码多半是有共通的逻辑的，需要改\n* **不要重复自己，不要复制粘贴**\n\n## 3、长函数\n\n* 在阿里的 Java 代码规约中，会认为一个方法超过 80 行就已经算是长函数了\n* **一个好的程序员面对代码库时要有不同尺度的观察能力，看设计时，要能够高屋建瓴，看代码时，要能细致入微** 。\n* 长函数往往还隐含着变量命名问题：类似含义的变量在同一方法(代码块)中是不可以重复声明的，抽取出方法之后，基本上不会有这个问题\n* 写出长函数的常见原因：\n  * 以性能为由\n  * 平铺直叙\n  * 每次迭代加一点\n\n## 4、大类\n\n* 大类的产生：\n  * 类的职责不单一：这个类做的事情很多，但是实际上这些事情可以是被细分的\n  * 字段未分组：\n* **所谓****的****将大类拆解成小类，本质上在做的工作是一个设计工作** 。\n\n## 5、长参数列表\n\n* 将参数封装为对象，之后再添加参数时直接在对象里面添加即可\n  * **一个模型的封装应该是以行为为基础的**。所以，在封装对象时也不能把参数一股脑的放到一个对象里面\n  * 动静分离：不变的变量可以设置为全局变量\n* 去除标记：对于设置状态及根据状态执行不同的处理逻辑的代码，可以分别抽成单独的方法\n\n## 6、滥用控制语句\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"1677756167092\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic1677756167092.png\" style=\"width: 100%;\">\n</div>\n\n> 这传说中的招法，他的名字叫做——かめはめ波(ka mi ha mi ha)！\n\n多层的嵌套关系其实是非常影响阅读的，我个人可能读到第四层或者第五层就完全读不下去了。对于这种代码的改进，比较出名的就是“卫语句\"这种写法。\n\n在开发时或许我们可以先想异常情况，之后写正常的处理逻辑。\n\n## 7、过长的调用链\n\n* 过长的调用链也是一种坏味道，最直接的方式就是将调用链封装为一个方法，隐藏中间的委托关系\n\n## 8、基本类型偏执\n\n```java\npublic double getEpubPrice(final boolean highQuality, final int chapterSequence) {\n  ...\n}\n```\n\n* 通过方法名，我们可以明确知道这个方法是返回一个表示价格的数据，但是使用的类型却是 double。double表示的范围有点大，价格没有负数的，或者价格的精度只有2位……\n* 改进方案：建立一个关于价格的模型(类)\n  * ```java\n    public class Price {\n        private double price;\n\n        public Price(final double price) {\n            if (price <= 0) {\n                throw new IllegalArgumentException(\"Price should be positive\");\n            }\n            this.price = price;\n        }\n\n        public double getDisplayPrice() {\n            BigDecimal decimal = new BigDecimal(this.price)；\n            return decimal.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();\n        }\n    }\n    ```\n* **封装之所以有难度，主要在于它是一个构建模型的过程**\n\n## 9、移除设值函数\n\n> 对于读取数据来说，修改是一个更加危险的操作，而对于修改数据来说，更可怕的是不可控的变化\n\n* 可以看一些 Java 中已经存在的一些方法声明，我们可以发现它其实是基于不变量返回的新的变量，所以这类问题的一个解决方案就是创建不变类\n  * ```java\n    String replace(char oldChar, char newChar)\n    ```\n  * ```java\n    LocalDateTime twoDaysLater = now.plusDays(2);\n    ```\n\n    饱受诟病的 Date 类在 Java8 修改之后，同样是基于原有的日期计算，返回计算结果，而不是修改原来的日期\n* 在项目中创建不变类是一件不太可能的事情，更实用的一个方案是：**区分类的性质**。\n  * 如果是实体对象就要限时数据的变化\n  * 如果是值对象就创建不变类\n\n## 10、变量声明与赋值分离\n\n先看一段代码\n\n```java\nEpubStatus status = null;\nCreateEpubResponse response = createEpub(request);\nif (response.getCode() == 201) {\n    status = EpubStatus.CREATED;\n} else {\n    status = EpubStatus.TO_CREATE;\n}\n```\n\n* 这段代码的问题在于第一行的赋值操作其实是没有意义的，如果第一行与真正赋值的操作隔了很远，这将极大的降低代码的可读性\n* 所以，我们编程时要有一个基本原则： **变量一次性完成初始化** 。\n\n```java\nfinal CreateEpubResponse response = createEpub(request);\nfinal EpubStatus status = toEpubStatus(response);\n\nprivate EpubStatus toEpubStatus(final CreateEpubResponse response) {\n    if (response.getCode() == 201) {\n    \treturn EpubStatus.CREATED;\n    }\n    return EpubStatus.TO_CREATE;\n}\n```\n\n* 从改进的代码中我们还看到了 `final`，基于尽可能使用不变的量的考虑：**在能够使用 `final` 的地方尽量使用 `final`，限制变量再赋值操作**\n\n对于集合的初始化\n\n```java\nList permissions = new ArrayList<>();\npermissions.add(Permission.BOOK_READ);\npermissions.add(Permission.BOOK_WRITE);\ncheck.grantTo(Role.AUTHOR, permissions);\n```\n\n* 这段代码是一个简单的几何初始化的过程，但是在 `Java9` 之后，这种写法就已经是一个很不好的写法了\n\n```java\nList permissions = List.of(\n  Permission.BOOK_READ, \n  Permission.BOOK_WRITE\n);\ncheck.grantTo(Role.AUTHOR, permissions);\n```\n\n* List.of 返回的还是一个不支持增删改操作的集合类型，同样是**尽量使用不可变的量**这个规则\n* 对比我们改造前后的代码，二者之间还有一个更关键的区别：前面的代码是命令式的代码，而后面的代码是声明式的代码。\n  * 命令式的代码，就是告诉你“怎么做”的代码，就像改造前的代码，声明一个集合，然后添加一个元素，再添加一个元素。\n  * 声明式的代码，是告诉你“做什么”的代码，改造后就是，我要一个包含了这两个元素的集合。\n* **用声明式的标准来看代码，是一个发现代码坏味道的重要参考**\n\n## 11、依赖混乱：你可能还没发现问题，代码就已经无法挽救了\n\n先看一段代码\n\n```java\n@PostMapping(\"/books\")\npublic NewBookResponse createBook(final NewBookRequest request) {\n    boolean result = this.service.createBook(request);\n    ...\n}\n```\n\n* 上面的问题在于：属于 controller/resource 层的 `NewBookRequest` 实体进入了业务处理层，业务处理层应该有相对稳定的参数、返回结构等信息，这样才可以实现每一层的隔离\n\n最好的解决方案：\n\n1. 每一层都有各自的参数，返回结果\n2. 面向接口编程\n\n## 12、不一致的代码：为什么你的代码总是被吐槽\n\n### 12.1 命名的不一致\n\n```java\nenum DistributionChannel {\n    WEBSITE\n    KINDLE_ONLY\n    ALL\n}\n```\n\n* 如上代码所示，代表分发渠道包括 网站（WEBSITE）、只在Kindle（KINDLE_ONLY），还是全渠道（ALL）\n\n  > 面对这段代码，我有些疑惑，于是我提了一个问题：\n  >\n  > 我：这里的 WEBSITE 和 KINDLE_ONLY 分别表示的是什么？\n  > 同事：WEBSITE 表示作品只会在我们自己的网站发布，KINDLE_ONLY 表示这部作品只会在 Kindle 的电子书商店里上架。\n  > 我：二者是不是都表示只在单独一个渠道发布？\n  > 同事：是啊！\n  > 我：既然二者都有只在一个平台上架发布的含义，为什么不都叫 XXX 或者 XXX_ONLY？\n  > 同事：呃，你说得有道理。\n  >\n* 表示**类似含义的代码应该有一致的名字**，而**一旦出现了不一致的名字，通常都表示不同的含义**\n\n### 12.2 方案的不一致\n\n比如两块代码中都用到了对于日期的操作，一个使用的 `Date` 类，另一个是使用的 `LocalDateTime` 类，在同一项目中，我们使用的方案应该是一致的\n\n### 12.3 代码中的不一致\n\n> 我们再来看一段代码：\n>\n> ```\n> public void createBook(final List\n> ```\n>\n> 这是一段在翻译引擎中创建作品的代码。首先，根据要处理的作品 ID 获取其中已经审核通过的作品，然后，发送一个 HTTP 请求在翻译引擎中创建出这个作品。\n>\n> 这么短的一段代码有什么问题吗？问题就在于这段代码中的不一致。你可能会想：“不一致？不一致体现在哪里呢？”答案就是，这些代码不是一个层次的代码。\n>\n> 通过了解这段代码的背景，你可能已经看出一些端倪了。首先是获取审核通过的作品，这是一个业务动作，接下来的三行其实是在做一件事，也就是发送创建作品的请求。具体到代码上，这三行代码分别是创建请求的参数，根据参数创建请求，最后，再把请求发送出去。这三行代码合起来完成了一个发送创建作品请求这么一件事，而这件事才是一个完整的业务动作。\n>\n> 所以，我说这个函数里的代码并不在一个层次上，有的是业务动作，有的是业务动作的细节。理解了这一点，我们就可以把这些业务细节的代码提取到一个函数里：\n>\n> ```\n> public void createBook(final List\n> ```\n>\n> 从结果上看，原来的函数（createBook）里面全都是业务动作，而提取出来的函数（createRemoteBook）则都是业务动作的细节，各自的语句都是在一个层次上了。\n\n* 很多程序员纠结的技术问题，其实是一个软件设计问题，不要通过奇技淫巧去解决一个本来不应该被解决的问题。\n\n## 13 落后的代码风格：使用“新”的语言特性和程序库升级你的代码\n\n## 14 写代码是一个值得一生精进的事情♪\n","tags":["Java开发规范"],"categories":["经验之谈"]},{"title":"Java 扩展 ——Manifold 插件","url":"/2023/03/394b666a.html","content":"> 原文指引：[https://developer.aliyun.com/article/1135549](https://developer.aliyun.com/article/1135549)\n\n# 什么是扩展方法\n\n扩展方法，就是能够向**现有类型**直接“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改现有类型。调用扩展方法的时候，与调用在类型中实际定义的方法相比没有明显的差异。\n\n* 所以，Java 其实是不支持扩展方法的\n\n# Manifold 使用\n\n<!-- more -->\n\n## 准备条件\n\n1. 在 IDEA 上安装 Manifold 插件\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"1677656179082\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic1677656179082.png\" style=\"width: 100%;\">\n   </div>\n\n2. 在项目 pom 的编译插件 *maven-compiler-plugin*  中加入  *annotationProcessorPaths* ：\n\n   ```xml\n   <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n       ...\n\n       <properties>\n           <manifold.version>2023.1.3</manifold.version>\n       </properties>\n\n       <dependencies>\n           <dependency>\n               <groupId>systems.manifold</groupId>\n               <artifactId>manifold-ext</artifactId>\n               <version>${manifold.version}</version>\n           </dependency>\n           ...\n       </dependencies>\n\n       <!--Add the -Xplugin:Manifold argument for the javac compiler-->\n       <build>\n           <plugins>\n               <plugin>\n                   <groupId>org.apache.maven.plugins</groupId>\n                   <artifactId>maven-compiler-plugin</artifactId>\n                   <version>3.8.1</version>\n                   <configuration>\n                       <source>8</source>\n                       <target>8</target>\n                       <encoding>UTF-8</encoding>\n                       <compilerArgs>\n                           <arg>-Xplugin:Manifold no-bootstrap</arg>\n                       </compilerArgs>\n                       <annotationProcessorPaths>\n                           <path>\n                               <groupId>systems.manifold</groupId>\n                               <artifactId>manifold-ext</artifactId>\n                               <version>${manifold.version}</version>\n                           </path>\n                       </annotationProcessorPaths>\n                   </configuration>\n               </plugin>\n           </plugins>\n       </build>\n   </project>\n   ```\n\n   如果项目使用了 Lombok，需要把 Lombok 也加入 annotationProcessorPaths\n\n   ```xml\n   <annotationProcessorPaths>\n       <path>\n           <groupId>org.projectlombok</groupId>\n           <artifactId>lombok</artifactId>\n           <version>${lombok.version}</version>\n       </path>\n       <path>\n           <groupId>systems.manifold</groupId>\n           <artifactId>manifold-ext</artifactId>\n           <version>${manifold.version}</version>\n       </path>\n   </annotationProcessorPaths>\n   ```\n\n## 编写扩展方法\n\n```java\npackage org.example.extensions.java.lang.String;\n\nimport manifold.ext.rt.api.Extension;\nimport manifold.ext.rt.api.This;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * String类型扩展\n *\n * @author ann-zhgy\n * @version StringExt.class 2023-02-24 15:36\n * @since 2023-02\n */\n@Extension\npublic final class StringExt {\n    public static String[] split(@This String str, char separator) {\n        return StringUtils.split(str, separator);\n    }\n}\n```\n\n* 扩展方法类必须在 `extensions` 包下，包名必须是要扩展的类的全路径名\n* 扩展方法需要添加 `@Extension` 注解\n* 普通方法的扩展方法需要持有要扩展的类对象，并且使用 `@This` 注解标记\n\n```java\npackage org.example.extensions.java.util.List;\n\nimport manifold.ext.rt.api.Extension;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * List扩展\n *\n * @author ann-zhgy\n * @version ListExt.class 2023-02-24 15:50\n * @since 2023-02\n */\n@Extension\npublic final class ListExt {\n\n    @Extension\n    public static <E> List<E> of(E elem) {\n        return Collections.singletonList(elem);\n    }\n\n    @Extension\n    @SafeVarargs\n    public static <E> List<E> of(E ...elem) {\n        return Collections.unmodifiableList(Arrays.asList(elem));\n    }\n}\n```\n\n* 静态方法的扩展需要在方法上面添加 `@Extension` 注解\n\n  ps：`@SafeVarargs` 仅用来抑制 “堆污染\" 警告\n\n**数组扩展方法**：可以参考 Manifold 自带的 `manifold.ext.rt.extensions.manifold.rt.api.Array.ManArrayExt`\n\n# 扩展方法需要谨慎添加\n\n扩展方法是极其通用的方法，所以必须谨慎添加！！！\n","tags":["Java 扩展方法","Manifold"],"categories":["Java 插件"]},{"title":"GibHub commit emoji 表情对照表（也可适用于 markdown 表情）","url":"/2023/02/d0090e46.html","content":"> 参考 [git commit emoji 使用指南](https://github.com/liuchengxu/git-commit-emoji-cn \"git commit emoji 使用指南\")、[markdown-emoji](https://github.com/zhouie/markdown-emoji \"markdown-emoji\")\n\n<!-- more -->\n\n# 提交 emoji\n\n| emoji        | emoji 代码                      | commit 说明            |\n| ------------ | ------------------------------- | ---------------------- |\n| 🎉           | ``:tada:``                      | 初次提交               |\n| 🆕           | ``:new:``                       | 引入新功能             |\n| 🔖           | ``:bookmark:``                  | 发行/版本标签          |\n| 🐛           | ``:bug:``                       | 修复bug                |\n| 🚑           | ``:ambulance:``                 | 重要补丁               |\n| 🌐           | ``:globe_with_meridians:``      | 国际化与本地化         |\n| 💄           | ``:lipstick:``                  | 更新UI和样式文件       |\n| 🎬           | ``:clapper:``                   | 更新演示/示例          |\n| 🚨           | ``:rotating_light:``            | 移除linter警告         |\n| 🔧           | ``:wrench:``                    | 修改配置文件           |\n| ➕           | ``:heavy_plus_sign:``           | 增加一个依赖           |\n| ➖           | ``:heavy_minus_sign:``          | 减少一个依赖           |\n| ⬆️         | ``:arrow_up:``                  | 升级依赖               |\n| ⬇️         | ``:arrow_down:``                | 降级依赖               |\n| ⚡️<br />🐎 | ``:zap:``<br />``:racehorse:``  | 提升性能               |\n| 📈           | ``:chart_with_upwards_trend:``  | 添加分析或跟踪代码     |\n| 🚀           | ``:rocket:``                    | 部署功能               |\n| ✅           | ``:white_check_mark:``          | 增加测试               |\n| 📝<br />📖   | ``:memo:``<br />``:book:``      | 撰写文档               |\n| 🔨           | ``:hammer:``                    | 重大重构               |\n| 🎨           | ``:art:``                       | 改进代码结构/代码格式  |\n| 🔥           | ``:fire:``                      | 移除代码或文件         |\n| ✏️         | ``:pencil2:``                   | 修复 typo              |\n| 🚧           | ``:construction:``              | 工作进行中             |\n| 🗑           | ``:wastebasket:``               | 废弃或删除             |\n| ♿️         | ``:wheelchair:``                | 可访问性               |\n| 👷           | ``:construction_worker:``       | 添加 CI 构建系统       |\n| 💚           | ``:green_heart:``               | 修复 CI 构建问题       |\n| 🔒           | ``:lock:``                      | 修复安全问题           |\n| 🐳           | ``:whale:``                     | Docker 相关工作        |\n| 🍎           | ``:apple:``                     | 修复 macOS 下的问题    |\n| 🐧           | ``:penguin:``                   | 修复 Linux 下的问题    |\n| 🏁           | ``:checkered_flag:``            | 修复 Windows 下的问题 |\n| 🔀           | ``:twisted_rightwards_arrows:`` | 分支合并               |\n\n# emoji 表情\n\n## 人物\n\n| 表情 | 代码                           | 表情 | 代码                               | 表情                                                                                                                                               | 代码                               | 表情 | 代码                        |\n| ---- | ------------------------------ | ---- | ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------- | ---- | --------------------------- |\n| 😄   | ``:smile:``                    | 😆   | ``:laughing:``                     | 😊                                                                                                                                                 | ``:blush:``                        | 😃   | ``:smiley:``                |\n| 😏   | ``:smirk:``                    | 😍   | ``:heart_eyes:``                   | 😘                                                                                                                                                 | `:kissing_heart:`                | 😚   | `:kissing_closed_eyes:`   |\n| 😌   | `:satisfied:`                | 😁   | `:grin:`                         | ☺️                                                                                                                                               | ``:relaxed:``                      | 😳   | `:flushed:`               |\n| 😉   | `:wink:`                     | 😜   | `:stuck_out_tongue_winking_eye:` | 😝                                                                                                                                                 | `:stuck_out_tongue_closed_eyes:` | 😀   | `:grinning:`              |\n| 😗   | `:kissing:`                  | 😙   | `:kissing_smiling_eyes:`         | 😛                                                                                                                                                 | `:stuck_out_tongue:`             | 😴   | `:sleeping:`              |\n| 😟   | `:worried:`                  | 😦   | `:frowning:`                     | 😧                                                                                                                                                 | `:anguished:`                    | 😮   | `:open_mouth:`            |\n| 😬   | `:grimacing:`                | 😕   | `:confused:`                     | 😯                                                                                                                                                 | `:hushed:`                       | 😑   | `:expressionless:`        |\n| 😒   | `:unamused:`                 | 😅   | `:sweat_smile:`                  | 😓                                                                                                                                                 | `:sweat:`                        | 😥   | `:disappointed_relieved:` |\n| 😩   | `:weary:`                    | 😔   | `:pensive:`                      | 😞                                                                                                                                                 | `:disappointed:`                 | 😖   | `:fearful:`               |\n| 😰   | `:cold_sweat:`               | 😣   | `:persevere:`                    | 😢                                                                                                                                                 | `:cry:`                          | 😭   | `:sob:`                   |\n| 😂   | `:joy:`                      | 😲   | `:astonished:`                   | 😱                                                                                                                                                 | `:scream:`                       | 😫   | `:tired_face:`            |\n| 😠   | `:angry:`                    | 😡   | `:rage:`                         | 😤                                                                                                                                                 | `:triumph:`                      | 😪   | `:sleepy:`                |\n| 😋   | `:yum:`                      | 😷   | `:mask:`                         | 😎                                                                                                                                                 | `:sunglasses:`                   | 😵   | `:dizzy_face:`            |\n| 👿   | `:imp:`                      | 😈   | `:smiling_imp:`                  | 😐                                                                                                                                                 | `:neutral_face:`                 | 😶   | `:no_mouth:`              |\n| 😇   | `:innocent:`                 | 👽   | `:alien:`                        | 💛                                                                                                                                                 | `:yellow_heart:`                 | 💙   | `:blue_heart:`            |\n| 💜   | `:purple_heart:`             | ❤️ | `:heart:`                        | 💚                                                                                                                                                 | `:green_heart:`                  | 💔   | `:broken_heart:`          |\n| 💓   | `:heartbeat:`                | 💗   | `:heartpulse:`                   | 💕                                                                                                                                                 | `:two_hearts:`                   | 💞   | `:revolving_hearts:`      |\n| 💘   | `:cupid:`                    | 💖   | `:sparkling_heart:`              | ✨                                                                                                                                                 | `:sparkles:`                     | ⭐️ | `:star:`                  |\n| 🌟   | `:star2:`                    | 💫   | `:dizzy:`                        | 💥                                                                                                                                                 | `:boom:`                         | 💥   | `:collision:`             |\n| 💢   | `:anger:`                    | ❗️ | `:exclamation:`                  | ❓                                                                                                                                                 | `:question:`                     | ❕   | `:grey_exclamation:`      |\n| ❔   | `:grey_question:`            | 💤   | 💤                                 | 💨                                                                                                                                                 | `:dash:`                         | 💦   | `:sweat_drops:`           |\n| 🎶   | `:notes:`                    | 🎵   | `:musical_note:`                 | 🔥                                                                                                                                                 | `:fire:`                         | 💩   | `:hankey:`                |\n| 💩   | `:poop:`                     | 💩   | `:shit:`                         | 👍                                                                                                                                                 | `:+1:`                           | 👍   | `:thumbsup:`              |\n| 👎   | `:-1:`                       | 👎   | `:thumbsdown:`                   | 👌                                                                                                                                                 | `:ok_hand:`                      | 👊   | `:punch:`                 |\n| 👊   | `:facepunch:`                | ✊   | `:fist:`                         | ✌️                                                                                                                                               | `:v:`                            | 👋   | `:wave:`                  |\n| ✋   | `:hand:`                     | ✋   | `:raised_hand:`                  | 👐                                                                                                                                                 | `:open_hands:`                   | ☝️ | `:point_up:`              |\n| 👇   | `:point_down:`               | 👈   | `:point_left:`                   | 👉                                                                                                                                                 | `:point_right:`                  | 🙌   | `:raised_hands:`          |\n| 🙏   | `:pray:`                     | 👆   | `:point_up_2:`                   | 👏                                                                                                                                                 | `:clap:`                         | 💪   | `:muscle:`                |\n| 🤘   | `:metal:`                    | 🖕   | `:fu:`                           | 🚶                                                                                                                                                 | `:walking:`                      | 🏃   | `:runner:`                |\n| 🏃   | `:running:`                  | 👫   | `:couple:`                       | 👪                                                                                                                                                 | `:family:`                       | 👬   | `:two_men_holding_hands:` |\n| 👭   | `:two_women_holding_hands:`  | 💃   | `:dancer:`                       | 👯                                                                                                                                                 | `:dancers:`                      | 🙆   | `:ok_woman:`              |\n| 🙅   | `:no_good:`                  | 💁   | `:information_desk_person:`      | 🙋                                                                                                                                                 | `:raising_hand:`                 | 👰   | `:bride_with_veil:`       |\n| 🙎   | `:person_with_pouting_face:` | 🙍   | `:person_frowning:`              | 🙇                                                                                                                                                 | `:bow:`                          | 👦   | `:boy:`                   |\n| 💑   | `:couple_with_heart:`        | 💆   | `:massage:`                      | 💇                                                                                                                                                 | `:haircut:`                      | 💅   | `:nail_care:`             |\n| 👧   | `:girl:`                     | 👩   | `:woman:`                        | 👨                                                                                                                                                 | `:man:`                          | 👶   | `:baby:`                  |\n| 👵   | `:older_woman:`              | 👴   | `:older_man:`                    | 👱                                                                                                                                                 | `:person_with_blond_hair:`       | 👲   | `:man_with_gua_pi_mao:`   |\n| 👳   | `:man_with_turban:`          | 👷   | `:construction_worker:`          | 👮                                                                                                                                                 | `:cop:`                          | 👼   | `:angel:`                 |\n| 👸   | `:princess:`                 | 😺   | `:smiley_cat:`                   | 😸                                                                                                                                                 | `:smile_cat:`                    | 😻   | `:heart_eyes_cat:`        |\n| 😽   | `:kissing_cat:`              | 😼   | `:smirk_cat:`                    | 🙀                                                                                                                                                 | `:scream_cat:`                   | 😿   | `:crying_cat_face:`       |\n| 😹   | `:joy_cat:`                  | 😾   | `:pouting_cat:`                  | 👹                                                                                                                                                 | `:japanese_ogre:`                | 👺   | `:japanese_goblin:`       |\n| 🙈   | `:see_no_evil:`              | 🙉   | `:hear_no_evil:`                 | 🙊                                                                                                                                                 | `:speak_no_evil:`                | 💂   | `:guardsman:`             |\n| 💀   | `:skull:`                    | 🐾   | `:feet:`                         | 👄                                                                                                                                                 | `:lips:`                         | 💋   | `:kiss:`                  |\n| 💧   | `:droplet:`                  | 👂   | `:ear:`                          | 👀                                                                                                                                                 | `:eyes:`                         | 👃   | `:nose:`                  |\n| 👅   | `:tongue:`                   | 💌   | `:love_letter:`                  | 👤                                                                                                                                                 | `:bust_in_silhouette:`           | 👥   | `:busts_in_silhouette:`   |\n| 💬   | `:speech_balloon:`           | 💭   | `:thought_balloon:`              | :trollface: | `:trollface:`                    |      |                             |\n\n## 自然\n\n| 表情 | 代码                              | 表情                                                                                                                                       | 代码                               | 表情 | 代码                      | 表情 | 代码                       |\n| ---- | --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------- | ---- | ------------------------- | ---- | -------------------------- |\n| ☀️ | `:sunny:`                       | ☔️                                                                                                                                       | `:umbrella:`                     | ☁️ | `:cloud:`               | ❄️ | `:snowflake:`            |\n| ⛄️ | `:snowman:`                     | ⚡️                                                                                                                                       | `:zap:`                          | 🌀   | `:cyclone:`             | 🌁   | `:foggy:`                |\n| 🌊   | `:ocean:`                       | 🐱                                                                                                                                         | `:cat:`                          | 🐶   | `:dog:`                 | 🐭   | `:mouse:`                |\n| 🐹   | `:hamster:`                     | 🐰                                                                                                                                         | `:rabbit:`                       | 🐺   | `:wolf:`                | 🐸   | `:frog:`                 |\n| 🐯   | `:tiger:`                       | 🐨                                                                                                                                         | `:koala:`                        | 🐻   | `:bear:`                | 🐷   | `:pig:`                  |\n| 🐽   | `:pig_nose:`                    | 🐮                                                                                                                                         | `:cow:`                          | 🐗   | `:boar:`                | 🐵   | `:monkey_face:`          |\n| 🐒   | `:monkey:`                      | 🐴                                                                                                                                         | `:horse:`                        | 🐎   | `:racehorse:`           | 🐫   | `:camel:`                |\n| 🐑   | `:sheep:`                       | 🐘                                                                                                                                         | `:elephant:`                     | 🐼   | `:panda_face:`          | 🐍   | `:snake:`                |\n| 🐦   | `:bird:`                        | 🐤                                                                                                                                         | `:baby_chick:`                   | 🐥   | `:hatched_chick:`       | 🐣   | `:hatching_chick:`       |\n| 🐔   | `:chicken:`                     | 🐧                                                                                                                                         | `:penguin:`                      | 🐢   | `:turtle:`              | 🐛   | `:bug:`                  |\n| 🐝   | `:honeybee:`                    | 🐜                                                                                                                                         | `:ant:`                          | 🐞   | `:beetle:`              | 🐌   | `:snail:`                |\n| 🐙   | `:octopus:`                     | 🐠                                                                                                                                         | `:tropical_fish:`                | 🐟   | `:fish:`                | 🐳   | `:whale:`                |\n| 🐋   | `:whale2:`                      | 🐬                                                                                                                                         | `:dolphin:`                      | 🐄   | `:cow2:`                | 🐏   | `:ram:`                  |\n| 🐀   | `:rat:`                         | 🐃                                                                                                                                         | `:water_buffalo:`                | 🐅   | `:tiger2:`              | 🐇   | `:rabbit2:`              |\n| 🐉   | `:dragon:`                      | 🐐                                                                                                                                         | 🐐                                 | 🐓   | `:rooster:`             | 🐕   | `:dog2:`                 |\n| 🐖   | `:pig2:`                        | 🐁                                                                                                                                         | `:mouse2:`                       | 🐂   | `:ox:`                  | 🐲   | `:dragon_face:`          |\n| 🐡   | `:blowfish:`                    | 🐊                                                                                                                                         | `:crocodile:`                    | 🐪   | `:dromedary_camel:`     | 🐆   | `:leopard:`              |\n| 🐈   | `:cat2:`                        | 🐩                                                                                                                                         | `:poodle:`                       | 🐾   | `:paw_prints:`          | 💐   | `:bouquet:`              |\n| 🌸   | `:cherry_blossom:`              | 🌷                                                                                                                                         | `:tulip:`                        | 🍀   | `:four_leaf_clover:`    | 🌹   | `:rose:`                 |\n| 🌻   | `:sunflower:`                   | 🌺                                                                                                                                         | `:hibiscus:`                     | 🍁   | `:maple_leaf:`          | 🍃   | `:leaves:`               |\n| 🍂   | `:fallen_leaf:`                 | 🌿                                                                                                                                         | `:herb:`                         | 🍄   | `:mushroom:`            | 🌵   | `:cactus:`               |\n| 🌴   | `:palm_tree:`                   | 🌲                                                                                                                                         | `:evergreen_tree:`               | 🌳   | `:deciduous_tree:`      | 🌰   | `:chestnut:`             |\n| 🌱   | `:seedling:`                    | 🌼                                                                                                                                         | `:blossom:`                      | 🌾   | `:ear_of_rice:`         | 🐚   | `:shell:`                |\n| 🌐   | `:globe_with_meridians:`        | 🌞                                                                                                                                         | `:sun_with_face:`                | 🌝   | `:full_moon_with_face:` | 🌚   | `:new_moon_with_face:`   |\n| 🌑   | `:new_moon:`                    | 🌒                                                                                                                                         | `:waxing_crescent_moon:`         | 🌓   | `:first_quarter_moon:`  | 🌔   | `:waxing_gibbous_moon:`  |\n| 🌕   | `:full_moon:`                   | 🌖                                                                                                                                         | `:waning_gibbous_moon:`          | 🌗   | `:last_quarter_moon:`   | 🌘   | `:waning_crescent_moon:` |\n| 🌜   | `:last_quarter_moon_with_face:` | 🌛                                                                                                                                         | `:first_quarter_moon_with_face:` | 🌔   | `:moon:`                | 🌍   | `:earth_africa:`         |\n| 🌎   | `:earth_americas:`              | 🌏                                                                                                                                         | `:earth_asia:`                   | 🌋   | `:volcano:`             | 🌌   | `:milky_way:`            |\n| ⛅️ | `:partly_sunny:`                | :octocat: | `:octocat:`                      |      |                           |      |                            |\n\n## 事物\n\n| 表情 | 代码                          | 表情 | 代码                     | 表情 | 代码                           | 表情 | 代码                                 |\n| ---- | ----------------------------- | ---- | ------------------------ | ---- | ------------------------------ | ---- | ------------------------------------ |\n| 🎍   | `:bamboo:`                  | 💝   | `:gift_heart:`         | 🎎   | `:dolls:`                    | 🎒   | `:school_satchel:`                 |\n| 🎓   | `:mortar_board:`            | 🎏   | `:flags:`              | 🎆   | `:fireworks:`                | 🎇   | `:sparkler:`                       |\n| 🎐   | `:wind_chime:`              | 🎑   | `:rice_scene:`         | 🎃   | `:jack_o_lantern:`           | 👻   | `:ghost:`                          |\n| 🎅   | `:santa:`                   | 🎄   | `:christmas_tree:`     | 🎁   | `:gift:`                     | 🔔   | `:bell:`                           |\n| 🔕   | `:no_bell:`                 | 🎋   | `:tanabata_tree:`      | 🎉   | `:tada:`                     | 🎊   | `:confetti_ball:`                  |\n| 🎈   | `:balloon:`                 | 🔮   | `:crystal_ball:`       | 💿   | `:cd:`                       | 📀   | `:dvd:`                            |\n| 💾   | `:floppy_disk:`             | 📷   | `:camera:`             | 📹   | `:video_camera:`             | 🎥   | `:movie_camera:`                   |\n| 💻   | `:computer:`                | 📺   | `:tv:`                 | 📱   | `:iphone:`                   | ☎️ | `:phone:`                          |\n| ☎️ | `:telephone:`               | 📞   | `:telephone_receiver:` | 📟   | `:pager:`                    | 📠   | `:fax:`                            |\n| 💽   | `:minidisc:`                | 📼   | `:vhs:`                | 🔉   | `:sound:`                    | 🔈   | `:speaker:`                        |\n| 🔇   | `:mute:`                    | 📢   | `:loudspeaker:`        | 📣   | `:mega:`                     | ⌛️ | `:hourglass:`                      |\n| ⏳   | `:hourglass_flowing_sand:`  | ⏰   | `:alarm_clock:`        | ⌚️ | `:watch:`                    | 📻   | `:radio:`                          |\n| 📡   | `:satellite:`               | ➿   | `:loop:`               | 🔍   | `:mag:`                      | 🔎   | `:mag_right:`                      |\n| 🔓   | `:unlock:`                  | 🔒   | `:lock:`               | 🔏   | `:lock_with_ink_pen:`        | 🔐   | `:closed_lock_with_key:`           |\n| 🔑   | `:key:`                     | 💡   | `:bulb:`               | 🔦   | `:flashlight:`               | 🔆   | `:high_brightness:`                |\n| 🔅   | `:low_brightness:`          | 🔌   | `:electric_plug:`      | 🔋   | `:battery:`                  | 📲   | `:calling:`                        |\n| ✉️ | `:email:`                   | 📫   | `:mailbox:`            | 📮   | `:postbox:`                  | 🛀   | `:bath:`                           |\n| 🛁   | `:bathtub:`                 | 🚿   | `:shower:`             | 🚽   | `:toilet:`                   | 🔧   | `:wrench:`                         |\n| 🔩   | `:nut_and_bolt:`            | 🔨   | `:hammer:`             | 💺   | `:seat:`                     | 💰   | `:moneybag:`                       |\n| 💴   | `:yen:`                     | 💵   | `:dollar:`             | 💷   | `:pound:`                    | 💶   | `:euro:`                           |\n| 💳   | `:credit_card:`             | 💸   | `:money_with_wings:`   | 📧   | `:e-mail:`                   | 📥   | `:inbox_tray:`                     |\n| 📤   | `:outbox_tray:`             | ✉️ | `:envelope:`           | 📨   | `:incoming_envelope:`        | 📯   | `:postal_horn:`                    |\n| 📪   | `:mailbox_closed:`          | 📬   | `:mailbox_with_mail:`  | 📭   | `:mailbox_with_no_mail:`     | 🚪   | `:door:`                           |\n| 🚬   | `:smoking:`                 | 💣   | `:bomb:`               | 🔫   | `:gun:`                      | 🔪   | `:hocho:`                          |\n| 💊   | `:pill:`                    | 💉   | `:syringe:`            | 📄   | `:page_facing_up:`           | 📃   | `:page_with_curl:`                 |\n| 📑   | `:bookmark_tabs:`           | 📊   | `:bar_chart:`          | 📈   | `:chart_with_upwards_trend:` | 📉   | `:chart_with_downwards_trend:`     |\n| 📜   | `:scroll:`                  | 📋   | `:clipboard:`          | 📆   | `:calendar:`                 | 📅   | `:date:`                           |\n| 📇   | `:card_index:`              | 📁   | `:file_folder:`        | 📂   | `:open_file_folder:`         | ✂️ | `:scissors:`                       |\n| 📌   | `:pushpin:`                 | 📎   | `:paperclip:`          | ✒️ | `:black_nib:`                | ✏️ | `:pencil2:`                        |\n| 📏   | `:straight_ruler:`          | 📐   | `:triangular_ruler:`   | 📕   | `:closed_book:`              | 📗   | `:green_book:`                     |\n| 📘   | `:blue_book:`               | 📙   | `:orange_book:`        | 📓   | `:notebook:`                 | 📔   | `:notebook_with_decorative_cover:` |\n| 📒   | `:ledger:`                  | 📚   | `:books:`              | 🔖   | `:bookmark:`                 | 📛   | `:name_badge:`                     |\n| 🔬   | `:microscope:`              | 🔭   | `:telescope:`          | 📰   | `:newspaper:`                | 🏈   | `:football:`                       |\n| 🏀   | `:basketball:`              | ⚽️ | `:soccer:`             | ⚾️ | `:baseball:`                 | 🎾   | `:tennis:`                         |\n| 🎱   | `:8ball:`                   | 🏉   | `:rugby_football:`     | 🎳   | `:bowling:`                  | ⛳️ | `:golf:`                           |\n| 🚵   | `:mountain_bicyclist:`      | 🚴   | `:bicyclist:`          | 🏇   | `:horse_racing:`             | 🏂   | `:snowboarder:`                    |\n| 🏊   | `:swimmer:`                 | 🏄   | `:surfer:`             | 🎿   | `:ski:`                      | ♠️ | `:spades:`                         |\n| ♥️ | `:hearts:`                  | ♣️ | `:clubs:`              | ♦️ | `:diamonds:`                 | 💎   | `:gem:`                            |\n| 💍   | `:ring:`                    | 🏆   | `:trophy:`             | 🎼   | `:musical_score:`            | 🎹   | `:musical_keyboard:`               |\n| 🎻   | `:violin:`                  | 👾   | `:space_invader:`      | 🎮   | `:video_game:`               | 🃏   | `:black_joker:`                    |\n| 🎴   | `:flower_playing_cards:`    | 🎲   | `:game_die:`           | 🎯   | `:dart:`                     | 🀄️ | `:mahjong:`                        |\n| 🎬   | `:clapper:`                 | 📝   | `:memo:`               | 📝   | `:pencil:`                   | 📖   | `:book:`                           |\n| 🎨   | `:art:`                     | 🎤   | `:microphone:`         | 🎧   | `:headphones:`               | 🎺   | `:trumpet:`                        |\n| 🎷   | `:saxophone:`               | 🎸   | `:guitar:`             | 👞   | `:shoe:`                     | 👡   | `:sandal:`                         |\n| 👠   | `:high_heel:`               | 💄   | `:lipstick:`           | 👢   | `:boot:`                     | 👕   | `:shirt:`                          |\n| 👕   | `:tshirt:`                  | 👔   | `:necktie:`            | 👚   | `:womans_clothes:`           | 👗   | `:dress:`                          |\n| 🎽   | `:running_shirt_with_sash:` | 👖   | `:jeans:`              | 👘   | `:kimono:`                   | 👙   | `:bikini:`                         |\n| 🎀   | `:ribbon:`                  | 🎩   | `:tophat:`             | 👑   | `:crown:`                    | 👒   | `:womans_hat:`                     |\n| 👞   | `:mans_shoe:`               | 🌂   | `:closed_umbrella:`    | 💼   | `:briefcase:`                | 👜   | `:handbag:`                        |\n| 👝   | `:pouch:`                   | 👛   | `:purse:`              | 👓   | `:eyeglasses:`               | 🎣   | `:fishing_pole_and_fish:`          |\n| ☕️ | `:coffee:`                  | 🍵   | `:tea:`                | 🍶   | `:sake:`                     | 🍼   | `:baby_bottle:`                    |\n| 🍺   | `:beer:`                    | 🍻   | `:beers:`              | 🍸   | `:cocktail:`                 | 🍹   | `:tropical_drink:`                 |\n| 🍷   | `:wine_glass:`              | 🍴   | `:fork_and_knife:`     | 🍕   | `:pizza:`                    | 🍔   | `:hamburger:`                      |\n| 🍟   | `:fries:`                   | 🍗   | `:poultry_leg:`        | 🍖   | `:meat_on_bone:`             | 🍝   | `:spaghetti:`                      |\n| 🍛   | `:curry:`                   | 🍤   | `:fried_shrimp:`       | 🍱   | `:bento:`                    | 🍣   | `:sushi:`                          |\n| 🍥   | `:fish_cake:`               | 🍙   | `:rice_ball:`          | 🍘   | `:rice_cracker:`             | 🍚   | `:rice:`                           |\n| 🍜   | `:ramen:`                   | 🍲   | `:stew:`               | 🍢   | `:oden:`                     | 🍡   | `:dango:`                          |\n| 🥚   | `:egg:`                     | 🍞   | `:bread:`              | 🍩   | `:doughnut:`                 | 🍮   | `:custard:`                        |\n| 🍦   | `:icecream:`                | 🍨   | `:ice_cream:`          | 🍧   | `:shaved_ice:`               | 🎂   | `:birthday:`                       |\n| 🍰   | `:cake:`                    | 🍪   | `:cookie:`             | 🍪   | `:cookie:`                   | 🍫   | `:chocolate_bar:`                  |\n| 🍬   | `:candy:`                   | 🍭   | `:lollipop:`           | 🍯   | `:honey_pot:`                | 🍎   | `:apple:`                          |\n| 🍏   | `:green_apple:`             | 🍊   | `:tangerine:`          | 🍋   | `:lemon:`                    | 🍒   | `:cherries:`                       |\n| 🍇   | `:grapes:`                  | 🍉   | `:watermelon:`         | 🍓   | `:strawberry:`               | 🍑   | `:peach:`                          |\n| 🍈   | `:melon:`                   | 🍌   | `:banana:`             | 🍐   | `:pear:`                     | 🍍   | `:pineapple:`                      |\n| 🍠   | `:sweet_potato:`            | 🍆   | `:eggplant:`           | 🍅   | `:tomato:`                   | 🌽   | `:corn:`                           |\n\n## 地点\n\n| 表情 | 代码                    | 表情 | 代码                         | 表情 | 代码                          | 表情 | 代码                         |\n| ---- | ----------------------- | ---- | ---------------------------- | ---- | ----------------------------- | ---- | ---------------------------- |\n| 🏠   | `:house:`             | 🏡   | `:house_with_garden:`      | 🏫   | `:school:`                  | 🏢   | `:office:`                 |\n| 🏣   | `:post_office:`       | 🏥   | `:hospital:`               | 🏦   | `:bank:`                    | 🏪   | `:convenience_store:`      |\n| 🏩   | `:love_hotel:`        | 🏨   | `:hotel:`                  | 💒   | `:wedding:`                 | ⛪️ | `:church:`                 |\n| 🏬   | `:department_store:`  | 🏤   | `:european_post_office:`   | 🌇   | `:city_sunrise:`            | 🌆   | `:city_sunset:`            |\n| 🏯   | `:japanese_castle:`   | 🏰   | `:european_castle:`        | ⛺️ | `:tent:`                    | 🏭   | `:factory:`                |\n| 🗼   | `:tokyo_tower:`       | 🗾   | `:japan:`                  | 🗻   | `:mount_fuji:`              | 🌄   | `:sunrise_over_mountains:` |\n| 🌅   | `:sunrise:`           | 🌠   | `:stars:`                  | 🗽   | `:statue_of_liberty:`       | 🌉   | `:bridge_at_night:`        |\n| 🎠   | `:carousel_horse:`    | 🌈   | `:rainbow:`                | 🎡   | `:ferris_wheel:`            | ⛲️ | `:fountain:`               |\n| 🎢   | `:roller_coaster:`    | 🚢   | `:ship:`                   | 🚤   | `:speedboat:`               | ⛵️ | `:boat:`                   |\n| ⛵️ | `:sailboat:`          | 🚣   | `:rowboat:`                | ⚓️ | `:anchor:`                  | 🚀   | `:rocket:`                 |\n| ✈️ | `:airplane:`          | 🚁   | `:helicopter:`             | 🚂   | `:steam_locomotive:`        | 🚊   | `:tram:`                   |\n| 🚞   | `:mountain_railway:`  | 🚲   | `:bike:`                   | 🚡   | `:aerial_tramway:`          | 🚟   | `:suspension_railway:`     |\n| 🚠   | `:mountain_cableway:` | 🚜   | `:tractor:`                | 🚙   | `:blue_car:`                | 🚘   | `:oncoming_automobile:`    |\n| 🚗   | `:car:`               | 🚗   | `:red_car:`                | 🚕   | `:taxi:`                    | 🚖   | `:oncoming_taxi:`          |\n| 🚛   | `:articulated_lorry:` | 🚌   | `:bus:`                    | 🚍   | `:oncoming_bus:`            | 🚨   | `:rotating_light:`         |\n| 🚓   | `:police_car:`        | 🚔   | `:oncoming_police_car:`    | 🚒   | `:fire_engine:`             | 🚑   | `:ambulance:`              |\n| 🚐   | `:minibus:`           | 🚚   | `:truck:`                  | 🚋   | `:train:`                   | 🚉   | `:station:`                |\n| 🚆   | `:train2:`            | 🚅   | `:bullettrain_front:`      | 🚄   | `:bullettrain_side:`        | 🚈   | `:light_rail:`             |\n| 🚝   | `:monorail:`          | 🚃   | `:railway_car:`            | 🚎   | `:trolleybus:`              | 🎫   | `:ticket:`                 |\n| ⛽️ | `:fuelpump:`          | 🚦   | `:vertical_traffic_light:` | 🚥   | `:traffic_light:`           | ⚠️ | `:warning:`                |\n| 🚧   | `:construction:`      | 🔰   | `:beginner:`               | 🏧   | `:atm:`                     | 🎰   | `:slot_machine:`           |\n| 🚏   | `:busstop:`           | 💈   | `:barber:`                 | ♨️ | `:hotsprings:`              | 🏁   | `:checkered_flag:`         |\n| 🎌   | `:crossed_flags:`     | 🏮   | `:izakaya_lantern:`        | 🗿   | `:moyai:`                   | 🎪   | `:circus_tent:`            |\n| 🎭   | `:performing_arts:`   | 📍   | `:round_pushpin:`          | 🚩   | `:triangular_flag_on_post:` | 🇯🇵 | `:jp:`                     |\n| 🇰🇷 | `:kr:`                | 🇨🇳 | `:cn:`                     | 🇺🇸 | `:us:`                      | 🇫🇷 | `:fr:`                     |\n| 🇪🇸 | `:es:`                | 🇮🇹 | `:it:`                     | 🇷🇺 | `:ru:`                      | 🇬🇧 | `:gb:`                     |\n| 🇬🇧 | `:uk:`                | 🇩🇪 | `:de:`                     |      |                               |      |                              |\n\n## 符号\n\n| 表情  | 代码                              | 表情  | 代码                                  | 表情  | 代码                          | 表情  | 代码                            |\n| ----- | --------------------------------- | ----- | ------------------------------------- | ----- | ----------------------------- | ----- | ------------------------------- |\n| 1️⃣ | `:one:`                         | 2️⃣ | `:two:`                             | 3️⃣ | `:three:`                   | 4️⃣ | `:four:`                      |\n| 5️⃣ | `:five:`                        | 6️⃣ | `:six:`                             | 7️⃣ | `:seven:`                   | 8️⃣ | `:eight:`                     |\n| 9️⃣ | `:nine:`                        | 🔟    | `:keycap_ten:`                      | 🔢    | `:1234:`                    | 0️⃣ | `:zero:`                      |\n| #️⃣ | `:hash:`                        | 🔣    | `:symbols:`                         | ◀️  | `:arrow_backward:`          | ⬇️  | `:arrow_down:`                |\n| ▶️  | `:arrow_forward:`               | ⬅️  | `:arrow_left:`                      | 🔠    | `:capital_abcd:`            | 🔡    | `:abcd:`                      |\n| 🔤    | `:abc:`                         | ↙️  | `:arrow_lower_left:`                | ↘️  | `:arrow_lower_right:`       | ➡️  | `:arrow_right:`               |\n| ⬆️  | `:arrow_up:`                    | ↖️  | `:arrow_upper_left:`                | ↗️  | `:arrow_upper_right:`       | ⏬    | `:arrow_double_down:`         |\n| ⏫    | `:arrow_double_up:`             | 🔽    | `:arrow_down_small:`                | ⤵️  | `:arrow_heading_down:`      | ⤴️  | `:arrow_heading_up:`          |\n| ↩️  | `:leftwards_arrow_with_hook:`   | ↪️  | `:arrow_right_hook:`                | ↔️  | `:left_right_arrow:`        | ↕️  | `:arrow_up_down:`             |\n| 🔼    | `:arrow_up_small:`              | 🔃    | `:arrows_clockwise:`                | 🔄    | `:arrows_counterclockwise:` | ⏪    | `:rewind:`                    |\n| ⏩    | `:fast_forward:`                | ℹ️  | `:information_source:`              | 🆗    | `:ok:`                      | 🔀    | `:twisted_rightwards_arrows:` |\n| 🔁    | `:repeat:`                      | 🔂    | `:repeat_one:`                      | 🆕    | `:new:`                     | 🔝    | `:top:`                       |\n| 🆙    | `:up:`                          | 🆒    | `:cool:`                            | 🆓    | `:free:`                    | 🆖    | `:ng:`                        |\n| 🎦    | `:cinema:`                      | 🈁    | `:koko:`                            | 📶    | `:signal_strength:`         | 🈹    | `:u5272:`                     |\n| 🈴    | `:u5408:`                       | 🈺    | `:u55b6:`                           | 🈯️  | `:u6307:`                   | 🈷️  | `:u6708:`                     |\n| 🈶    | `:u6709:`                       | 🈵    | `:u6e80:`                           | 🈚️  | `:u7121:`                   | 🈸    | `:u7533:`                     |\n| 🈳    | `:u7a7a:`                       | 🈲    | `:u7981:`                           | 🈂️  | `:sa:`                      | 🚻    | `:restroom:`                  |\n| 🚹    | `:mens:`                        | 🚺    | `:womens:`                          | 🚼    | `:baby_symbol:`             | 🚭    | `:no_smoking:`                |\n| 🅿️  | `:parking:`                     | ♿️  | `:wheelchair:`                      | 🚇    | `:metro:`                   | 🛄    | `:baggage_claim:`             |\n| 🚰    | `:potable_water:`               | 🚾    | `:wc:`                              | 🚮    | `:put_litter_in_its_place:` | ㊙️  | `:secret:`                    |\n| ㊗️  | `:congratulations:`             | Ⓜ️  | `:m:`                               | 🛂    | `:passport_control:`        | 🛅    | `:left_luggage:`              |\n| 🛃    | `:customs:`                     | 🉐    | `:ideograph_advantage:`             | 🆑    | `:cl:`                      | 🆘    | `:sos:`                       |\n| 🆔    | `:id:`                          | 🚫    | `:no_entry_sign:`                   | 🔞    | `:underage:`                | 📵    | `:no_mobile_phones:`          |\n| 🚯    | `:do_not_litter:`               | 🚱    | `:non-potable_water:`               | 🚳    | `:no_bicycles:`             | 🚷    | `:no_pedestrians:`            |\n| 🚸    | `:children_crossing:`           | ⛔️  | `:no_entry:`                        | ✳️  | `:eight_spoked_asterisk:`   | ✴️  | `:eight_pointed_black_star:`  |\n| 💟    | `:heart_decoration:`            | 🆚    | `:vs:`                              | 📳    | `:vibration_mode:`          | 📴    | `:mobile_phone_off:`          |\n| 💹    | `:chart:`                       | 💱    | `:currency_exchange:`               | ♈️  | `:aries:`                   | ♉️  | `:taurus:`                    |\n| ♊️  | `:gemini:`                      | ♋️  | `:cancer:`                          | ♌️  | `:leo:`                     | ♍️  | `:virgo:`                     |\n| ♎️  | `:libra:`                       | ♏️  | `:scorpius:`                        | ♐️  | `:sagittarius:`             | ♑️  | `:capricorn:`                 |\n| ♒️  | `:aquarius:`                    | ♓️  | `:pisces:`                          | ⛎    | `:ophiuchus:`               | 🔯    | `:six_pointed_star:`          |\n| ❎    | `:negative_squared_cross_mark:` | 🅰️  | `:a:`                               | 🅱️  | `:b:`                       | 🆎    | `:ab:`                        |\n| 🅾️  | `:o2:`                          | 💠    | `:diamond_shape_with_a_dot_inside:` | ♻️  | `:recycle:`                 | 🔚    | `:end:`                       |\n| 🔛    | `:on:`                          | 🔜    | `:soon:`                            | 🕐    | `:clock1:`                  | 🕜    | `:clock130:`                  |\n| 🕙    | `:clock10:`                     | 🕥    | `:clock1030:`                       | 🕚    | `:clock11:`                 | 🕦    | `:clock1130:`                 |\n| 🕛    | `:clock12:`                     | 🕧    | `:clock1230:`                       | 🕑    | `:clock2:`                  | 🕝    | `:clock230:`                  |\n| 🕒    | `:clock3:`                      | 🕞    | `:clock330:`                        | 🕓    | `:clock4:`                  | 🕟    | `:clock430:`                  |\n| 🕔    | `:clock5:`                      | 🕠    | `:clock530:`                        | 🕕    | `:clock6:`                  | 🕡    | `:clock630:`                  |\n| 🕖    | `:clock7:`                      | 🕢    | `:clock730:`                        | 🕗    | `:clock8:`                  | 🕣    | `:clock830:`                  |\n| 🕘    | `:clock9:`                      | 🕤    | `:clock930:`                        | 💲    | `:heavy_dollar_sign:`       | ©️  | `:copyright:`                 |\n| ®️  | `:registered:`                  | ™️  | `:tm:`                              | ❌    | `:x:`                       | ❗️  | `:heavy_exclamation_mark:`    |\n| ‼️  | `:bangbang:`                    | ⁉️  | `:interrobang:`                     | ⭕️  | `:o:`                       | ✖️  | `:heavy_multiplication_x:`    |\n| ➕    | `:heavy_plus_sign:`             | ➖    | `:heavy_minus_sign:`                | ➗    | `:heavy_division_sign:`     | 💮    | `:white_flower:`              |\n| 💯    | `:100:`                         | ✔️  | `:heavy_check_mark:`                | ☑️  | `:ballot_box_with_check:`   | 🔘    | `:radio_button:`              |\n| 🔗    | `:link:`                        | ➰    | `:curly_loop:`                      | 〰️  | `:wavy_dash:`               | 〽️  | `:part_alternation_mark:`     |\n| 🔱    | `:trident:`                     | ✅    | `:white_check_mark:`                | 🔲    | `:black_square_button:`     | 🔳    | `:white_square_button:`       |\n| ⚫️  | `:black_circle:`                | ⚪️  | `:white_circle:`                    | 🔴    | `:red_circle:`              | 🔵    | `:large_blue_circle:`         |\n| 🔷    | `:large_blue_diamond:`          | 🔶    | `:large_orange_diamond:`            | 🔹    | `:small_blue_diamond:`      | 🔸    | `:small_orange_diamond:`      |\n| 🔺    | `:small_red_triangle:`          | 🔻    | `:small_red_triangle_down:`         |       |                               |       |                                 |\n","tags":["markdown emoji","github emoji"],"categories":["emoji"]},{"title":"JAVA9 新特性","url":"/2023/02/fb6d7cde.html","content":"> JAVA9 并非一个长期更新版本，但是其中的一些新特性也代表着 Java 更新的方向\n\n<!-- more -->\n\n# JDK 目录的变化\n\n在 JavaSE 9 之前：\n\n* bin目录用于包含命令行开发和调试工具，如javac，jar和javadoc。 它还用于包含Java命令来启动Java应用程序。\n* include目录包含在编译本地代码时使用的C/C++头文件。\n* lib目录包含JDK工具的几个JAR和其他类型的文件。 它有一个tools.jar文件，其中包含javac编译器的Java类。\n* jre\\bin目录包含基本命令，如java命令。 在Windows平台上，它包含系统的运行时动态链接库（DLL）。\n* jre\\lib目录包含用户可编辑的配置文件，如.properties和.policy文件。\n* jre\\lib\\approved目录包含允许使用标准覆盖机制的JAR。 这允许在Java社区进程之外创建的实施标准或独立技术的类和接口的更高版本被并入Java平台。 这些JAR被添加到JVM的引导类路径中，从而覆盖了Java运行时中存在的这些类和接口的任何定义。\n* jre\\lib\\ext目录包含允许扩展机制的JAR。 该机制通过扩展类加载器（该类加载器）加载了该目录中的所有JAR，该引导类加载器是系统类加载器的子进程，它加载所有应用程序类。 通过将JAR放在此目录中，可以扩展Java SE平台。 这些JAR的内容对于在此运行时映像上编译或运行的所有应用程序都可见。\n* jre\\lib目录包含几个JAR。 rt.jar文件包含运行时的Java类和资源文件。 许多工具依赖于rt.jar文件的位置。\n* jre\\lib目录包含用于非Windows平台的动态链接本地库。\n* jre\\lib目录包含几个其他子目录，其中包含运行时文件，如字体和图像。\n\n从 JavaSE 9 开始：\n\n* 没有名为jre的子目录。\n* bin目录包含所有命令。 在Windows平台上，它继续包含系统的运行时动态链接库。\n* conf目录包含用户可编辑的配置文件，例如以前位于jre\\lib目录中的.properties和.policy文件。\n* include目录包含要在以前编译本地代码时使用的C/C++头文件。 它只存在于JDK中。\n* jmods目录包含JMOD格式的平台模块。 创建自定义运行时映像时需要它。 它只存在于JDK中。\n* legal 目录包含法律声明。\n* lib目录包含非Windows平台上的动态链接本地库。 其子目录和文件不应由开发人员直接编辑或使用。\n\n# 接口可以添加私有方法\n\n继 Java8 可以添加默认方法之后，Java9 支持添加私有方法了，给人一种和抽象类越来越像的感觉\n\n```java\npublic interface InterfaceA {\n    void methodA();\n\n    default void defaultMethod() {\n        System.out.println(\"default method!\");\n        System.out.println(\"call private method...\");\n        privateMethod();\n    }\n\n    private void privateMethod() {\n        System.out.println(\"private method!\");\n    }\n}\n```\n\n* 接口中的私有方法可以提供给 default 修饰的方法调用，在子类中是不可调用的\n\n# try-with-resource 语法糖支持将外部变量写在括号内\n\n```java\npublic class TryWithResource {\n    public static void main(String[] args) throws IOException {\n        FileReader fileReader = new FileReader(Objects.requireNonNull(TryWithResource.class.getResource(\"/file.txt\")).getPath());\n        BufferedReader bufferedReader = new BufferedReader(fileReader);\n        try (fileReader; bufferedReader) {\n            // 具体操作\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        }\n    }\n}\n```\n\n* 此写法使得 try-resource 的括号中的内容不再臃肿\n\n# 变量命名时禁止使用 ‘_’\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"1677650907021\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic1677650907021.png\" style=\"width: 100%;\">\n</div>\n\n* 在 Java8 中，单独使用 `_` 作为变量名会有警告信息，Java9 中已经是会报错了\n\n# @Deprecated 注解添加属性\n\n```java\n/*\n * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.*;\nimport static java.lang.annotation.ElementType.*;\n\n/**\n * A program element annotated {@code @Deprecated} is one that programmers\n * are discouraged from using. An element may be deprecated for any of several\n * reasons, for example, its usage is likely to lead to errors; it may\n * be changed incompatibly or removed in a future version; it has been\n * superseded by a newer, usually preferable alternative; or it is obsolete.\n *\n * <p>Compilers issue warnings when a deprecated program element is used or\n * overridden in non-deprecated code. Use of the {@code @Deprecated}\n * annotation on a local variable declaration or on a parameter declaration\n * or a package declaration has no effect on the warnings issued by a compiler.\n *\n * <p>When a module is deprecated, the use of that module in {@code\n * requires}, but not in {@code exports} or {@code opens} clauses causes\n * a warning to be issued. A module being deprecated does <em>not</em> cause\n * warnings to be issued for uses of types within the module.\n *\n * <p>This annotation type has a string-valued element {@code since}. The value\n * of this element indicates the version in which the annotated program element\n * was first deprecated.\n *\n * <p>This annotation type has a boolean-valued element {@code forRemoval}.\n * A value of {@code true} indicates intent to remove the annotated program\n * element in a future version. A value of {@code false} indicates that use of\n * the annotated program element is discouraged, but at the time the program\n * element was annotated, there was no specific intent to remove it.\n *\n * @apiNote\n * It is strongly recommended that the reason for deprecating a program element\n * be explained in the documentation, using the {@code @deprecated}\n * javadoc tag. The documentation should also suggest and link to a\n * recommended replacement API, if applicable. A replacement API often\n * has subtly different semantics, so such issues should be discussed as\n * well.\n *\n * <p>It is recommended that a {@code since} value be provided with all newly\n * annotated program elements. Note that {@code since} cannot be mandatory,\n * as there are many existing annotations that lack this element value.\n *\n * <p>There is no defined order among annotation elements. As a matter of\n * style, the {@code since} element should be placed first.\n *\n * <p>The {@code @Deprecated} annotation should always be present if\n * the {@code @deprecated} javadoc tag is present, and vice-versa.\n *\n * @author  Neal Gafter\n * @since 1.5\n * @jls 9.6.4.6 @Deprecated\n */\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})\npublic @interface Deprecated {\n    /**\n     * Returns the version in which the annotated element became deprecated.\n     * The version string is in the same format and namespace as the value of\n     * the {@code @since} javadoc tag. The default value is the empty\n     * string.\n     *\n     * @return the version string\n     * @since 9\n     */\n    String since() default \"\";\n\n    /**\n     * Indicates whether the annotated element is subject to removal in a\n     * future version. The default value is {@code false}.\n     *\n     * @return whether the element is subject to removal\n     * @since 9\n     */\n    boolean forRemoval() default false;\n}\n```\n\n* `since` 属性表示从哪个版本开始弃用\n* `forRemoval` 表示未来是否会删除\n\n# String类底层优化\n\n1. 底层使用 `byte[]` 代替 `char[]` 存储，当字符串是全英文的时候，可以节省空间\n2. 新增了 `COMPACT_STRINGS` 和 `coder` 两个成员变量\n   1. `COMPACT_STRINGS`：是否压缩。true-压缩；false-不压缩，使用 UTF16 编码格式\n   2. `coder`：当前使用的编码。LATIN1(0)-拉丁，UTF16(1)\n\n# Jmod 模块化\n\n当我们开发web应用时， `Java` 自带有很多无用的包也必须加载，如：awt、application……但是实际上我们用不到这些包。Java9 模块化的特性将这些基础的包分成了各个模块，开发者可以通过 module-info.java 这个文件限制当前模块哪些类是可以开放给外界使用的，哪些类是我需要的\n\n> 对比 [Java8](https://docs.oracle.com/javase/8/docs/api/index.html) 和 [Java9](https://docs.oracle.com/javase/9/docs/api/overview-summary.html) 的官方文档，我们可以发现 Java9 的官方文档首页显示的是 module，而 Java8 的是 package\n\nmodule-info.java\n\n```java\nmodule java9Demo {\n    requires xxx;\n    exports xxx; // 导出包，表示允许访问指标包中的 public 成员\n    opens xxx2; // 导出包，表示允许在运行时通过反射的形式访问\n    uses xxxInterface;\n    provides xxxInterface with xxxImplClass; // 语句指定一个或多个服务接口的实现类\n}\n```\n\n* 使用 `requires` 表示需要本模块依赖哪些接口\n* 使用 `exports` 表示本模块要开放哪些接口，即依赖方可以访问哪些包下面的 public 资源，但是不可以通过反射访问，运行时会报错\n* 使用 `opens` 表示本模块哪些成员可以在，即依赖方可以在运行时通过反射的方式访问哪些资源，但是不可以直接访问，编译时会报错\n* 使用 `uses` 表示本模块的接口是需要依赖引用的模块实现的，使用服务接口的名字,当前模块就会发现它,使用 `java.util.ServiceLoader` 类进行加载,必须是本模块中的,不能是其他模块中的.其实现类可以由其他模块提供.\n* 使用 `provides xxxInterface with xxxImplClass` 表示本模块的接口使用的哪个实现\n\n# JShell 工具\n\n> 类似于 node、ruby 等包含直接运行简单脚本的交互环境，Java9 也添加了类似的环境，同时也可以类比一下浏览器的开发者工具的控制台，可以直接运行简单的 js 脚本\n\n* 通过 jshell 命令进入终端，然后写简单的语句即可实时获取结果\n\n  <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n    <img alt=\"1678179847508\" src=\"https://blog-pic-bed.oss-cn-beijing.aliyuncs.com/blog-pic1678179847508.png\" style=\"width: 100%;\">\n  </div>","tags":["Java9新特性"],"categories":["Java新特性"]},{"title":"专题 —— 数据结构与算法 - 06 番外 - 表达式求值","url":"/2022/03/ef31f377.html","content":"`OperatorEnum`: 简单加减乘除的枚举类\n\n<!-- more -->\n\n```java\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NonNull;\n\n/**\n * 操作符\n */\n@Getter\n@AllArgsConstructor\npublic enum OperatorEnum {\n    ADD(\"+\", 1) {\n        @Override\n        public Number eval(@NonNull Number number1, @NonNull Number number2) {\n            return number1.doubleValue() + number2.doubleValue();\n        }\n    },\n    SUBTRACT(\"-\", 1) {\n        @Override\n        public Number eval(@NonNull Number number1, @NonNull Number number2) {\n            return number1.doubleValue() - number2.doubleValue();\n        }\n    },\n    MULTIPLY(\"*\", 2) {\n        @Override\n        public Number eval(@NonNull Number number1, @NonNull Number number2) {\n            return number1.doubleValue() * number2.doubleValue();\n        }\n    },\n    DIVIDE(\"/\", 2) {\n        @Override\n        public Number eval(@NonNull Number number1, @NonNull Number number2) {\n            return number1.doubleValue() / number2.doubleValue();\n        }\n    }\n    ;\n    /**\n     * 操作符 + - * /\n     */\n    private final String operationalCharacter;\n\n    /**\n     * 操作符 优先级权重，越大优先级越高：乘除比加减的优先级高\n     */\n    private final Integer priorityWeight;\n\n    public abstract Number eval(@NonNull Number number1, @NonNull Number number2);\n\n    public static OperatorEnum valueOfOperationalCharacter(String operationalCharacter) {\n        for (OperatorEnum value : values()) {\n            if (value.operationalCharacter.equals(operationalCharacter)) {\n                return value;\n            }\n        }\n        return null;\n    }\n}\n```\n\n# 表达式的前缀、中缀、后缀\n\n## 中缀表达式（中缀记法）\n\n> a + (b + c) / d\n\n中缀表达式是一种通用的算数或逻辑公式的表示方法，操作符处于操作数之间，是最直观、人脑最容易理解的表达式，但是计算机并不容易理解\n\n## 前缀表达式（前缀记法、波兰式）\n\n> \\+ / + b c d a\n\n前缀表达式的操作符位于操作数之前\n\n### 计算机求值方式\n\n从右至左扫描表达式，遇到数字的时候，直接压入栈中，遇到运算符时，弹出两个操作数，计算结果并将结果压入栈中，重复此过程直到表达式最左端\n\n例如 “$(3 + 4) \\times 5 - 6$” ->“- × + 3 4 5 6”：\n\n1. 从右至左扫描，将6、5、4、3压入堆栈\n2. 遇到 $+$ 运算符，因此弹出3和4，计算出 $3+4$ 的值，得7，再将7入栈\n3. 接下来是 $\\times$ 运算符，因此弹出7和5，计算出 $7\\times5=35$ ，将35入栈\n4. 最后是 $-$ 运算符，计算出 $35-6$ 的值，即29，由此得出最终结果\n\n```java\npublic static Number eval(String expression) {\n    Stack<Number> stack = new Stack<>();\n    List<String> operators = Arrays.stream(OperatorEnum.values())\n        .map(OperatorEnum::getOperationalCharacter)\n        .collect(Collectors.toList());\n    String[] split = expression.split(\" \");\n    for (int i = split.length - 1; i >= 0; i--) {\n        String operator = split[i];\n        if (!operators.contains(operator)) {\n            stack.push(Double.parseDouble(String.valueOf(operator)));\n            continue;\n        }\n        OperatorEnum operatorEnum = OperatorEnum.valueOfOperationalCharacter(operator);\n        assert operatorEnum != null;\n        Number result = operatorEnum.eval(stack.pop(), stack.pop());\n        stack.push(result);\n    }\n    Number result = stack.pop();\n    if (!stack.isEmpty()) {\n        throw new IllegalArgumentException(\"表达式错误\");\n    }\n    return result;\n}\n```\n\n## 后缀表达式（后缀记法，逆波兰式）\n\n> b c + d / a +\n\n后缀表达式的操作符位于操作数之后\n\n### 计算机求值方式\n\n与前缀表达式类似，只是顺序是从左至右：\n从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。\n例如“$(3 + 4) \\times 5 - 6$” ->“3 4 + 5 × 6 -”：\n\n1. 从左至右扫描，将3和4压入堆栈\n2. 遇到 $+$ 运算符，因此弹出4和3，计算出 $3+4$ 的值，得7，再将7入栈\n3. 将5入栈\n4. 接下来是 $\\times$ 运算符，因此弹出5和7，计算出 $7\\times5=35$ ，将35入栈\n5. 将6入栈\n6. 最后是 $-$ 运算符，计算出 $35-6$ 的值，即29，由此得出最终结\n\n```java\npublic static Number eval(String expression) {\n    String[] split = expression.split(\" \");\n    Stack<String> stack = new Stack<>();\n    for (int i = split.length - 1; i >= 0; i--) {\n        String operator = split[i];\n        stack.push(operator);\n    }\n    while (stack.size() > 1) {\n        Double number1 = Double.parseDouble(stack.pop());\n        Double number2 = Double.parseDouble(stack.pop());\n        String operatorChar = stack.pop();\n        OperatorEnum operatorEnum = OperatorEnum.valueOfOperationalCharacter(operatorChar);\n        assert operatorEnum != null;\n        Number result = operatorEnum.eval(number1, number2);\n        stack.push(String.valueOf(result));\n    }\n    return Double.parseDouble(stack.pop());\n}\n```\n\n# 中缀表达式转换为[前/后]缀表达式\n\n```java\n\n```\n","tags":["栈应用","表达式求值"]},{"title":"专题 —— 数据结构与算法 - 05 线性表 - 栈、队列","url":"/2021/11/1f63d870.html","content":"> 栈和队列都是一种运算受限的线性表，因为其运算受限，所以才有一些优秀的特性\n\n# 栈\n\n> 栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。`<right-bq>`——来自[百度百科](https://baike.baidu.com/item/%E6%A0%88/12808149)`</right-bq>`\n\n<!-- more -->\n\n## 栈是什么\n\n栈是一种后进先出的线性结构，一个比较贴切的例子就是一摞叠在一起的盘子，我们总是会将盘子叠在原有的上面，取的时候也总是从最上面的开始取。**后进者先出，先进者后出**就是栈结构\n\n## 相关概念\n\n* 顺序栈：使用数组实现的栈\n* 链式栈：使用链表实现的栈\n* 栈顶：允许数据插入和删除的一端\n* 栈底：栈顶的另一端\n* 入栈/压栈(push)：将数据插入栈\n* 出栈/弹栈(pop)：删除栈顶的数据\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20220323162300\" src=\"https://s2.loli.net/2022/03/23/EqO72l4RCiYWQmM.png\" style=\"width: 100%;\">\n</div>\n## 复杂度\n\n以顺序栈为例：在实现栈时，我们需要存储栈顶和栈底，所以弹栈和压栈都是 $O(1)$ 的时间复杂度，但是当栈满了之后继续压栈就需要扩容，若栈的容量为 $k$，那么在进行了 $k$ 次压栈之后就需要一个 $O(k)$ 的扩容，均摊下来之后，时间复杂度依旧为 $O(1)$\n\n## 栈的应用\n\n1. 浏览器的前进后退功能\n2. `JVM`中的**栈**：程序运行总伴随着方法的调用，方法执行前会先保留现场，然后将参数、临时变量等信息封装为一个栈帧压入栈中，执行完毕之后将此栈帧从栈中弹出，所以递归调用时如果不设置方法出口(``return `)就会发生栈溢出 `StackOverflowError`\n3. 表达式求值：可看后文\n4. 括号匹配\n\n# 队列\n\n> **队列**，又称为**伫列**（queue），[计算机科学](https://zh.wikipedia.org/wiki/計算機科學)中的一种[抽象资料型别](https://zh.wikipedia.org/wiki/抽象資料型別)，是[先进先出](https://zh.wikipedia.org/wiki/先進先出演算法)（FIFO, First-In-First-Out）的[线性表](https://zh.wikipedia.org/wiki/线性表)。在具体应用中通常用[链表](https://zh.wikipedia.org/wiki/链表)或者[数组](https://zh.wikipedia.org/wiki/数组)来实现。队列只允许在后端（称为*rear*）进行插入操作，在前端（称为*front*）进行删除操作。`<right-bq>`——来自[维基百科](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97)`</right-bq>`\n\n## 队列是什么\n\n队列是一种先进先出的结构，比较贴切的例子就是排队买票，先来的先买，后来的排到队尾，不可以插队。**先进者先出**就是队列\n\n## 相关概念\n\n* 顺序队列：使用数组实现的队列\n* 链式队列：使用链表实现的队列\n* 循环队列：队首队尾相连的队列\n* 阻塞队列：当队列为空时，不允许出队操作，当队列满时，不允许入队操作\n* 并发队列：可以保证并发时线程安全的队列\n* 队首(front)：可以进行出队的一端\n* 队尾(rear)：可以进行入队的一端\n* 入队(enqueue)：将数据插入到队列中\n* 出队(dequeue)：从队列中取出数据\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20220323173707\" src=\"https://s2.loli.net/2022/03/23/WyksNeIJhMKi8bO.png\" style=\"width: 100%;\">\n</div>\n","tags":["数据结构与算法","栈","队列"]},{"title":"数据结构与算法 - 线性表 - 链表注意事项","url":"/2021/11/3439f55d.html","content":"# 重要概念——指针\n\n> 指针在不同的语言中叫法不同，比如在 C 语言中叫做指针，但是在 Java 中叫做引用，虽然名字不同，但是实际上是同一种东西\n\n<!-- more -->\n\n## 指针是什么？\n\n指针是存储地址的变量，通过指针可以访问到该地址的数据。需要注意的是，指针变量只用来存储地址值，其并不关心该地址值是否可用，地址是否有效，寻址时才会关心这些\n\n举个🌰：\n\n今天天气不错，所以你在商场吃多了(别问为啥，我也不知道)，吃多了之后你就想去厕所释放一下，但是你不知道厕所在哪，所以你问服务员，然后服务员给了你一个纸条，上面写着厕所的地址，这个纸条就可以理解成指针，因为它存储了厕所的地址\n\n## C语言和其他语言的指针\n\nC语言的指针几乎可以访问任意数据，而指针所在的内存也是通过函数申请来的，所以在使用完之后需要手动释放内存空间。对于 Java、Go 等有垃圾回收器的语言来说，就不需要手动释放内存了。\n\n# 哨兵\n\n> 哨兵：守卫边疆的英雄！\n\n哨兵节点就是边界节点——头节点或尾节点（一般是头节点），这个节点不存储元素，目的是用来简化链表的实现难度，减少边界值的处理\n\n## 向空链表插入节点\n\n向指定节点 p 后面插入节点时，只需要如下两行代码即可\n\n```c\nnewNode.next = p.next;\np.next = newNode;\n```\n\n但是向空链表插入节点时，因为没有头节点，所以需要将插入节点变为头节点\n\n```c\nif (head == null) {\n    head = newNode;\n}\n```\n\n## 删除链表的最后一个节点\n\n> 节点前面的节点叫做前驱节点，后面的叫做后继节点\n\n如果我们要删除某节点的后继节点，用下面一行代码即可搞定：\n\n```c\np.next = p.next.next;\n```\n\n但是如果该节点是链表的最后一个节点，就不能这么删除了，需要进行判断\n\n```c\nif (head.next == null) {\n    head = null;\n}\n```\n\n## 添加哨兵后\n\n> 哨兵节点并不会存储任何数据，它就是单纯作为头节点存在的\n>\n> 有哨兵节点的链表叫做带头链表，反之则称为不带头链表\n\n向空链表插入节点时，`p` 就是 `head` 节点，删除链表的最后一个节点时，`p` 还是 `head` 节点，使用原有的逻辑即可\n\n# 一些注意点\n\n## 善于画图\n\n画图可以清晰地表达出逻辑关系，便于理解，同时，代码写完后画图走一遍也更容易找出 bug\n\n## 注意边界条件\n\n在软件开发中，代码在边界情况下极容易产生 bug。比如链表，在实现的时候就需要考虑在边界条件下代码是否正常：\n\n* 链表为空时\n* 只包含一个节点或只包含两个节点时\n* 对于头尾节点的操作\n\n## 多练习\n\n熟能生巧，通过大量的练习，我们可以找到很多写代码的感觉，积累很多经验\n","tags":["数据结构与算法","链表","指针","哨兵"]},{"title":"数据结构与算法 - 线性表 - 数组、链表","url":"/2021/10/17da1b31.html","content":"\n# 线性表\n\n> 线性表是最基本、最简单、也是最常用的一种数据结构。线性表*（linear list）*是[数据结构](https://baike.baidu.com/item/数据结构/1450)的一种，一个线性表是n个具有相同特性的数据元素的[有限序列](https://baike.baidu.com/item/有限序列/22032089)。<right-bq>——来自[百度百科](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081)</right-bq>\n\n* 说白了线性表就是数据就像排成一条线一样的结构，主要有：数组、链表、队列、栈等\n\n**与之对应的就是*非线性表*，非线性表指的就是类似于树、图等结构**\n\n<!-- more -->\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20211025190256\" src=\"https://i.loli.net/2021/10/25/mbiWj3QfJgyO2dp.png\" style=\"width: 100%;\">\n</div>\n# 数组\n\n> 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据\n\n## 数组的下标为什么从 0 开始呢？\n\n生活中，我们总是习惯从 1 开始计数，为什么数组的索引是从 0 开始呢？下图是一个数组的示意图：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20211025192541\" src=\"https://i.loli.net/2021/10/25/3rmSd8z97cgi2Ln.png\" style=\"width: 100%;\">\n</div>\n\n1. 数据类型是需要占据一定的空间的，但是不同的数据类型占据不同大小的空间，所以每种数据类型都有自己的 `type_size`\n2. 数据是一组**连续**的内存空间，存储的是**相同类型**的数据\n\n由上面两点可以想到什么呢？\n\n* 我们只需要存储数组的首元素地址，之后的地址就可以直接计算出来了：$首元素地址 + n \\times type\\_size$\n* 如果 $n$ 从 1 开始，计算某个元素的地址的时候就需要有**减 1** 的操作，如果从 0 开始，就不需要了\n\n## 数组的特性\n\n### 查询、替换效率高\n\n* 当通过数组访问指定索引的元素时，CPU 可以根据数组地址和元素所在索引直接计算出该元素的地址，所以时间复杂度是 $O(1)$\n\n### 插入删除效率低\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"array\" src=\"https://i.loli.net/2021/10/29/JYhPEbeX7Ur8WAf.png\" style=\"width: 100%;\">\n</div>\n\n#### 插入\n\n如上图所示数组，如果我们要在 `a` 和 `b` 中间插入 `f`：\n\n1. 我们需要将元素 `b`、`c`、`d`、`e` 向后移动一个位置，然后将 `f` 插入到原本 `b` 的位置，插入后的数组为 `a f b c d e`\n2. 我们只需要将 `b` 放到最后一个位置，然后将 `f` 放入原本 `b` 的位置，插入后的数组为 `a f c d e b`\n\n方法 1 因为会进行很多次的移动操作，所以插入的效率和插入的位置有关，位置越靠前，效率越低；方法 2 的时间复杂度就是固定的，但是插入后数组原本的顺序改变了，这是一个需要注意的点\n\n#### 删除\n\n如上图所示，如果我们要删除 `a`，删除之后需要将 `b c d e` 四个元素向前移动，删除后的顺序为 `b c d e`\n\n**如果要删除多个呢？**\n\n* 如果要删除多个元素，我们可以先将要删除的元素标记出来，然后一次性删除，最后再整理数组\n\n  > ps：如果了解JVM的垃圾回收的话，会发现这个和标记清除算法比较像\n\n**很多时候并不需要死背数据结构和算法，搞清楚它背后的逻辑和思想更有价值**\n\n## 数组越界\n\n在 C 语言中，只要不是禁止访问的内存，所有的内存地址都是可以读出来的，所以我们可以试一下执行这段代码：\n\n```c\n#include <stdio.h>\n\nint main(int argc, char* argv[]) {\n    int arr[] = {0};\n    printf(\"%d\\r\\n\", arr[0]);\n    printf(\"%d\\r\\n\", arr[1]);\n    printf(\"%d\\r\\n\", arr[2]);\n}\n```\n\n执行结果：\n\n```text\n0\n-296302744\n32766\n```\n\n我们可以看到第一行是 `arr[0]` 的值，第二行第三行是紧跟着的内存空间里面的**“垃圾”**，所以需要程序员注意这点。但是在 java 等语言中，是自带数组越界的检查的。\n\n## 容器是否可以完全替代数组\n\n>  现在很多编程语言都提供了好用的容器，其可以自动扩容，毕竟数组是需要预先指定大小的，那个容器这么好用，是否可以完全替代数组呢？\n\n* 如果是业务开发，代码的可读性要更加重要，也不会在乎这一点的性能，所以适合使用容器\n* 如果是底层开发，比如说中间件、系统等，需要将性能压榨到极致，就适合使用数组这种基本类型\n\n# 链表\n\n> 链表是一种物理[存储单元](https://baike.baidu.com/item/存储单元/8727749)上非连续、非顺序的[存储结构](https://baike.baidu.com/item/存储结构/350782)，[数据元素](https://baike.baidu.com/item/数据元素/715313)的逻辑顺序是通过链表中的[指针](https://baike.baidu.com/item/指针/2878304)链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储[数据元素](https://baike.baidu.com/item/数据元素)的数据域，另一个是存储下一个结点地址的[指针](https://baike.baidu.com/item/指针/2878304)域。<right-bq>——[百度百科](https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473)</right-bq>\n\n## 链表与数组\n\n链表与数组都属于线性表，但是数组是一段连续的内存结构，如果我们要申请 100M 大小的数组，但是当前系统中没有连续的 100M 内存，就算空闲内存有 200M 也无法申请成功\n\n但是链表的结构并不需要连续的存储空间，所以链表是可以申请成功的（单个元素需要的空间不是特别大的情况下）\n\n**链表与数组都可以进行数据的插入和删除操作**\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"链表结构示意图\" src=\"https://i.loli.net/2021/10/29/KIOkPjZFyhpzJub.png\" style=\"width: 100%;\">\n</div>\n## 链表的结构\n\n> 链表结构很多，主要是 **单链表**、**双向链表**、**循环链表**、**双向循环链表**\n\n### 单链表\n\n1. 结构\n\n   1. 代码（Java版本）\n\n      ```java\n      class Node<T> {\n          T element;\n          Node<T> next;\n      }\n      ```\n      \n   2. 图示\n   \n      <div style=\"max-width: 25%; margin: auto; opacity: 0.95;\">\n        <img alt=\"20211029195813\" src=\"https://i.loli.net/2021/10/29/D5YcxRlVnOHmg9W.png\" style=\"width: 100%;\">\n      </div>\n   \n2. 示意图\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"20211029195630\" src=\"https://i.loli.net/2021/10/29/cKE3jvLebz4DgBx.png\" style=\"width: 100%;\">\n   </div>\n   * 里面有两个比较特殊的节点\n     1. 第一个节点：没有任何节点指向它，我们叫它头节点\n     2. 最后一个节点：它的 `next` 指向了 `null`，我们叫它尾节点\n\n3. 操作\n\n   1. 插入元素\n\n      1. 示意图\n\n         <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n           <img alt=\"20211103200005\" src=\"https://i.loli.net/2021/11/03/fmQHw3xMtLYO9Z7.png\" style=\"width: 100%;\">\n         </div>\n         \n      2. 链表的插入和删除只需要考虑相邻节点的指针指向就好了\n\n   2. 删除元素\n\n      <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n        <img alt=\"20211103200458\" src=\"https://i.loli.net/2021/11/03/mGQRcYrsvI8V5S4.png\" style=\"width: 100%;\">\n      </div>\n\n### 双向链表\n\n1. 结构\n\n   1. 代码（`Java` 版本）\n\n      ```java\n      class Node<T> {\n          Node<T> prev;\n          T element;\n          Node<T> next;\n      }\n      ```\n      \n   2. 图示\n   \n      <div style=\"max-width: 35%; margin: auto; opacity: 0.95;\">\n        <img alt=\"20211102200626\" src=\"https://i.loli.net/2021/11/02/jzk2vA6fcnHeUxE.png\" style=\"width: 100%;\">\n      </div>\n   \n2. 示意图\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"20211102201021\" src=\"https://i.loli.net/2021/11/02/dG9SEKkCD1caxpF.png\" style=\"width: 100%;\">\n   </div>\n\n   * 也有两个特殊的节点：\n     1. 第一个节点：头节点，其 `prev` 指向 `null`\n     2. 最后一个节点：尾节点，其 `next` 指向 `null`\n   \n3. 操作\n\n   1. 插入\n\n      <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n        <img alt=\"20211103202519\" src=\"https://i.loli.net/2021/11/03/hcv8IptSFgiYMqe.png\" style=\"width: 100%;\">\n      </div>\n\n   2. 删除\n\n      <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n        <img alt=\"20211104120032\" src=\"https://i.loli.net/2021/11/04/XVIkRmGwEr1Q6OJ.png\" style=\"width: 100%;\">\n      </div>\n\n### 循环链表\n\n1. 结构\n\n   * 同单链表\n\n2. 示意图\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"20211104151405\" src=\"https://i.loli.net/2021/11/04/R7F41iLhGf6MOdl.png\" style=\"width: 100%;\">\n   </div>\n\n   * 在循环链表中，必须有一个指针指向头节点\n\n3. 操作\n\n   * 同单链表，注意删除最后一个元素时的区别\n   * 判断链表是否有环\n     * 可以设置两个指针遍历链表，一个一次走一个元素，一个一次走两个元素，如果遍历时两个指针指向了同一个元素，即代表有环\n\n### 双向循环链表\n\n1. 结构\n\n   * 同双向链表\n\n2. 示意图\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"20211104152022\" src=\"https://i.loli.net/2021/11/04/82nAfwkYWLl5hKi.png\" style=\"width: 100%;\">\n   </div>\n\n   * 在循环链表中，必须有一个指针指向头节点\n\n3. 操作\n\n   * 同双向链表，注意删除最后一个元素时的区别\n\n## 链表的查询\n\n链表在查询时，因为没办法直接计算出元素所在的地址，所以就只能一个元素一个元素的找，其时间复杂度为 $O(n)$\n\n对于双向循环链表，可以根据元素的位置判断要向哪个方向找，效率会高一些\n\n# 链表与数组比较\n\n## 性能\n\n数组和链表由于不同的数据组织方式，其插入、删除、随机访问的效率正好是相反的\n\n|            | 链表   | 数组   |\n| ---------- | ------ | ------ |\n| 插入、删除 | $O(1)$ | $O(n)$ |\n| 随机访问   | $O(n)$ | $O(1)$ |\n\n> 关于数组的查询性能，还有一个有意思的点：\n>\n> 根据时间局部性和空间局部性原理：现在用到的数据在不久的将来很有可能也会用到，其周围的数据也有可能会用到。所以 CPU 与内存之间有一个叫做高速缓存的东西，这个高速缓存从内存中读取数据的单位是 **64 个字节（一个缓存行）**，因为数组申请的内存空间是连续的，所以 CPU 读取时可能就会直接在高速缓存中找到，链表的内存空间不是连续的，所以 CPU 遍历时可能就需要每次都从内存中去数据。\n>\n> 现如今，CPU 从高速缓存读取数据和高速缓存从内存中读取数据的时间比大概是 $1:10000$，但是实际开发中，我们并不需要太过于关注这些东西\n\n## 区别\n\n1. 数组申请的是连续内存，随机访问效率很高，但是插入、删除性能不好；链表插入、删除性能很好，但是随机访问性能不高\n2. 链表天然具有动态扩展的特性，但是频繁的插入、删除操作可能会带来很多的内存碎片；大部分语言提供的容器对数组进行了封装，使其也具有动态扩展的特性，但是这种特性一般是通过申请更大的数组空间，然后将原来的数据拷贝到新数组里面，但是数据的拷贝是很耗时的\n3. 在实际开发中的情况是很复杂的，所以不能仅仅通过时间复杂度来判断使用哪种数据结构\n\n<center>线性表——数组 and 链表实现[github]()</center>\n\n","tags":["数据结构与算法","线性表","数组","链表"]},{"title":"通用 LaTeX 数学公式语法手册","url":"/2021/10/77b91355.html","content":"\n[**MathJax**](https://www.mathjax.org/) 是一款运行于 Web 浏览器当中的开源 JavaScript 数学符号渲染引擎，通过它可以方便的在现代 Web 浏览器当中显示数学公式，目前已经能够解析 `LaTex`、`MathML` 等标记语言。**MathJax** 项目发源于 2009 年，目前由 NumFOCUS 基金会主持，并且得到了 MathJax 联盟的支持，该联盟是**美国数学协会**（AMS）和 **工业与应用数学协会**（SIAM）的共同合资企业。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"latex-logo\" src=\"https://uinika.gitee.io/Zen/LaTex/logo.png\" style=\"width: 100%;\">\n</div>\n\n<!-- more -->\n\n[**LaTeX**](https://www.latex-project.org/) 是一种高质量的排版格式，可以生成复杂的表格与数学公式，是当前电子与数学出版行业的事实标准。本文以 [**Pandoc**](https://www.pandoc.org/) 作为 LaTex 渲染引擎（一款用于标记语言文档转换的命令行工具），分门别类的总结了撰写数学公式所需要经常使用到的 LaTeX 语法，方便写作相关科技类文章时随手查阅。\n\n# 保留字符\n\nLaTeX 环境中具有特殊含义的保留字符，不能直接使用，必须通过指定的语法实现：\n\n| 序号 |   符号    |   LaTeX   | 序号 |     符号     |    LaTeX     |\n| :--: | :-------: | :-------: | :--: | :----------: | :----------: |\n|  1   |   $\\#$    |   `\\#`    |  6   |     $\\{$     |     `\\{`     |\n|  2   |   $\\%$    |   `\\%`    |  7   |     $\\}$     |     `\\}`     |\n|  3   | $^\\wedge$ | `^\\wedge` |  8   |    $\\sim$    |    `\\sim`    |\n|  4   |   $\\&$    |   `\\&`    |  9   | $\\backslash$ | `\\backslash` |\n|  5   |   $\\_$    |   `\\_`    |      |              |              |\n\n# 希腊字母\n\n| 序号 |  标准符号  |   LaTeX    | 首字母大写 |   LaTeX    |      使用 `var` 前缀       |          LaTeX           |    读音     |\n| :--: | :--------: | :--------: | :--------: | :--------: | :------------------------: | :----------------------: | :---------: |\n|  1   |  $\\alpha$  |  `\\alpha`  |            |            |                            |                          |   /ˈælfə/   |\n|  2   |  $\\beta$   |  `\\beta`   |            |            |                            |                          |  /ˈbeɪtə/   |\n|  3   |  $\\gamma$  |  `\\gamma`  |  $\\Gamma$  |  `\\Gamma`  |        $\\varGamma$         |       `\\varGamma`        |   /ˈɡæmə/   |\n|  4   |  $\\delta$  |  `\\delta`  |  $\\Delta$  |  `\\Delta`  |        $\\varDelta$         |       `\\varDelta`        |  /ˈdɛltə/   |\n|  5   | $\\epsilon$ | `\\epsilon` |            |            |       $\\varepsilon$        |      `\\varepsilon`       | /ˈɛpsɪlɒn/  |\n|  6   |  $\\zeta$   |  `\\zeta`   |            |            |                            |                          |  /ˈzeɪtə/   |\n|  7   |   $\\eta$   |   `\\eta`   |            |            |                            |                          |   /ˈeɪtə/   |\n|  8   |  $\\theta$  |  `\\theta`  |  $\\Theta$  |  `\\Theta`  | $\\vartheta$ 、 $\\varTheta$ | `\\vartheta`、`\\varTheta` |  /ˈθiːtə/   |\n|  9   |  $\\iota$   |  `\\iota`   |            |            |                            |                          |  /aɪˈoʊtə/  |\n|  10  |  $\\kappa$  |  `\\kappa`  |            |            |        $\\varkappa$         |       `\\varkappa`        |   /ˈkæpə/   |\n|  11  | $\\lambda$  | `\\lambda`  | $\\Lambda$  | `\\Lambda`  |        $\\varLambda$        |       `\\varLambda`       |  /ˈlæmdə/   |\n|  12  |   $\\mu$    |   `\\mu`    |            |            |                            |                          |   /mjuː/    |\n|  13  |   $\\nu$    |   `\\nu`    |            |            |                            |                          |   /njuː/    |\n|  14  |   $\\xi$    |   `\\xi`    |   $\\Xi$    |   `\\Xi`    |          $\\varXi$          |         `\\varXi`         | /zaɪ, ksaɪ/ |\n|  15  |    $o$     |    `o`     |    $O$     |    `O`     |                            |                          | /ˈɒmɪkrɒn/  |\n|  16  |   $\\pi$    |   `\\pi`    |   $\\Pi$    |   `\\Pi`    |    $\\varpi $、 $\\varPi$    |    `\\varpi`、`\\varPi`    |    /paɪ/    |\n|  17  |   $\\rho$   |   `\\rho`   |            |            |         $\\varrho$          |        `\\varrho`         |    /roʊ/    |\n|  18  |  $\\sigma$  |  `\\sigma`  |  $\\Sigma$  |  `\\Sigma`  | $\\varsigma $、 $\\varSigma$ | `\\varsigma`、`\\varSigma` |  /ˈsɪɡmə/   |\n|  19  |   $\\tau$   |   `\\tau`   |            |            |                            |                          | /taʊ, tɔː/  |\n|  20  | $\\upsilon$ | `\\upsilon` | $\\Upsilon$ | `\\Upsilon` |       $\\varUpsilon$        |      `\\varUpsilon`       | /ˈʌpsɪlɒn/  |\n|  21  |   $\\phi$   |   `\\phi`   |   $\\Phi$   |   `\\Phi`   |   $\\varphi $、 $\\varPhi$   |   `\\varphi`、`\\varPhi`   |    /faɪ/    |\n|  22  |   $\\chi$   |   `\\chi`   |            |            |                            |                          |    /kaɪ/    |\n|  23  |   $\\psi$   |   `\\psi`   |   $\\Psi$   |   `\\Psi`   |         $\\varPsi$          |        `\\varPsi`         |   /psaɪ/    |\n|  24  |  $\\omega$  |  `\\omega`  |  $\\Omega$  |  `\\Omega`  |        $\\varOmega$         |       `\\varOmega`        | /oʊˈmeɪɡə/  |\n|  25  | $\\digamma$ | `\\digamma` |            |            |                            |                          | /daɪ'gæmə/  |\n\n# 希伯来字母\n\n| 序号 |    符号    |  LaTeX   | 英文  | 序号 |    符号     |   LaTeX   |  英文  |\n| :--: | :--------: | :------: | :---: | :--: | :---------: | :-------: | :----: |\n|  1   |  $\\aleph$  | `\\aleph` | aleph |  3   |  $\\gimel$   | `\\gimel`  | gimel  |\n|  2   |  $\\beth$   | `\\beth`  | beth  |  4   |  $\\daleth$  | `\\daleth` | daleth |\n\n# 二元运算符\n\n| 序号 |        符号        |      LaTeX       | 序号 |         符号         |       LaTeX        |\n| :--: | :----------------: | :--------------: | :--: | :------------------: | :----------------: |\n|  1   |        $+$         |       `+`        |  20  |      $\\bullet$       |     `\\bullet`      |\n|  2   |        $−$         |       `-`        |  21  |       $\\oplus$       |      `\\oplus`      |\n|  3   |      $\\times$      |     `\\times`     |  22  |      $\\ominus$       |     `\\ominus`      |\n|  4   |       $\\div$       |      `\\div`      |  23  |       $\\odot$        |      `\\odot`       |\n|  5   |       $\\pm$        |      `\\pm`       |  24  |      $\\oslash$       |     `\\oslash`      |\n|  6   |       $\\mp$        |      `\\mp`       |  25  |      $\\otimes$       |     `\\otimes`      |\n|  7   |  $\\triangleleft$   | `\\triangleleft`  |  26  |      $\\bigcirc$      |     `\\bigcirc`     |\n|  8   |  $\\triangleright$  | `\\triangleright` |  27  |      $\\diamond$      |     `\\diamond`     |\n|  9   |      $\\cdot$       |     `\\cdot`      |  28  |       $\\uplus$       |      `\\uplus`      |\n|  10  |    $\\setminus$     |   `\\setminus`    |  29  |   $\\bigtriangleup$   |  `\\bigtriangleup`  |\n|  11  |      $\\star$       |     `\\star`      |  30  |  $\\bigtriangledown$  | `\\bigtriangledown` |\n|  12  |       $\\ast$       |      `\\ast`      |  31  |        $\\lhd$        |       `\\lhd`       |\n|  13  |       $\\cup$       |      `\\cup`      |  32  |        $\\rhd$        |       `\\rhd`       |\n|  14  |       $\\cap$       |      `\\cap`      |  33  |       $\\unlhd$       |      `\\unlhd`      |\n|  15  |      $\\sqcap$      |     `\\sqcup`     |  34  |       $\\unrhd$       |      `\\unrhd`      |\n|  16  |      $\\sqcap$      |     `\\sqcap`     |  35  |       $\\amalg$       |      `\\amalg`      |\n|  17  |       $\\vee$       |      `\\vee`      |  36  |        $\\wr$         |       `\\wr`        |\n|  18  |      $\\wedge$      |     `\\wedge`     |  37  |      $\\dagger$       |     `\\dagger`      |\n|  19  |      $\\circ$       |     `\\circ`      |  38  |      $\\ddagger$      |     `\\ddagger`     |\n\n# 二元关系符\n\n| 序号 |                    符号                    |                  LaTeX                   | 序号 |       符号       |     LaTeX      |\n| :--: | :----------------------------------------: | :--------------------------------------: | :--: | :--------------: | :------------: |\n|  1   |                    $=$                     |                   `=`                    |  49  |     $\\gneq$      |    `\\gneq`     |\n|  2   |                   $\\ne$                    |                  `\\ne`                   |  50  |     $\\gneqq$     |    `\\geqq`     |\n|  3   |                   $\\neq$                   |                  `\\neq`                  |  51  |     $\\ngeq$      |    `\\ngeq`     |\n|  4   |                  $\\equiv$                  |                 `\\equiv`                 |  52  |     $\\ngeqq$     |    `\\ngeqq`    |\n|  5   |                $\\not\\equiv$                |               `\\not\\equiv`               |  53  |     $\\gneqq$     |    `\\gneqq`    |\n|  6   |                  $\\doteq$                  |                 `\\doteq`                 |  54  |   $\\gvertneqq$   |  `\\gvertneqq`  |\n|  7   |                $\\doteqdot$                 |               `\\doteqdot`                |  55  |    $\\lessgtr$    |   `\\lessgtr`   |\n|  8   |  $\\overset{\\underset{\\mathrm{def}}{}}{=}$  | `\\overset{\\underset{\\mathrm{def}}{}}{=}` |  56  |   $\\lesseqgtr$   |  `\\lesseqgtr`  |\n|  9   |                    $:= $                   |                   `:=`                   |  57  |  $\\lesseqqgtr$   | `\\lesseqqgtr`  |\n|  10  |                   $\\sim$                   |                  `\\sim`                  |  58  |    $\\gtrless$    |   `\\gtrless`   |\n|  11  |                  $\\nsim$                   |                 `\\nsim`                  |  59  |   $\\gtreqless$   |  `\\gtreqless`  |\n|  12  |                 $\\backsim$                 |                `\\backsim`                |  60  |  $\\gtreqqless$   | `\\gtreqqless`  |\n|  13  |                $\\thicksim$                 |               `\\thicksim`                |  61  |   $\\leqslant$    |  `\\leqslant`   |\n|  14  |                  $\\simeq$                  |                 `\\simeq`                 |  62  |   $\\nleqslant$   |  `\\nleqslant`  |\n|  15  |                $\\backsimeq$                |               `\\backsimeq`               |  63  |  $\\eqslantless$  | `\\eqslantless` |\n|  16  |                  $\\eqsim$                  |                 `\\eqsim`                 |  64  |   $\\geqslant$    |  `\\geqslant`   |\n|  17  |                  $\\cong$                   |                 `\\cong`                  |  65  |   $\\ngeqslant$   |  `\\ngeqslant`  |\n|  18  |                  $\\ncong$                  |                 `\\ncong`                 |  66  |  $\\eqslantgtr$   | `\\eqslantgtr`  |\n|  19  |                 $\\approx$                  |                `\\approx`                 |  67  |    $\\lesssim$    |   `\\lesssim`   |\n|  20  |               $\\thickapprox$               |              `\\thickapprox`              |  68  |     $\\lnsim$     |    `\\lnsim`    |\n|  21  |                $\\approxeq$                 |               `\\approxeq`                |  69  |  $\\lessapprox$   | `\\lessapprox`  |\n|  22  |                  $\\asymp$                  |                 `\\asymp`                 |  70  |   $\\lnapprox$    |  `\\lnapprox`   |\n|  23  |                 $\\propto$                  |                `\\propto`                 |  71  |    $\\gtrsim$     |   `\\gtrsim`    |\n|  24  |                $\\varpropto$                |               `\\varpropto`               |  72  |     $\\gnsim$     |    `\\gnsim`    |\n|  25  |                    $<$                     |                   `<`                    |  73  |   $\\gtrapprox$   |  `\\gtrapprox`  |\n|  26  |                  $\\nless$                  |                 `\\nless`                 |  74  |   $\\gnapprox$    |  `\\gnapprox`   |\n|  27  |                   $\\ll$                    |                  `\\ll`                   |  75  |     $\\prec$      |    `\\prec`     |\n|  28  |                 $\\not\\ll$                  |                `\\not\\ll`                 |  76  |     $\\nprec$     |    `\\nprec`    |\n|  29  |                   $\\lll$                   |                  `\\lll`                  |  77  |    $\\preceq$     |   `\\preceq`    |\n|  30  |                 $\\not\\lll$                 |                `\\not\\lll`                |  78  |    $\\npreceq$    |   `\\npreceq`   |\n|  31  |                 $\\lessdot$                 |                `\\lessdot`                |  79  |   $\\precneqq$    |  `\\precneqq`   |\n|  32  |                    $>$                     |                   `>`                    |  80  |     $\\succ$      |    `\\succ`     |\n|  33  |                  $\\ngtr$                   |                 `\\ngtr`                  |  81  |     $\\nsucc$     |    `\\nsucc`    |\n|  34  |                   $\\gg$                    |                  `\\gg`                   |  82  |    $\\succeq$     |   `\\succeq`    |\n|  35  |                 $\\not\\gg$                  |                `\\not\\gg`                 |  83  |    $\\nsucceq$    |   `\\nsucceq`   |\n|  36  |                   $\\ggg $                  |                  `\\ggg`                  |  84  |   $\\succneqq$    |  `\\succneqq`   |\n|  37  |                 $\\not\\ggg $                |                `\\not\\ggg`                |  85  |  $\\preccurlyeq$  | `\\preccurlyeq` |\n|  38  |                 $\\gtrdot$                  |                `\\gtrdot`                 |  86  |  $\\curlyeqprec$  | `\\curlyeqprec` |\n|  39  |                   $\\le$                    |                  `\\le`                   |  87  |  $\\succcurlyeq$  | `\\succcurlyeq` |\n|  40  |                   $\\leq$                   |                  `\\leq`                  |  88  |  $\\curlyeqsucc$  | `\\curlyeqsucc` |\n|  41  |                  $\\lneq$                   |                 `\\lneq`                  |  89  |    $\\precsim$    |   `\\precsim`   |\n|  42  |                  $\\leqq$                   |                 `\\leqq`                  |  90  |   $\\precnsim$    |  `\\precnsim`   |\n|  43  |                  $\\nleq$                   |                 `\\nleq`                  |  91  |  $\\precapprox$   | `\\precapprox`  |\n|  44  |                  $\\nleqq$                  |                 `\\nleqq`                 |  92  |  $\\precnapprox$  | `\\precnapprox` |\n|  45  |                  $\\lneqq$                  |                 `\\lneqq`                 |  93  |    $\\succsim$    |   `\\succsim`   |\n|  46  |                $\\lvertneqq$                |               `\\lvertneqq`               |  94  |   $\\succnsim$    |  `\\succnsim`   |\n|  47  |                   $\\ge$                    |                  `\\ge`                   |  95  |  $\\succapprox$   | `\\succapprox`  |\n|  48  |                   $\\geq$                   |                  `\\geq`                  |  96  |  $\\succnapprox$  | `\\succnapprox` |\n\n# 几何符号\n\n| 序号 |         符号          |        LaTeX        | 序号 |          符号           |         LaTeX         |\n| :--: | :-------------------: | :-----------------: | :--: | :---------------------: | :-------------------: |\n|  1   |      $\\parallel$      |     `\\parallel`     |  14  |       $\\lozenge$        |      `\\lozenge`       |\n|  2   |     $\\nparallel$      |    `\\nparallel`     |  15  |     $\\blacklozenge$     |    `\\blacklozenge`    |\n|  3   |   $\\shortparallel$    |  `\\shortparallel`   |  16  |       $\\bigstar$        |      `\\bigstar`       |\n|  4   |   $\\nshortparallel$   |  `\\nshortparallel`  |  17  |       $\\bigcirc$        |      `\\bigcirc`       |\n|  5   |        $\\perp$        |       `\\perp`       |  18  |       $\\triangle$       |      `\\triangle`      |\n|  6   |       $\\angle$        |      `\\angle`       |  19  |    $\\bigtriangleup$     |   `\\bigtriangleup`    |\n|  7   |   $\\sphericalangle$   |  `\\sphericalangle`  |  20  |   $\\bigtriangledown$    |  `\\bigtriangledown`   |\n|  8   |   $\\measuredangle$    |  `\\measuredangle`   |  21  |     $\\vartriangle$      |    `\\vartriangle`     |\n|  9   |      $45^\\circ$       |     `45^\\circ`      |  22  |     $\\triangledown$     |    `\\triangledown`    |\n|  10  |        $\\Box$         |       `\\Box`        |  23  |    $\\blacktriangle$     |   `\\blacktriangle`    |\n|  11  |    $\\blacksquare$     |   `\\blacksquare`    |  24  |  $\\blacktriangledown$   | `\\blacktriangledown`  |\n|  12  |      $\\diamond$       |     `\\diamond`      |  25  |  $\\blacktriangleleft$   | `\\blacktriangleleft`  |\n|  13  |  $\\Diamond \\lozenge$  | `\\Diamond \\lozenge` |  26  |  $\\blacktriangleright$  | `\\blacktriangleright` |\n\n# 逻辑符号\n\n| 序号 |        符号        |      LaTeX       | 序号 |           符号           |         LaTeX          |\n| :--: | :----------------: | :--------------: | :--: | :----------------------: | :--------------------: |\n|  1   |     $\\forall$      |    `\\forall`     |  20  |          $\\neg$          |         `\\neg`         |\n|  2   |     $\\exists$      |    `\\exists`     |  21  |  $\\not\\operatorname{R}$  | `\\not\\operatorname{R}` |\n|  3   |     $\\nexists$     |    `\\nexists`    |  22  |          $\\bot$          |         `\\bot`         |\n|  4   |    $\\therefore$    |   `\\therefore`   |  23  |          $\\top$          |         `\\top`         |\n|  5   |     $\\because$     |    `\\because`    |  24  |         $\\vdash$         |        `\\vdash`        |\n|  6   |       $\\And$       |      `\\And`      |  25  |         $\\dashv$         |        `\\dashv`        |\n|  7   |       $\\lor$       |      `\\lor`      |  26  |         $\\vDash$         |        `\\vDash`        |\n|  8   |       $\\vee$       |      `\\vee`      |  27  |         $\\Vdash$         |        `\\Vdash`        |\n|  9   |    $\\curlyvee$     |   `\\curlyvee`    |  28  |        $\\models$         |       `\\models`        |\n|  10  |     $\\bigvee$      |    `\\bigvee`     |  29  |        $\\Vvdash$         |       `\\Vvdash`        |\n|  11  |      $\\land$       |     `\\land`      |  30  |        $\\nvdash$         |       `\\nvdash`        |\n|  12  |      $\\wedge$      |     `\\wedge`     |  31  |        $\\nVdash$         |       `\\nVdash`        |\n|  13  |   $\\curlywedge$    |  `\\curlywedge`   |  32  |        $\\nvDash$         |       `\\nvDash`        |\n|  14  |    $\\bigwedge$     |   `\\bigwedge`    |  33  |        $\\nVDash$         |       `\\nVDash`        |\n|  15  |     $\\bar{q}$      |    `\\bar{q}`     |  34  |       $\\ulcorner$        |      `\\ulcorner`       |\n|  16  |    $\\bar{abc}$     |   `\\bar{abc}`    |  35  |       $\\urcorner$        |      `\\urcorner`       |\n|  17  |   $\\overline{q}$   |  `\\overline{q}`  |  36  |       $\\llcorner$        |      `\\llcorner`       |\n|  18  |  $\\overline{abc}$  | `\\overline{abc}` |  37  |       $\\lrcorner$        |      `\\lrcorner`       |\n|  19  |      $\\lnot$       |     `\\lnot`      |      |                          |                        |\n\n# 集合符号\n\n| 序号 |        符号        |      LaTeX       | 序号 |        符号        |      LaTeX       |\n| :--: | :----------------: | :--------------: | :--: | :----------------: | :--------------: |\n|  1   |      $\\{ \\}$       |     `\\{ \\}`      |  23  |    $\\sqsubset$     |   `\\sqsubset`    |\n|  2   |    $\\emptyset$     |   `\\emptyset`    |  24  |     $\\supset$      |    `\\supset`     |\n|  3   |   $\\varnothing$    |  `\\varnothing`   |  25  |     $\\Supset$      |    `\\Supset`     |\n|  4   |       $\\in$        |      `\\in`       |  26  |    $\\sqsupset$     |   `\\sqsupset`    |\n|  5   |      $\\notin$      |     `\\notin`     |  27  |    $\\subseteq$     |   `\\subseteq`    |\n|  6   |       $\\ni$        |      `\\ni`       |  28  |    $\\nsubseteq$    |   `\\nsubseteq`   |\n|  7   |       $\\cap$       |      `\\cap`      |  29  |    $\\subsetneq$    |   `\\subsetneq`   |\n|  8   |       $\\Cap$       |      `\\Cap`      |  30  |  $\\varsubsetneq$   | `\\varsubsetneq`  |\n|  9   |      $\\sqcap$      |     `\\sqcap`     |  31  |   $\\sqsubseteq$    |  `\\sqsubseteq`   |\n|  10  |     $\\bigcap$      |    `\\bigcap`     |  32  |    $\\supseteq$     |   `\\supseteq`    |\n|  11  |       $\\cup$       |      `\\cup`      |  33  |    $\\nsupseteq$    |   `\\nsupseteq`   |\n|  12  |       $\\Cup$       |      `\\Cup`      |  34  |    $\\supsetneq$    |   `\\supsetneq`   |\n|  13  |      $\\sqcup$      |     `\\sqcup`     |  35  |  $\\varsupsetneq$   | `\\varsupsetneq`  |\n|  14  |     $\\bigcup$      |    `\\bigcup`     |  36  |   $\\sqsupseteq$    |  `\\sqsupseteq`   |\n|  15  |    $\\bigsqcup$     |   `\\bigsqcup`    |  37  |    $\\subseteqq$    |   `\\subseteqq`   |\n|  16  |      $\\uplus$      |     `\\uplus`     |  38  |   $\\nsubseteqq$    |  `\\nsubseteqq`   |\n|  17  |    $\\biguplus$     |   `\\biguplus`    |  39  |   $\\subsetneqq$    |  `\\subsetneqq`   |\n|  18  |    $\\setminus$     |   `\\setminus`    |  40  |  $\\varsubsetneqq$  | `\\varsubsetneqq` |\n|  19  |  $\\smallsetminus$  | `\\smallsetminus` |  41  |    $\\supseteqq$    |   `\\supseteqq`   |\n|  20  |      $\\times$      |     `\\times`     |  42  |   $\\nsupseteqq$    |  `\\nsupseteqq`   |\n|  21  |     $\\subset$      |    `\\subset`     |  43  |   $\\supsetneqq$    |  `\\supsetneqq`   |\n|  22  |     $\\Subset$      |    `\\Subset`     |  44  |  $\\varsupsetneqq$  | `\\varsupsetneqq` |\n\n# 箭头符号\n\n| 序号 |          符号           |         LaTeX         | 序号 |           符号           |         LaTeX          |\n| :--: | :---------------------: | :-------------------: | :--: | :----------------------: | :--------------------: |\n|  1   |     $\\Rrightarrow$      |    `\\Rrightarrow`     |  36  |      $\\longmapsto$       |     `\\longmapsto`      |\n|  2   |      $\\Lleftarrow$      |     `\\Lleftarrow`     |  37  |    $\\rightharpoonup$     |   `\\rightharpoonup`    |\n|  3   |      $\\Rightarrow$      |     `\\Rightarrow`     |  38  |   $\\rightharpoondown$    |  `\\rightharpoondown`   |\n|  4   |     $\\nRightarrow$      |    `\\nRightarrow`     |  39  |     $\\leftharpoonup$     |    `\\leftharpoonup`    |\n|  5   |    $\\Longrightarrow$    |   `\\Longrightarrow`   |  40  |    $\\leftharpoondown$    |   `\\leftharpoondown`   |\n|  6   |       $\\implies$        |      `\\implies`       |  41  |     $\\upharpoonleft$     |    `\\upharpoonleft`    |\n|  7   |      $\\Leftarrow$       |     `\\Leftarrow`      |  42  |    $\\upharpoonright$     |   `\\upharpoonright`    |\n|  8   |      $\\nLeftarrow$      |     `\\nLeftarrow`     |  43  |    $\\downharpoonleft$    |   `\\downharpoonleft`   |\n|  9   |    $\\Longleftarrow$     |   `\\Longleftarrow`    |  44  |   $\\downharpoonright$    |  `\\downharpoonright`   |\n|  10  |    $\\Leftrightarrow$    |   `\\Leftrightarrow`   |  45  |   $\\rightleftharpoons$   |  `\\rightleftharpoons`  |\n|  11  |   $\\nLeftrightarrow$    |  `\\nLeftrightarrow`   |  46  |   $\\leftrightharpoons$   |  `\\leftrightharpoons`  |\n|  12  |  $\\Longleftrightarrow$  | `\\Longleftrightarrow` |  47  |    $\\curvearrowleft$     |   `\\curvearrowleft`    |\n|  13  |         $\\iff$          |        `\\iff`         |  48  |    $\\circlearrowleft$    |   `\\circlearrowleft`   |\n|  14  |       $\\Uparrow$        |      `\\Uparrow`       |  49  |          $\\Lsh$          |         `\\Lsh`         |\n|  15  |      $\\Downarrow$       |     `\\Downarrow`      |  50  |      $\\upuparrows$       |     `\\upuparrows`      |\n|  16  |     $\\Updownarrow$      |    `\\Updownarrow`     |  51  |   $\\rightrightarrows$    |  `\\rightrightarrows`   |\n|  17  |      $\\rightarrow$      |     `\\rightarrow`     |  52  |    $\\rightleftarrows$    |   `\\rightleftarrows`   |\n|  18  |          $\\to$          |         `\\to`         |  53  |    $\\rightarrowtail$     |   `\\rightarrowtail`    |\n|  19  |     $\\nrightarrow$      |    `\\nrightarrow`     |  54  |    $\\looparrowright$     |   `\\looparrowright`    |\n|  20  |    $\\longrightarrow$    |   `\\longrightarrow`   |  55  |    $\\curvearrowright$    |   `\\curvearrowright`   |\n|  21  |      $\\leftarrow$       |     `\\leftarrow`      |  56  |   $\\circlearrowright$    |  `\\circlearrowright`   |\n|  22  |         $\\gets$         |        `\\gets`        |  57  |          $\\Rsh$          |         `\\Rsh`         |\n|  23  |      $\\nleftarrow$      |     `\\nleftarrow`     |  58  |    $\\downdownarrows$     |   `\\downdownarrows`    |\n|  24  |    $\\longleftarrow $    |   `\\longleftarrow`    |  59  |    $\\leftleftarrows$     |   `\\leftleftarrows`    |\n|  25  |    $\\leftrightarrow$    |   `\\leftrightarrow`   |  60  |    $\\leftrightarrows$    |   `\\leftrightarrows`   |\n|  26  |   $\\nleftrightarrow$    |  `\\nleftrightarrow`   |  61  |     $\\leftarrowtail$     |    `\\leftarrowtail`    |\n|  27  |  $\\longleftrightarrow$  | `\\longleftrightarrow` |  62  |     $\\looparrowleft$     |    `\\looparrowleft`    |\n|  28  |       $\\uparrow$        |      `\\uparrow`       |  63  |    $\\hookrightarrow$     |   `\\hookrightarrow`    |\n|  29  |      $\\downarrow$       |     `\\downarrow`      |  64  |     $\\hookleftarrow$     |    `\\hookleftarrow`    |\n|  30  |     $\\updownarrow$      |    `\\updownarrow`     |  65  |       $\\multimap$        |      `\\multimap`       |\n|  31  |       $\\nearrow$        |      `\\nearrow`       |  66  |  $\\leftrightsquigarrow$  | `\\leftrightsquigarrow` |\n|  32  |       $\\swarrow$        |      `\\swarrow`       |  67  |    $\\rightsquigarrow$    |   `\\rightsquigarrow`   |\n|  33  |       $\\nwarrow$        |      `\\nwarrow`       |  68  |   $\\twoheadrightarrow$   |  `\\twoheadrightarrow`  |\n|  34  |       $\\searrow$        |      `\\searrow`       |  69  |   $\\twoheadleftarrow$    |  `\\twoheadleftarrow`   |\n|  35  |        $\\mapsto$        |       `\\mapsto`       |      |                          |                        |\n\n# 特殊符号\n\n| 序号 |        符号        |      LaTeX       | 序号 |         符号          |        LaTeX        |\n| :--: | :----------------: | :--------------: | :--: | :-------------------: | :-----------------: |\n|  1   |      $\\infty$      |     `\\infty`     |  33  |        $\\flat$        |       `\\flat`       |\n|  2   |      $\\aleph$      |     `\\aleph`     |  34  |      $\\natural$       |     `\\natural`      |\n|  3   |   $\\complement$    |  `\\complement`   |  35  |       $\\sharp$        |      `\\sharp`       |\n|  4   |   $\\backepsilon$   |  `\\backepsilon`  |  36  |       $\\diagup$       |      `\\diagup`      |\n|  5   |       $\\eth$       |      `\\eth`      |  37  |      $\\diagdown$      |     `\\diagdown`     |\n|  6   |      $\\Finv$       |     `\\Finv`      |  38  |     $\\centerdot$      |    `\\centerdot`     |\n|  7   |      $\\hbar$       |     `\\hbar`      |  39  |       $\\ltimes$       |      `\\ltimes`      |\n|  8   |       $\\Im$        |      `\\Im`       |  40  |       $\\rtimes$       |      `\\rtimes`      |\n|  9   |      $\\imath$      |     `\\imath`     |  41  |   $\\leftthreetimes$   |  `\\leftthreetimes`  |\n|  10  |      $\\jmath$      |     `\\jmath`     |  42  |  $\\rightthreetimes$   | `\\rightthreetimes`  |\n|  11  |      $\\Bbbk$       |     `\\Bbbk`      |  43  |       $\\eqcirc$       |      `\\eqcirc`      |\n|  12  |       $\\ell$       |      `\\ell`      |  44  |       $\\circeq$       |      `\\circeq`      |\n|  13  |       $\\mho$       |      `\\mho`      |  45  |     $\\triangleq$      |    `\\triangleq`     |\n|  14  |       $\\wp$        |      `\\wp`       |  46  |       $\\bumpeq$       |      `\\bumpeq`      |\n|  15  |       $\\Re$        |      `\\Re`       |  47  |       $\\Bumpeq$       |      `\\Bumpeq`      |\n|  16  |    $\\circledS$     |   `\\circledS`    |  48  |      $\\doteqdot$      |     `\\doteqdot`     |\n|  17  |      $\\amalg$      |     `\\amalg`     |  49  |    $\\risingdotseq$    |   `\\risingdotseq`   |\n|  18  |        $\\%$        |       `\\%`       |  50  |   $\\fallingdotseq$    |  `\\fallingdotseq`   |\n|  19  |     $\\dagger$      |    `\\dagger`     |  51  |      $\\intercal$      |     `\\intercal`     |\n|  20  |     $\\ddagger$     |    `\\ddagger`    |  52  |      $\\barwedge$      |     `\\barwedge`     |\n|  21  |      $\\ldots$      |     `\\ldots`     |  53  |       $\\veebar$       |      `\\veebar`      |\n|  22  |      $\\cdots$      |     `\\cdots`     |  54  |   $\\doublebarwedge$   |  `\\doublebarwedge`  |\n|  23  |      $\\smile$      |     `\\smile`     |  55  |      $\\between$       |     `\\between`      |\n|  24  |      $\\frown$      |     `\\frown`     |  56  |     $\\pitchfork$      |    `\\pitchfork`     |\n|  25  |       $\\wr$        |      `\\wr`       |  57  |  $\\vartriangleleft$   | `\\vartriangleleft`  |\n|  26  |  $\\triangleleft$   | `\\triangleleft`  |  58  |   $\\ntriangleleft$    |  `\\ntriangleleft`   |\n|  27  |  $\\triangleright$  | `\\triangleright` |  59  |  $\\vartriangleright$  | `\\vartriangleright` |\n|  28  |   $\\diamondsuit$   |  `\\diamondsuit`  |  60  |   $\\ntriangleright$   |  `\\ntriangleright`  |\n|  29  |    $\\heartsuit$    |   `\\heartsuit`   |  61  |   $\\trianglelefteq$   |  `\\trianglelefteq`  |\n|  30  |    $\\clubsuit$     |   `\\clubsuit`    |  62  |  $\\ntrianglelefteq$   | `\\ntrianglelefteq`  |\n|  31  |    $\\spadesuit$    |   `\\spadesuit`   |  63  |  $\\trianglerighteq$   | `\\trianglerighteq`  |\n|  32  |      $\\Game$       |     `\\Game`      |  64  |  $\\ntrianglerighteq$  | `\\ntrianglerighteq` |\n\n# 分数\n\n| 类型                    | 符号                                                         | LaTeX                                                        |\n| :---------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| **分数**                |  $\\frac{2}{4}x=0.5x , {2 \\over 4}x=0.5x$                     | `\\frac{2}{4}x=0.5x or {2 \\over 4}x=0.5x`                     |\n| **小型分数**            | 24x=0.5x                                                     | `\\tfrac{2}{4}x = 0.5x`                                       |\n| **大型分数** （不嵌套） |  $\\dfrac{2}{4} = 0.5 , \\qquad \\dfrac{2}{c + \\dfrac{2}{d + \\dfrac{2}{4}}} = a$  | `\\dfrac{2}{4} = 0.5 \\qquad \\dfrac{2}{c + \\dfrac{2}{d + \\dfrac{2}{4}}} = a` |\n| **大型分数** （嵌套）   |  $\\cfrac{2}{c + \\cfrac{2}{d + \\cfrac{2}{4}}} = a$            | `\\cfrac{2}{c + \\cfrac{2}{d + \\cfrac{2}{4}}} = a`             |\n\n# 数值函数\n\n| 符号                                                         | LaTeX                                                        |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n|  $\\exp_a b = a^b, \\exp b = e^b, 10^m$                        | `\\exp_a b = a^b, \\exp b = e^b, 10^m`                         |\n|  $\\ln c, \\lg d = \\log e, \\log_{10} f$                        | `\\ln c, \\lg d = \\log e, \\log_{10} f`                         |\n|  $\\sin a, \\cos b, \\tan c, \\cot d, \\sec e, \\csc f$            | `\\sin a, \\cos b, \\tan c, \\cot d, \\sec e, \\csc f`             |\n|  $\\arcsin a, \\arccos b, \\arctan c$                           | `\\arcsin a, \\arccos b, \\arctan c`                            |\n|  $\\operatorname{arccot} d, \\operatorname{arcsec} e, \\operatorname{arccsc} f$  | `\\operatorname{arccot} d, \\operatorname{arcsec} e, \\operatorname{arccsc} f` |\n|  $\\sinh a, \\cosh b, \\tanh c, \\coth d$                        | `\\sinh a, \\cosh b, \\tanh c, \\coth d`                         |\n|  $\\operatorname{sh}k, \\operatorname{ch}l, \\operatorname{th}m, \\operatorname{coth}n$  | `\\operatorname{sh}k, \\operatorname{ch}l, \\operatorname{th}m, \\operatorname{coth}n` |\n|  $\\operatorname{argsh}o, \\operatorname{argch}p, \\operatorname{argth}q$  | `\\operatorname{argsh}o, \\operatorname{argch}p, \\operatorname{argth}q` |\n|  $\\operatorname{sgn}r, \\left\\vert s \\right\\vert$             | `\\operatorname{sgn}r, \\left\\vert s \\right\\vert`              |\n|  $\\min(x,y), \\max(x,y)$                                      | `\\min(x,y), \\max(x,y)`                                       |\n\n如果需要使用特殊的函数符号，那么可以采用 `\\operatorname{}` 命令进行自定义：\n\n| 符号                         | LaTeX                      |\n| :--------------------------- | :------------------------- |\n|  $\\operatorname{mydefine}x$  | `\\operatorname{mydefine}x` |\n\n# 根式\n\n| 符号           | LaTeX        | 符号                            | LaTeX                         |\n| :------------- | :----------- | :------------------------------ | :---------------------------- |\n|  $\\surd$       | `\\surd`      |  $\\sqrt[n]{\\pi}$                | `\\sqrt[n]{\\pi}`               |\n|  $\\sqrt{\\pi}$  | `\\sqrt{\\pi}` |  $\\sqrt[3]{\\frac{x^3+y^3}{2}}$  | `\\sqrt[3]{\\frac{x^3+y^3}{2}}` |\n\n# 微分与导数\n\n| 符号                                                         | LaTeX                                                        |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n|  $dt, \\mathrm{d}t, \\partial t, \\nabla\\psi$                   | `dt, \\mathrm{d}t, \\partial t, \\nabla\\psi`                    |\n|  $dy/dx, \\mathrm{d}y/\\mathrm{d}x, \\frac{dy}{dx}, \\frac{\\mathrm{d}y}{\\mathrm{d}x}, \\frac{\\partial^2}{\\partial x_1\\partial x_2}y$  | `dy/dx, \\mathrm{d}y/\\mathrm{d}x, \\frac{dy}{dx}, \\frac{\\mathrm{d}y}{\\mathrm{d}x}, \\frac{\\partial^2}{\\partial x_1\\partial x_2}y` |\n|  $\\prime, \\backprime, f^\\prime, f', f'', f^{(3)}, \\dot y, \\ddot y$  | `\\prime, \\backprime, f^\\prime, f', f'', f^{(3)}, \\dot y, \\ddot y` |\n\n# 模运算\n\n| 符号                                     | LaTeX                                  |\n| :--------------------------------------- | :------------------------------------- |\n|  $s_k \\equiv 0 \\pmod{m}$                 | `s_k \\equiv 0 \\pmod{m}`                |\n|  $a \\bmod b$                             | `a \\bmod b`                            |\n|  $\\gcd(m, n), \\operatorname{lcm}(m, n)$  | `\\gcd(m, n), \\operatorname{lcm}(m, n)` |\n|  $\\mid, \\nmid, \\shortmid, \\nshortmid$    | `\\mid, \\nmid, \\shortmid, \\nshortmid`   |\n\n# 极限\n\n| 符号                                  | LaTeX                               |\n| :------------------------------------ | :---------------------------------- |\n|  $\\lim_{n \\to \\infty}x_n$             | `\\lim_{n \\to \\infty}x_n`            |\n|  $\\textstyle \\lim_{n \\to \\infty}x_n$  | `\\textstyle \\lim_{n \\to \\infty}x_n` |\n\n# 范围与预测\n\n| 符号                                       | LaTeX                                    |\n| :----------------------------------------- | :--------------------------------------- |\n|  $\\min x, \\max y, \\inf s, \\sup t$          | `\\min x, \\max y, \\inf s, \\sup t`         |\n|  $\\lim u, \\liminf v, \\limsup w$            | `\\lim u, \\liminf v, \\limsup w`           |\n|  $\\dim p, \\deg q, \\det m, \\ker\\phi$        | `\\dim p, \\deg q, \\det m, \\ker\\phi`       |\n|  $\\Pr j, \\hom l, \\lVert z \\rVert, \\arg z$  | `\\Pr j, \\hom l, \\lVert z \\rVert, \\arg z` |\n\n# 积分\n\n| 符号                                          | LaTeX                                       |\n| :-------------------------------------------- | :------------------------------------------ |\n|  $\\int\\limits_{1}^{3}\\frac{e^3/x}{x^2}\\, dx$  | `\\int\\limits_{1}^{3}\\frac{e^3/x}{x^2}\\, dx` |\n|  $\\int_{1}^{3}\\frac{e^3/x}{x^2}\\, dx$         | `\\int_{1}^{3}\\frac{e^3/x}{x^2}\\, dx`        |\n|  $\\textstyle \\int\\limits_{-N}^{N} e^x dx$     | `\\textstyle \\int\\limits_{-N}^{N} e^x dx`    |\n|  $\\textstyle \\int_{-N}^{N} e^x dx$            | `\\textstyle \\int_{-N}^{N} e^x dx`           |\n|  $\\iint\\limits_D dx\\,dy$                      | `\\iint\\limits_D dx\\,dy`                     |\n|  $\\iiint\\limits_E dx\\,dy\\,dz$                 | `\\iiint\\limits_E dx\\,dy\\,dz`                |\n|  $\\iiiint\\limits_F dx\\,dy\\,dz\\,dt$            | `\\iiiint\\limits_F dx\\,dy\\,dz\\,dt`           |\n|  $\\int_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy$     | `\\int_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy`    |\n|  $\\oint_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy$    | `\\oint_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy`   |\n\n> **注意**：积分符号采用 `\\int\\_{}^{}` 命令调用，双重积分符号采用 `\\iint\\_{}^{}`，以此类推，最高可以支持四重积分。\n\n曲线积分可以使用 `\\oint` 命令调用，但是 MathJax 并不支持该语法，因此在开启了 Unicode 扩展的前提下，可以改为采用 `\\unicode{}` 命令调用：\n\n| 符号                                                         | LaTeX                                                        | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n|  $\\unicode{8751} \\unicode{x222F}_C$                          | `\\unicode{8751} \\unicode{x222F}_C`                           | 曲面积分符号的 Unicode 码十进制为 `8751`,十六进制为 `x222F`； |\n|  $\\unicode{8752} \\unicode{x2230}_C$                          | `\\unicode{8752} \\unicode{x2230}_C`                           | 三维曲面积分符号的 Unicode 码十进制为 `8752`,十六进制为 `x2230`； |\n|  $\\unicode{8753} \\unicode{x2231}_c \\unicode{8754} \\unicode{x2232}_c \\unicode{8755} \\unicode{x2233}_c$  | `\\unicode{8753} \\unicode{x2231}_c \\unicode{8754} \\unicode{x2232}_c \\unicode{8755} \\unicode{x2233}_c` | 其它积分符号；                                               |\n\n# 大型运算符\n\n| 分类       |         符号          | LaTeX               |               符号               | LaTeX                          |\n| :--------- | :-------------------: | :------------------ | :------------------------------: | :----------------------------- |\n| **求和**   |    $\\sum_{a}^{b}$     | `\\sum_{a}^{b}`      |    $\\textstyle \\sum_{a}^{b}$     | `\\textstyle \\sum_{a}^{b}`      |\n| **连乘积** |    $\\prod_{a}^{b}$    | `\\prod_{a}^{b}`     |    $\\textstyle \\prod_{a}^{b}$    | `\\textstyle \\prod_{a}^{b}`     |\n| **余积**   |   $\\coprod_{a}^{b}$   | `\\coprod_{a}^{b}`   |   $\\textstyle \\coprod_{a}^{b}$   | `\\textstyle \\coprod_{a}^{b}`   |\n| **并集**   |   $\\bigcup_{a}^{b}$   | `\\bigcup_{a}^{b}`   |   $\\textstyle \\bigcup_{a}^{b}$   | `\\textstyle \\bigcup_{a}^{b}`   |\n| **交集**   |   $\\bigcap_{a}^{b}$   | `\\bigcap_{a}^{b}`   |   $\\textstyle \\bigcap_{a}^{b}$   | `\\textstyle \\bigcap_{a}^{b}`   |\n| **析取**   |   $\\bigvee_{a}^{b}$   | `\\bigvee_{a}^{b}`   |   $\\textstyle \\bigvee_{a}^{b}$   | `\\textstyle \\bigvee_{a}^{b}`   |\n| **合取**   |  $\\bigwedge_{a}^{b}$  | `\\bigwedge_{a}^{b}` |  $\\textstyle \\bigwedge_{a}^{b}$  | `\\textstyle \\bigwedge_{a}^{b}` |\n\n# 上下标\n\n|         类型         |                             符号                             | 代码                                                         |\n| :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------- |\n|         上标         |                      $a^2 $、 $a^{x+3}$                      | `a^2` `a^{x+3}`                                              |\n|         下标         |                            $a_2$                             | `a_2`                                                        |\n|         组合         |             $10^{30} a^{2+2} $、 $a{i,j} b{f'}$              | `10^{30} a^{2+2}` `a{i,j} b{f'}`                             |\n|      上下标混合      |                     $x_2^3 $、 ${x_2}^3$                     | `x_2^3` `{x_2}^3`                                            |\n|      上标的上标      |                        $10^{10^{8}}$                         | `10^{10^{8}}`                                                |\n|       混合标识       |       $\\sideset{1^2}{3^4}X_a^b $、 ${}_1^2!\\Omega_3^4$       | `\\sideset{1^2}{3^4}X_a^b` `{}_1^2!\\Omega_3^4`                |\n|       顶标底标       |  $\\overset{\\alpha}{\\omega} $、 $\\underset{\\alpha}{\\omega}$、$\\overset{\\alpha}{\\underset{\\gamma}{\\omega}}$、$\\stackrel{\\alpha}{\\omega}$  | `\\overset{\\alpha}{\\omega}` `\\underset{\\alpha}{\\omega}` `\\overset{\\alpha}{\\underset{\\gamma}{\\omega}}` `\\stackrel{\\alpha}{\\omega}` |\n|         导数         |      $x', y'', f', f'' $、 $x^\\prime, y^{\\prime\\prime}$      | `x', y'', f', f''` `x^\\prime, y^{\\prime\\prime}`              |\n|        导数点        |                     $\\dot{x}, \\ddot{x}$                      | `\\dot{x}, \\ddot{x}`                                          |\n|    上下划线与向量    |  $\\hat a \\ \\bar b \\ \\vec c$、$\\overrightarrow{a b} \\ \\overleftarrow{c d} \\ \\widehat{d e f}$、$\\overline{g h i} \\ \\underline{j k l}$  | `\\hat a \\ \\bar b \\ \\vec c` `\\overrightarrow{a b} \\ \\overleftarrow{c d} \\ \\widehat{d e f}` `\\overline{g h i} \\ \\underline{j k l}` |\n|         弧度         |                   $\\overset{\\frown} {AB}$                    | `\\overset{\\frown} {AB}`                                      |\n|         箭头         |    $A \\xleftarrow{n+\\mu-1} B \\xrightarrow[T]{n\\pm i-1} C$    | `A \\xleftarrow{n+\\mu-1} B \\xrightarrow[T]{n\\pm i-1} C`       |\n|        大括号        |            $\\overbrace{ 1+2+\\cdots+100 }^{5050}$             | `\\overbrace{ 1+2+\\cdots+100 }^{5050}`                        |\n|      底部大括号      |              $\\underbrace{ a+b+\\cdots+z }_{26}$              | `\\underbrace{ a+b+\\cdots+z }_{26}`                           |\n|       求和运算       |                      $\\sum_{k=1}^N k^2$                      | `\\sum_{k=1}^N k^2`                                           |\n| 文本模式下的求和运算 |                $\\textstyle \\sum_{k=1}^N k^2$                 | `\\textstyle \\sum_{k=1}^N k^2`                                |\n|   分式中的求和运算   |                 $\\frac{\\sum_{k=1}^N k^2}{a}$                 | `\\frac{\\sum_{k=1}^N k^2}{a}`                                 |\n|   分式中的求和运算   |          $\\frac{\\displaystyle \\sum_{k=1}^N k^2}{a}$          | `\\frac{\\displaystyle \\sum_{k=1}^N k^2}{a}`                   |\n|   分式中的求和运算   |            $\\frac{\\sum\\limits^{^N}_{k=1} k^2}{a}$            | `\\frac{\\sum\\limits^{^N}_{k=1} k^2}{a}`                       |\n|       乘积运算       |                     $\\prod_{i=1}^N x_i$                      | `\\prod_{i=1}^N x_i`                                          |\n|       乘积运算       |                $\\textstyle \\prod_{i=1}^N x_i$                | `\\textstyle \\prod_{i=1}^N x_i`                               |\n|       副乘运算       |                    $\\coprod_{i=1}^N x_i$                     | `\\coprod_{i=1}^N x_i`                                        |\n|       副乘运算       |               $\\textstyle \\coprod_{i=1}^N x_i$               | `\\textstyle \\coprod_{i=1}^N x_i`                             |\n|         极限         |                   $\\lim_{n \\to \\infty}x_n$                   | `\\lim_{n \\to \\infty}x_n`                                     |\n|         极限         |             $\\textstyle \\lim_{n \\to \\infty}x_n$              | `\\textstyle \\lim_{n \\to \\infty}x_n`                          |\n|         积分         |         $\\int\\limits_{1}^{3}\\frac{e^3/x}{x^2}\\, dx$          | `\\int\\limits_{1}^{3}\\frac{e^3/x}{x^2}\\, dx`                  |\n|         积分         |             $\\int_{1}^{3}\\frac{e^3/x}{x^2}\\, dx$             | `\\int_{1}^{3}\\frac{e^3/x}{x^2}\\, dx`                         |\n|         积分         |           $\\textstyle \\int\\limits_{-N}^{N} e^x dx$           | `\\textstyle \\int\\limits_{-N}^{N} e^x dx`                     |\n|         积分         |              $\\textstyle \\int_{-N}^{N} e^x dx$               | `\\textstyle \\int_{-N}^{N} e^x dx`                            |\n|       双重积分       |                   $\\iint\\limits_D dx\\,dy$                    | `\\iint\\limits_D dx\\,dy`                                      |\n|       三重积分       |                 $\\iiint\\limits_E dx\\,dy\\,dz$                 | `\\iiint\\limits_E dx\\,dy\\,dz`                                 |\n|       四重积分       |               $\\iiiint\\limits_F dx\\,dy\\,dz\\,d$               | `\\iiiint\\limits_F dx\\,dy\\,dz\\,dt`                            |\n|       路径积分       |           $\\int_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy$           | `\\int_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy`                     |\n|       环路积分       |          $\\oint_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy$           | `\\oint_{(x,y)\\in C} x^3\\, dx + 4y^2\\, dy`                    |\n|         交集         |                    $\\bigcap_{i=1}^n E_i$                     | `\\bigcap_{i=1}^n E_i`                                        |\n|         并集         |                    $\\bigcup_{i=1}^n E_i$                     | `\\bigcup_{i=1}^n E_i`                                        |\n\n# 二项式系数\n\n| 类型           | 符号              | LaTeX           |\n| :------------- | :---------------- | :-------------- |\n| 二项式系数     |  $\\binom{n}{k}$   | `\\binom{n}{k}`  |\n| 小型二项式系数 |  $\\tbinom{n}{k}$  | `\\tbinom{n}{k}` |\n| 大型二项式系数 |  $\\dbinom{n}{k}$  | `\\dbinom{n}{k}` |\n\n# 矩阵\n\n|                             符号                             |                            LaTeX                             |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n|          $\\begin{matrix}x & y \\\\ z & v\\end{matrix}$           |          `\\begin{matrix}x & y \\\\ z & v\\end{matrix}`           |\n|         $\\begin{vmatrix}x & y \\\\ z & v\\end{vmatrix}$          |         `\\begin{vmatrix}x & y \\\\ z & v\\end{vmatrix}`          |\n|         $\\begin{Vmatrix}x & y \\\\ z & v\\end{Vmatrix}$          |         `\\begin{Vmatrix}x & y \\\\ z & v\\end{Vmatrix}`          |\n|  $\\begin{bmatrix}0 & \\cdots & 0 \\\\ \\vdots & \\ddots & \\vdots \\\\0 & \\cdots & 0\\end{bmatrix}$  | `\\begin{bmatrix}0 & \\cdots & 0 \\\\ \\vdots & \\ddots & \\vdots \\\\ 0 & \\cdots & 0\\end{bmatrix}` |\n|         $\\begin{Bmatrix}x & y \\\\ z & v\\end{Bmatrix}$          |         `\\begin{Bmatrix}x & y \\\\ z & v\\end{Bmatrix}`          |\n|         $\\begin{pmatrix}x & y \\\\ z & v\\end{pmatrix}$          |         `\\begin{pmatrix}x & y \\\\ z & v\\end{pmatrix}`          |\n|  $\\bigl( \\begin{smallmatrix}a&b \\\\ c&d\\end{smallmatrix} \\bigr)$  | `\\bigl( \\begin{smallmatrix}a&b \\\\ c&d\\end{smallmatrix} \\bigr)` |\n\n# 数组\n\n|                             符号                             |                            LaTeX                             |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n|  $\\begin{array}{ |c |c |c |}a & b & S \\\\\\hline0 & 0 & 1 \\\\0 & 1 & 1 \\\\1 & 0 & 1 \\\\1 & 1 & 0\\end{array}$  | `\\begin{array}{ | c | c | c | }a & b & S \\\\\\hline0 & 0 & 1 \\\\0 & 1 & 1 \\\\1 & 0 & 1 \\\\1 & 1 & 0\\end{array}` |\n\n# 方程与方程组\n\n|                             符号                             |                            LaTeX                             |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n|  $\\begin{cases}3x + 5y + z \\\\7x - 2y + 4z \\\\-6x + 3y + 2z\\end{cases}$  | `\\begin{cases}3x + 5y + z \\\\7x - 2y + 4z \\\\-6x + 3y + 2z\\end{cases}` |\n\n## 条件定义\n\n|                             符号                             |                            LaTeX                             |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n|  $f(n) =\\begin{cases}n/2, & \\text{if }n\\text{ is even} \\\\3n+1, & \\text{if }n\\text{ is odd}\\end{cases}$  | `f(n) =\\begin{cases}n/2, & \\text{if }n\\text{ is even} \\\\3n+1, & \\text{if }n\\text{ is odd}\\end{cases}` |\n\n## 多行等式\n\n|                             符号                             |                            LaTeX                             |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n|  $\\begin{align}f(x) & = (a+b)^2 \\\\ & = a^2+2ab+b^2\\end{align}$  | `\\begin{align}f(x) & = (a+b)^2 \\\\ & = a^2+2ab+b^2\\end{align}`  |\n|  $\\begin{alignat}{2}f(x) & = (a-b)^2 \\\\ & = a^2-2ab+b^2\\end{alignat}$  | `\\begin{alignat}{2}f(x) & = (a-b)^2 \\\\ & = a^2-2ab+b^2\\end{alignat}` |\n|  $\\begin{array}{lcl}z & = & a \\\\ f(x,y,z) & = & x + y + z\\end{array}$  | `\\begin{array}{lcl}z & = & a \\\\ f(x,y,z) & = & x + y + z\\end{array}` |\n|  $\\begin{array}{lcr}z & = & a \\\\ f(x,y,z) & = & x + y + z\\end{array}$  | `\\begin{array}{lcr}z & = & a \\\\ f(x,y,z) & = & x + y + z\\end{array}` |\n\n## 自动编号\n\n|                             描述                             |                             符号                             |                            LaTeX                             |\n| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n| 开启 AMS 扩展包的情况下，会在部分环境的多行公式后自动编号；  |   $\\begin{eqnarray}E = mc^2 \\\\e^{i\\pi}+1=0\\end{eqnarray}$    |   `\\begin{eqnarray}E = mc^2 \\\\e^{i\\pi}+1=0\\end{eqnarray}`    |\n| 整个公式都不进行编号，可以使用`{equation*}`、`{eqnarray*}`环境； |  $\\begin{eqnarray*}E = mc^2 \\\\e^{i\\pi}+1=0\\end{eqnarray*}$   |  `\\begin{eqnarray*}E = mc^2 \\\\e^{i\\pi}+1=0\\end{eqnarray*}`   |\n| 单个方程不进行编号，可以在指定方程后面添加`\\nonumber`命令；  |  $\\begin{eqnarray}E = mc^2 \\\\e^{i\\pi}+1=0 \\nonumber\\end{eqnarray}$  | `\\begin{eqnarray}E = mc^2 \\\\e^{i\\pi}+1=0 \\nonumber\\end{eqnarray}` |\n| 个别公式出现或者不出现编号，可以在公式后使用`\\tag{}`或者`\\notag`命令； |  $\\begin{eqnarray}E = mc^2 \\notag\\\\e^{i\\pi}+1=0 \\tag{b}\\end{eqnarray}$  | `\\begin{eqnarray}E = mc^2 \\notag\\\\e^{i\\pi}+1=0 \\tag{b}\\end{eqnarray}` |\n\n# 括号\n\n常用的`()`、`[]`、`{}`括号符号可以在 LaTeX 环境当中直接进行使用，但是如果处于较大的符号当中，就应该配合`\\left`和`\\right`命令来使用：\n\n| 类型                                      |                             符号                             | LaTeX                                                        |\n| :---------------------------------------- | :----------------------------------------------------------: | :----------------------------------------------------------- |\n| 圆括号、小括号                            |                $\\left ( \\frac{a}{b} \\right )$                | `\\left ( \\frac{a}{b} \\right )`                               |\n| 方括号、中括号                            |  $\\left [ \\frac{a}{b} \\right ]  $、$\\left \\lbrack \\frac{a}{b} \\right \\rbrack$  | `\\left [ \\frac{a}{b} \\right ]` `\\left \\lbrack \\frac{a}{b} \\right \\rbrack` |\n| 花括号、大括号                            |  $\\left \\{ \\frac{a}{b} \\right \\} $、 $\\left \\lbrace \\frac{a}{b} \\right \\rbrace$  | `\\left \\{ \\frac{a}{b} \\right \\}` `\\left \\lbrace \\frac{a}{b} \\right \\rbrace` |\n| 角括号                                    |          $\\left \\langle \\frac{a}{b} \\right \\rangle$          | `\\left \\langle \\frac{a}{b} \\right \\rangle`                   |\n| 单竖线和双竖线                            |  $\\left \\vert \\frac{a}{b} \\right \\vert $、 $\\left \\Vert \\frac{c}{d} \\right \\Vert$  | `\\left \\vert \\frac{a}{b} \\right \\vert` `\\left \\Vert \\frac{c}{d} \\right \\Vert` |\n| 取整函数与取顶函数                        |  $\\left \\lfloor \\frac{a}{b} \\right \\rfloor $、$\\left \\lceil \\frac{c}{d} \\right \\rceil$  | `\\left \\lfloor \\frac{a}{b} \\right \\rfloor` `\\left \\lceil \\frac{c}{d} \\right \\rceil` |\n| 斜线与反斜线                              |           $\\left / \\frac{a}{b} \\right \\backslash$            | `\\left / \\frac{a}{b} \\right \\backslash`                      |\n| 上下箭头                                  |  $\\left \\uparrow \\frac{a}{b} \\right \\downarrow $、 $\\left \\Uparrow \\frac{a}{b} \\right \\Downarrow $、 $\\left \\updownarrow \\frac{a}{b} \\right \\Updownarrow$  | `\\left \\uparrow \\frac{a}{b} \\right \\downarrow` `\\left \\Uparrow \\frac{a}{b} \\right \\Downarrow` `\\left \\updownarrow \\frac{a}{b} \\right \\Updownarrow` |\n| 混合括号                                  |  $\\left [ 0,1 \\right ) $、 $\\left \\langle \\psi \\right \\vert$  | `\\left [ 0,1 \\right )` `\\left \\langle \\psi \\right \\vert`     |\n| 使用`\\left.`和`\\right.`不显示某侧的括号； |             $\\left. \\frac{A}{B} \\right \\} \\to X$             | `\\left. \\frac{A}{B} \\right \\} \\to X`                         |\n\n> **注意**：在 Markdown 当中使用 LaTeX 时，为了避免语法冲突，花括号`{}`必须采用`\\{`和`\\}`进行转义，或者改用`\\lbrace`和`\\rbrace`的方式；如果是在 Markdown 表格当中使用 LaTeX，则必须采用 `\\vert` 或者 `\\Vert` 代替直接在公式当中书写 `|`和`||`。\n\n## 括号尺寸\n\n|                             符号                             | LaTeX                                                        |\n| :----------------------------------------------------------: | :----------------------------------------------------------- |\n|  $( \\bigl( \\Bigl( \\biggl( \\Biggl( \\dots \\Biggr] \\biggr] \\Bigr] \\bigr] ]$  | `( \\bigl( \\Bigl( \\biggl( \\Biggl( \\dots \\Biggr] \\biggr] \\Bigr] \\bigr] ]` |\n|  $\\{ \\bigl \\{ \\Bigl \\{ \\biggl \\{ \\Biggl \\{ \\dots \\Biggr\\rangle \\biggr\\rangle \\Bigr\\rangle \\bigr\\rangle \\rangle$  | `\\{ \\bigl \\{ \\Bigl \\{ \\biggl \\{ \\Biggl \\{ \\dots \\Biggr\\rangle \\biggr\\rangle \\Bigr\\rangle \\bigr\\rangle \\rangle` |\n|  $\\vert \\big \\vert \\Big \\vert \\bigg \\vert \\Bigg \\vert \\dots \\Bigg \\vert \\bigg \\vert \\Big \\vert \\big \\vert$  | `\\vert \\big \\vert \\Big \\vert \\bigg \\vert \\Bigg \\vert \\dots \\Bigg \\vert \\bigg \\vert \\Big \\vert \\big \\vert` |\n|  $\\lfloor \\bigl\\lfloor \\Bigl\\lfloor \\biggl\\lfloor \\Biggl\\lfloor \\dots \\Biggr\\rceil \\biggr\\rceil \\Bigr\\rceil \\bigr\\rceil \\rceil$  | `\\lfloor \\bigl\\lfloor \\Bigl\\lfloor \\biggl\\lfloor \\Biggl\\lfloor \\dots \\Biggr\\rceil \\biggr\\rceil \\Bigr\\rceil \\bigr\\rceil \\rceil` |\n|  $\\uparrow \\big\\uparrow \\Big\\uparrow \\bigg\\uparrow \\Bigg\\uparrow \\dots \\Bigg\\Downarrow \\bigg\\Downarrow \\Big\\Downarrow \\big\\Downarrow \\Downarrow$  | `\\uparrow \\big\\uparrow \\Big\\uparrow \\bigg\\uparrow \\Bigg\\uparrow \\dots \\Bigg\\Downarrow \\bigg\\Downarrow \\Big\\Downarrow \\big\\Downarrow \\Downarrow` |\n|  $\\updownarrow \\big\\updownarrow \\Big\\updownarrow \\bigg\\updownarrow \\Bigg\\updownarrow \\dots \\Bigg\\Updownarrow \\bigg\\Updownarrow \\Big\\Updownarrow \\big\\Updownarrow \\Updownarrow$  | `\\updownarrow \\big\\updownarrow \\Big\\updownarrow \\bigg\\updownarrow \\Bigg\\updownarrow \\dots \\Bigg\\Updownarrow \\bigg\\Updownarrow \\Big\\Updownarrow \\big\\Updownarrow \\Updownarrow` |\n|  $/ \\big/ \\Big/ \\bigg/ \\Bigg/ \\dots \\Bigg\\backslash \\bigg\\backslash \\Big\\backslash \\big\\backslash \\backslash$  | `/ \\big/ \\Big/ \\bigg/ \\Bigg/ \\dots \\Bigg\\backslash \\bigg\\backslash \\Big\\backslash \\big\\backslash \\backslash` |\n\n# 空格与换行\n\n| 描述                         | 符号             | LaTeX          |\n| :--------------------------- | :--------------- | -------------- |\n| 双空格                       |  $a \\qquad b$    | `a \\qquad b`   |\n| 单空格                       |  $a \\quad b$     | `a \\quad b`    |\n| 字符空格                     |  $a\\ b$          | `a\\ b`         |\n| 文本模式中的字符空格         |  $a \\text{ } b$  | `a \\text{ } b` |\n| 大空格                       |  $a\\;b$          | `a\\;b`         |\n| 小空格                       |  $a\\,b$          | `a\\,b`         |\n| 极小空格                     |  $ab$            | `ab`           |\n| 极小空格（用于区分语法）     |  $a b$           | `a b`          |\n| 无空格（用于区分多字母变量） |  $\\mathit{ab}$   | `\\mathit{ab}`  |\n\nMathJax 3.0 取消了单行公式环境下`\\\\`的强制换行功能，因此强制换行命令`\\\\`仅能用于`eqnarray`、`align`、`array`、`matrix`等多行环境当中。除此之外，还可以在`\\displaylines{}`行显示命令当中使用`\\\\`强制换行命令：\n\n|                  符号                  |                LaTeX                 |\n| :------------------------------------: | :----------------------------------: |\n|  $\\displaylines{y=1729x \\\\ y=1729-x}$  | `\\displaylines{y=1729x \\\\ y=1729-x}` |\n\n# 颜色\n\nLaTeX 默认支持下面表格当中的文本颜色：\n\n![img](https://uinika.gitee.io/Zen/LaTex/colors.png)\n\n## 字体颜色\n\n公式当中可以使用`\\color{options}{math}`调用颜色命令，第 1 个参数为**颜色**，第 2 个参数为**公式内容**：\n\n|                             符号                             |                            LaTeX                            |\n| :----------------------------------------------------------: | :---------------------------------------------------------: |\n|  ${\\color{Blue}x^2}+{\\color{Orange}2x}-{\\color{LimeGreen}1}$  | `{\\color{Blue}x^2}+{\\color{Orange}2x}-{\\color{LimeGreen}1}` |\n\n## 背景颜色\n\n文本环境中可以使用`\\colorbox{options}{text}`来调用背景颜色命令，第 1 个参数为**颜色**，第 2 个颜色为**公式内容**：\n\n|              符号               |             LaTeX             |\n| :-----------------------------: | :---------------------------: |\n|  $\\colorbox{yellow}{Thistext}$  | `\\colorbox{yellow}{Thistext}` |\n\n该命令应用于数学环境当中时，需要在第 2 个参数加入`$\\displaystyle + 公式$`：\n\n|                        符号                        |                      LaTeX                       |\n| :------------------------------------------------: | :----------------------------------------------: |\n| $$\\colorbox{yellow}{$\\displaystyle \\frac{a}{b}$}$$ | `\\colorbox{yellow}{$\\displaystyle \\frac{a}{b}$}` |\n\n> **注意**：在 Markdown 内联 LaTeX 公式`$...$`当中使用`$\\displaystyle + 公式$`语法时将会引发冲突，因此该语法仅用于多行公式 `$$...$$`。\n\n## RGB 颜色\n\n通过使用`\\definecolor`命令可以自定义 LaTeX 公式的颜色：\n\n|                             符号                             |                            LaTeX                             |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n|  $\\definecolor{mygreen}{RGB}{0,200,0} {\\color{mygreen}e^{i \\pi} + 1 = 0 }$  | `\\definecolor{mygreen}{RGB}{0,200,0} {\\color{mygreen}e^{i \\pi} + 1 = 0 }` |\n\n# 字体\n\n## 字体加粗\n\n| 符号                                        | LaTeX                                     |\n| :------------------------------------------ | :---------------------------------------- |\n|  $\\boldsymbol{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  | `\\boldsymbol{ABCDEFGHIJKLMNOPQRSTUVWXYZ}` |\n|  $\\boldsymbol{abcdefghijklmnopqrstuvwxyz}$  | `\\boldsymbol{abcdefghijklmnopqrstuvwxyz}` |\n|  $\\boldsymbol{0123456789}$                  | `\\boldsymbol{0123456789}`                 |\n\n## 黑体\n\n| 符号                                    | LaTeX                                 |\n| :-------------------------------------- | :------------------------------------ |\n|  $\\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  | `\\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}` |\n|  $\\mathbf{abcdefghijklmnopqrstuvwxyz}$  | `\\mathbf{abcdefghijklmnopqrstuvwxyz}` |\n|  $\\mathbf{0123456789}$                  | `\\mathbf{0123456789}`                 |\n\n## 黑板报体\n\n| 符号                                    | LaTeX                                 |\n| :-------------------------------------- | :------------------------------------ |\n|  $\\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  | `\\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}` |\n|  $\\mathbb{abcdefghijklmnopqrstuvwxyz}$  | `\\mathbb{abcdefghijklmnopqrstuvwxyz}` |\n|  $\\mathbb{0123456789}$                  | `\\mathbb{0123456789}`                 |\n\n## 斜体\n\n| 符号                                    | LaTeX                                 |\n| :-------------------------------------- | :------------------------------------ |\n|  $\\mathit{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  | `\\mathit{ABCDEFGHIJKLMNOPQRSTUVWXYZ}` |\n|  $\\mathit{abcdefghijklmnopqrstuvwxyz}$  | `\\mathit{abcdefghijklmnopqrstuvwxyz}` |\n|  $\\mathit{0123456789}$                  | `\\mathit{0123456789}`                 |\n\n## 罗马体\n\n| 符号                                    | LaTeX                                 |\n| :-------------------------------------- | :------------------------------------ |\n|  $\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  | `\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}` |\n|  $\\mathrm{abcdefghijklmnopqrstuvwxyz}$  | `\\mathrm{abcdefghijklmnopqrstuvwxyz}` |\n|  $\\mathrm{0123456789}$                  | `\\mathrm{0123456789}`                 |\n\n## 无衬线体\n\n| 符号                                    | LaTeX                                 |\n| :-------------------------------------- | :------------------------------------ |\n|  $\\mathsf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  | `\\mathsf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}` |\n|  $\\mathsf{abcdefghijklmnopqrstuvwxyz}$  | `\\mathsf{abcdefghijklmnopqrstuvwxyz}` |\n|  $\\mathsf{0123456789}$                  | `\\mathsf{0123456789}`                 |\n\n## 手写体\n\n| 符号                                     | LaTeX                                  |\n| :--------------------------------------- | :------------------------------------- |\n|  $\\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  | `\\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}` |\n|  $\\mathcal{abcdefghijklmnopqrstuvwxyz}$  | `\\mathcal{abcdefghijklmnopqrstuvwxyz}` |\n|  $\\mathcal{0123456789}$                  | `\\mathcal{0123456789}`                 |\n\n## 哥特字体\n\n| 符号                                      | LaTeX                                   |\n| :---------------------------------------- | :-------------------------------------- |\n|  $\\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$  | `\\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}` |\n|  $\\mathfrak{abcdefghijklmnopqrstuvwxyz}$  | `\\mathfrak{abcdefghijklmnopqrstuvwxyz}` |\n|  $\\mathfrak{0123456789}$                  | `\\mathfrak{0123456789}`                 |\n\n## 小脚本风格\n\n| 符号                                                | LaTeX                                             |\n| :-------------------------------------------------- | :------------------------------------------------ |\n|  ${\\scriptstyle\\text{ABCDEFGHIJKLMNOPQRSTUVWXYZ}}$  | `{\\scriptstyle\\text{ABCDEFGHIJKLMNOPQRSTUVWXYZ}}` |\n|  ${\\scriptstyle\\text{abcdefghijklmnopqrstuvwxyz}}$  | `{\\scriptstyle\\text{abcdefghijklmnopqrstuvwxyz}}` |\n|  ${\\scriptstyle\\text{0123456789}}$                  | `{\\scriptstyle\\text{0123456789}}`                 |\n\n## 字号尺寸\n\n| 符号                                  | LaTeX                               |\n| :------------------------------------ | :---------------------------------- |\n|  ${\\tiny abc极小tiny}$                | `{\\tiny abc极小tiny}`               |\n|  ${\\scriptsize abc 超小 scriptsize}$  | `{\\scriptsize abc 超小 scriptsize}` |\n|  ${\\small abc 小 small}$              | `{\\small abc 小 small}`             |\n|  ${\\normalsize abc 正常 normal}$      | `{\\normalsize abc 正常 normal}`     |\n|  ${\\large abc 大 large}$              | `{\\large abc 大 large}`             |\n|  ${\\Large abc 超大 Large}$            | `{\\Large abc 超大 Large}`           |\n|  ${\\LARGE abc 特大 LARGE}$            | `{\\LARGE abc 特大 LARGE}`           |\n|  ${\\huge abc 巨大 huge}$              | `{\\huge abc 巨大 huge}`             |\n|  ${\\Huge abc 巨无霸 Huge}$            | `{\\Huge abc 巨无霸 Huge}`           |\n","tags":["LaTeX","latex 语法"]},{"title":"数据结构与算法 —— 复杂度分析","url":"/2021/09/82c308cd.html","content":"\n> 数据结构与算法的目的在于让代码运行更快，占用更少的存储空间，所以，执行效率是必须评判的点，但是执行效率需要有一个评价标准，这个标准就是复杂度\n\n# 为什么需要复杂度分析？\n\n代码写完后，直接去跑一遍就好了，使用一些工具自然能统计出运行的时间、占用内存的大小，什么的数据会比实实在在的运行得来的结果直接、明确呢？那为什么还要复杂度分析？\n\n1. 测试结果强依赖于测试环境\n   * 这样的测试方式是强依赖于测试环境的，不同的测试环境得出的结果会有差别\n2. 测试结果受数据规模影响很大\n   * 最明显的就是排序算法，给10个元素排序和给1000000个元素排序需要的时间明显不一样\n\n<!-- more -->\n\n# 大 O 复杂度表示法\n\n> 算法的执行效率本质上是算法的执行时间，那么怎么在不运行代码的情况下评估代码的执行时间呢\n\n## 基本理论\n\n看如下代码\n\n```java\nint sum(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum = sum + 1;\n    }\n    return sum;\n}\n```\n\nCPU 的操作包括 输入、运算、输出，如果把上述代码第 4 行看成一个基本的执行单位(unit)，上述代码就需要执行 n 次第 4 行代码，再加上第二行代码和 for 循环里面的 `int i = 1`，所以此方法的会执行 (n + 2) 个 unit\n\n```java\nint calc(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            int tmp = i * j;\n            sum = sum + tmp;\n        }\n    }\n}\n```\n\n如果上述方法 for 循环中还有一个循环 n 次的 for 循环，会执行 $ n * (2n + 1) + 1 + 1 $ 个 unit，即：$ 2n^2 + n + 2 $ 个unit\n\n通过上述分析，我们可以发现：**所有代码的执行时间T(n)与每行代码的执行次数n成正比**。\n\n将其总结为一个公式就是：$ T(n) = O(f(n)) $\n\n所以，第一段代码的时间复杂度就是 $ O(n+2) $，第二段代码的时间复杂度就是 $ O(2n^2 + n + 2) $\n\n事实上，大 O 时间复杂度表示法也叫做渐进时间复杂度，表示的是**代码执行时间随数据规模增长的趋势**，所以，并不需要关注公式中的低阶、系数、常量这三部分，因为这三部分并不会明显左右增长趋势，我们只需要记录一下最大的量级即可。即：第一段代码的时间复杂度是 $ O(n) $，第二段代码的时间复杂度是 $ O(n^2) $\n\n## 时间复杂度分析方法\n\n1. 只关注循环次数最多的一段代码\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n## 几种常见的时间复杂度\n\n常见的时间复杂度有：\n\n1. 常量阶：$O(1)$\n2. 线性阶：$O(n)$\n3. 次方阶：$O(n^2)$、$O(n^3)$、$O(n^4)$ ...\n4. 阶乘阶：$O(n!)$\n5. 指数阶：$O(2^n)$\n6. 对数阶：$O(logn)$\n7. 线性对数阶：$O(nlogn)$\n\n几种时间复杂度的函数图像（增长趋势）\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"函数图\" src=\"https://i.loli.net/2021/10/19/76oKqSlTEZpLxa9.png\" style=\"width: 100%;\"/>\n</div>\n\n## 空间复杂度\n\n与时间复杂度类似，空间复杂度全称就是**渐进空间复杂度**，**表示算法的存储空间与数据规模之间的增长关系**。与时间复杂度不同的是，空间复杂度中，常见的空间复杂度就是就是 $O(1)$、$O(n)$、$O(n^2)$\n\n与时间复杂度计算过程类似，我们将声明一次变量作为一个基本单位进行计算即可，不展开叙述\n\n# 时间复杂度的特殊场景\n\n> 就像生活中有最好、最坏结果一样，时间复杂度也有几种特别的结果\n\n## 最好、最坏情况时间复杂度\n\n看一个最简单的查找元素的代码：\n\n```java\nint search(int[] array, int x) {\n    int index = -1;\n    for (int i = 0; i < array.length; i++) {\n        if (array[i] == x) {\n            index = i;\n        }\n    }\n    return index;\n}\n```\n\n可以很轻易的看出上面代码的时间复杂度是 $O(n)$，但是，当我们查找到元素之后就没必要循环了，所以将代码优化一下\n\n```java\nint search(int[] array, int x) {\n    for (int i = 0; i < array.length; i++) {\n        if (array[i] == x) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n当我们将代码优化之后，时间复杂度依旧是 $O(n)$，但是如果元素就在第一个，代码只需要执行一次就结束了，如果元素在最后一个，代码就需要执行 n 次了\n\n## 平均情况时间复杂度\n\n如上面的代码，如何计算平均复杂度呢？\n\n* 变量 `x` 可能会在数组中的位置有 *0 ～ n-1* 和 *不在数组* 中共 n+1 种情况，所以将这些情况的需要执行的次数加起来然后除以 n+1 就是此代码的平均复杂度。即：\n  $$\n  \\dfrac{1+2+3+...+n+n}{n+1} = \\dfrac{n!+n}{n+1} = \\dfrac{n(n+3)}{2(n+1)}\n  $$\n  当我们忽略系数、低阶、常量，将公式简化后，得到的平均复杂度就是 $O(n)$\n\n* 但是，这样的计算是有点问题的。首先，要查找的变量 x 要么在数组中，要么不在数组中，所以其概率都为 $\\tfrac{1}{2}$ ，当元素在数组中时，其在每一个位置的概率为 $\\tfrac{1}{n}$ ，所以要查找的数据在数组中任一位置的概率为 $\\tfrac{1}{2n}$ ，计算方式为：\n  $$\n  1\\times\\dfrac{1}{2n}+2\\times\\dfrac{1}{2n}+3\\times\\dfrac{1}{2n}+...+n\\times\\dfrac{1}{2n}+n\\times\\dfrac{1}{2}=\\dfrac{3n+1}{4}\n  $$\n  这个值在概率中叫做**加权平均值**，也叫做**期望值**，所以平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**。但是在把公式简化之后，时间复杂度同样是 $O(n)$\n\n# 内容总结\n\n* 本篇介绍了**复杂度**，包括时间复杂度和空间复杂度，时间复杂度中，介绍了**最好、最坏时间复杂度**和**平均时间复杂度**。\n\n* 复杂度是衡量算法效率的标准，可以熟练分析就好\n","tags":["数据结构与算法"]},{"title":"数据结构与算法 —— 概述","url":"/2021/09/efe21aee.html","content":"\n> 数据结构的一些实现和笔记可以看[数据结构](https://github.com/ann-zhgy/inner-strength/tree/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\n\n# 为什么要学习数据结构与算法？\n\n1. 应付面试，现在的企业面试更加看重的是你长远发展的潜力，会更加看重基础\n2. 数据结构与算法属于基础，掌握之后对于学习新的开源项目的原理及其源码有很大的帮助\n3. 可以提高自己的代码质量，写出好代码，而不仅仅是能用的代码\n\n<!-- more -->\n\n# 什么是数据结构？什么是算法？\n\n## 数据结构\n\n数据结构就是数据的组织方式。在生活中，图书馆图书分类放置的方式、小卖铺商品放置的方式都可以称作是数据结构。在专业领域，指的就是数组、链表、树、图等数据结构\n\n## 算法\n\n算法就是对数据进行操作的方式。比如图书馆的书怎么摆放、怎么找到小卖铺对应的商品等。在专业领域，指的就是各种各样的排序算法、查找算法等。\n\n# 数据结构和算法有什么关系\n\n数据结构是算法的基础，很多算法就是在特定的数据结构上才有意义。所以，数据结构和算法是相辅相成的\n\n# 数据结构与算法该怎么学？\n\n## 数据结构与算法内容\n\n数据结构与算法包括很多内容，如下图所示：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"数据结构与算法\" src=\"https://i.loli.net/2021/10/19/5sty1R9LdqwTOYm.png\" style=\"width: 100%;\">\n</div>\n\n\n1. **复杂度分析**是评判算好坏及其运行时间的基础，非常重要，必须掌握\n2. 因为我们并不是算法工程师，所以只需要掌握常见的数据结构与算法即可：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树；递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法\n\n## 学习数据结构与算法的技巧\n\n1. 多学多练，适当刷题。\n   * 纸上得来终觉浅，绝知此事要躬行。适度刷题练习可以帮我们快速掌握所学内容\n2. 学的时候要思考\n   * 学而不思则惘，思考可以帮助自己形成自己的理解\n3. 别好高骛远\n   * 知识需要沉淀，不要想着一次就掌握所有东西，学习知识的过程是一个不断沉淀，不断总结的过程，一定要把一部分完全弄懂之后再开始学习下一部分\n\n","tags":["数据结构与算法"]},{"title":"闲聊 —— 讲讲我对于程序员的一些看法","url":"/2021/09/37113fbf.html","content":"\n> 程序员这个群体作为“高薪”职业、“新时代农民工”，队伍在不断壮大\n\n<!-- more -->\n\n# 选择程序员这个职业意味着什么？\n\n1. 意味着不断学习，这一点对于IT这个行业尤为重要\n2. 意味着“加班”，其实对于加班这件事情，还是要看公司，但是，在上线前，加班基本上是跑不了的\n3. 意味着“高薪”？IT行业的高薪和加班是有一定关系的，如果你计算时薪的话，对于大多数来说，并不一定高，但是，付出与收获是成正比的，我始终坚信这一点！\n4. 意味着 35 会找不到工作？我认为不管是哪一行，如果你跟不上这个行业的发展，那就一定会被淘汰，不巧的是，IT行业正在高速发展期，所以“不断学习”这一点，及其的重要，或许随着年龄增加，我们学习的效率会不可避免的降低，但是我们所拥有的经验，同样可以帮助我们学习，当然，这个经验，需要是经得起考验的才可以\n\n# 程序员的基本功\n\n作为一个普通二本院校毕业，工作了一年的菜鸟来说，我认为服务器端开发的程序员的基本功有：\n\n1. **数据结构**。这个是最基本的东西，这个足够扎实，对于之后的学习有很大帮助。\n2. **设计模式**。代码不是可以用就可以了，还需要有好的维护性、可扩展性以及**容易阅读**，*代码是给人看的，字节码和二进制才是给机器看的*\n3. **其他基础知识**。比如，计算机组成原理、计算机网络，这些同样是基础知识中很重要的一部分。\n4. **良好的工程概念**。「软件工程」同样是工程，也有相应的步骤。像市场调研、需求审批、设计开发等，这些东西了解一下会有意想不到的惊喜。\n5. **不断学习的决心和行动力**。这一点我认为在每一个行业都是通用的，至少不可以跟不上行业的发展，对吧？\n6. **适合自己的学习方法**。学习是有方法的，找到适合自己的学习方法可以显著的提高学习效率。\n\n# 关于学习的一些建议\n\n1. 要多看多问，更重要的是多想。**学而不思则惘，思而不学则怠**\n2. 要勤于实践。**百闻不如一见，百见不如一干**\n3. 互联网的发展是不断提出问题，然后再解决问题的过程，随着这个路线学习，或许会容易很多\n4. 如有必要，报个培训班，因为这是我们获得一个技能最快的方式了，但是绝对不能依赖\n5. 一定要学习一些算法，这个对于自己写代码有帮助\n","tags":["闲聊～"]},{"title":"vmware 虚拟机安装 Macos","url":"/2021/08/e50044fa.html","content":"\n> 本人作为一个用不起 mac 的 diao si，又不想把自己的电脑装成黑苹果，毕竟电脑东西还有点多，而且，安装完之后还不一定适配，尤其是驱动问题。所以就只能搞搞虚拟机了......\n\n# 安装VMware\n\n这个不用多说，直接[官网](https://www.vmware.com/go/getworkstation-win)下载，然后安装，不停的点击【下一步】即可\n\n安装完之后的VMware是不可以安装Mac系统的，我们需要先**解锁**！！！\n\n<!-- more -->\n\n# unlocker\n\n这个包可以让你的 VMware 支持安装 Macos 系统，直接百度搜 `vmware unlocker` 就可以，找到 github 的网站下载即可\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"image-20210813160409263\" src=\"https://i.loli.net/2021/08/15/RJU8EXDjwdstOig.png\" style=\"width: 100%;\">\n</div>\n\n下载完成后选择 `win-install.cmd` 右键 -> 以管理员方式运行安装即可\n\n# MacOS 镜像文件\n\n> 此链接是我测试可用的 `Macos 10.15` 的镜像文件\n\n链接：https://pan.baidu.com/s/1gmY405HLACkepcunXUO9Yg\n提取码：fxyy\n\n# 安装\n\n1. 打开VMware -> 新建虚拟机\n\n2. 需要选择自定义类型的配置\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"image-20210813160846974\" src=\"https://i.loli.net/2021/08/15/c39CAZWPUMvd4GR.png\" style=\"width: 100%;\">\n   </div>\n   \n3. 下一步，之后先选择稍后安装操作系统\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"image-20210813160956955\" src=\"https://i.loli.net/2021/08/15/VXoRJlbCdTWEGZB.png\" style=\"width: 100%;\">\n   </div>\n\n4. 选择 10.15 版本\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"image-20210813161942410\" src=\"https://i.loli.net/2021/08/15/7gVW3qnosJMheK1.png\" style=\"width: 100%;\">\n   </div>\n\n5. 之后选择硬件配置，一直下一步即可，内存和磁盘容量可以酌情给大一些\n\n6. 直到这里\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"image-20210813162114124\" src=\"https://i.loli.net/2021/08/15/om8wZdlJctpDrCv.png\" style=\"width: 100%;\">\n   </div>\n   \n7. 我们需要先自定义硬件，主要是选择macos镜像的地址\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"image-20210813162211969\" src=\"https://i.loli.net/2021/08/15/J8m3ZCk4EuoYPVD.png\" style=\"width: 100%;\">\n   </div>\n   \n8. 点击完成\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"image-20210813162314434\" src=\"https://i.loli.net/2021/08/15/DwaEMsY3ecmLpHU.png\" style=\"width: 100%;\">\n   </div>\n   \n9. 需要保证CD/DVD这里是选择了你下载的镜像文件的，之后开启虚拟机\n\n10. 在 VMware 15 之前点击开启虚拟机后是启动不了的，需要改一下虚拟机的配置文件，15之后不用了\n\n    1. 配置文件：虚拟机文件的目录 -> 后缀为 .vmx 的文件\n    2. 用记事本打开，然后在**最后一行**添加 `smc.version = 0`，保存退出。\n\n11. 之后就是操作系统安装的引导界面，按照提示安装即可，安装系统之前先格式化硬盘\n\n    <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n      <img alt=\"image-20210813162832324\" src=\"https://i.loli.net/2021/08/15/l4Idf2oq8hwQYcA.png\" style=\"width: 100%;\">\n    </div>\n\n12. 之后就是漫长的等待时间\n\n    <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n      <img alt=\"image-20210813165121077\" src=\"https://i.loli.net/2021/08/15/OhWL1kHEJjzopB8.png\" style=\"width: 100%;\">\n    </div>\n\n13. 安装完成\n\n    <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n      <img alt=\"image-20210813171556909\" src=\"https://i.loli.net/2021/08/15/mPjqV59volU7EGL.png\" style=\"width: 100%;\">\n    </div>\n","tags":["macos","vmware","vmware安装macos"]},{"title":"elasticsearch 建议器","url":"/2021/08/287a9339.html","content":"\n# 什么是建议器\n\n> 建议器就是我们进行搜索时，浏览器进行的自动补全和自动纠错的行为\n>\n> 其意义在于可以提升用户体验，减少用户搜索的次数\n\n<!-- more -->\n\n# ES 中建议器的使用\n\nelasticsearch 的建议器存在于 `Suggesters API` 中，需要注意的是：`_suggest` 已经弃用了，现在可以通过 `_search` api进行建议器的查询\n\n<!-- more -->\n\n在使用建议器前，我们先插入一些数据\n\n```text\nPUT iktest\n{\n  \"mappings\": {\n    \"dynamic\": false,\n    \"properties\": {\n      \"content\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\"\n      }\n    }\n  }\n}\n\nPOST iktest/_doc\n{\n  \"content\": \"I want something just like this\"\n}\n\nPOST iktest/_doc\n{\n  \"content\": \"I want to know something of you\"\n}\n\nPOST iktest/_doc\n{\n  \"content\": \"I want to know anything of you\"\n}\n\nPOST iktest/_doc\n{\n  \"content\": \"I love you more than anyone\"\n}\n```\n\n现在我们可以来使用建议器：\n\n* 补全词条\n\n  ```text\n  GET iktest/_search\n  {\n    \"suggest\": {\n      \"make_up_suggest\": {\n        \"text\": \"somethi\",\n        \"term\": {\n          \"field\": \"content\"\n        }\n      }\n    }\n  }\n  ```\n\n  \n\n* 自动纠错\n\n  ```text\n  GET iktest/_search\n  {\n    \"suggest\": {\n      \"make_up_suggest\": {\n        \"text\": \"semothing\",\n        \"term\": {\n          \"field\": \"content\"\n        }\n      }\n    }\n  }\n  ```\n\n# ES 的 4 种建议器\n\nES 有四种建议器：\n\n* 词条建议器（term suggester）：对于给定文本的每个词条，该键议器从索引中抽取要建议的关键词，这对于短字段（如分类标签）很有效。\n* 词组建议器（phrase suggester）：我们可以认为它是词条建议器的扩展，为整个文本（而不是单个词条）提供了替代方案，它考虑了各词条彼此临近出现的频率，使得该建议器更适合较长的字段，比如商品的描述。\n* 完成建议器（completion suggester）：该建议器根据词条的前缀，提供自动完成的功能（智能提示，有点最左前缀查询的意思），为了实现这种实时的建议功能，它得到了优化，工作在内存中。所以，速度要比之前说的`match_phrase_prefix`快的多！\n* 上下文建议器（context suggester）：它是完成建议器的扩展，允许我们根据词条或分类亦或是地理位置对结果进行过滤。\n\n## 词条建议器\n\n> 词条建议器可以实现对结果的自动纠错或自动补全，主要是以词条为单位进行建议\n\n```text\nGET iktest/_search\n{\n  \"suggest\": {\n    \"term_suggest1\": {\n      \"text\": \"anythi\",\n      \"term\": {\n        \"field\": \"content\"\n      }\n    },\n    \"term_suggest2\": {\n      \"text\": \"anynoe\",\n      \"term\": {\n        \"field\": \"content\"\n      }\n    }\n  }\n}\n```\n\n### 建议器中的其他参数：\n\n- text：建议文本，建议文本是必需的选项，可以通过全局（多个建议器中查询相同的内容）或者按照单个建议器的格式来\n- field：从field字段中获取候选建议的字段。这是一个必需的选项，需要全局设置或根据建议设置\n- analyzer：用于分析建议文本的分析器。默认为建议字段的搜索分析器\n- size：建议文本标记返回的最大条目\n- sort：定义如何根据建议文本术语对建议进行排序。它有两个可能的值\n  - score，先按分数排序，然后按文档频率排序，再按术语本身排序\n  - frequency，首先按文档频率排序，然后按相似性分数排序，然后按术语本身排序。也可以理解为按照流行度排序\n- suggest_mode：控制建议的模式，有3个模式可选择\n  - missing，仅为不在索引中的建议文本术语提供建议。这是默认值\n  - popular，仅建议在比原始建议文本术语更多的文档中出现的建议。也就是说提供比原有输入词频更高的词条\n  - always，根据建议文本中的条款建议任何匹配的建议。说白了就是无论如何都会提供建议\n- lowercase_terms：在文本分析之后降低建议文本术语的大小写\n- min_word_length：建议文本术语必须具有的最小长度才能包含在内。默认为4.（旧名称`min_word_len`已弃用）\n- shard_size：设置从每个单独分片中检索的最大建议数。在减少阶段，仅根据size选项返回前N个建议。默认为该  size选项。将此值设置为高于该值的值size可能非常有用，以便以性能为代价获得更准确的拼写更正文档频率。由于术语在分片之间被划分，因此拼写校正频率的分片级文档可能不准确。增加这些将使这些文档频率更精确\n- max_inspections：用于乘以的因子， shards_size以便在碎片级别上检查更多候选拼写更正。可以以性能为代价提高准确性。默认为5\n- string_distance：用于比较类似建议术语的字符串距离实现\n  - internal：默认值基于damerau_levenshtein，但高度优化用于比较索引中术语的字符串距离\n  - damerau_levenshtein：基于Damerau-Levenshtein算法的字符串距离算法\n  - levenshtein：基于Levenshtein编辑距离算法的字符串距离算法\n  - jaro_winkler：基于Jaro-Winkler算法的字符串距离算法\n  - ngram：基于字符n-gram的字符串距离算法\n\n### 建议器选择词条的条件\n\n词条建议器使用了Lucene的错拼检查器模块，该模块会根据给定词条的**编辑距离**（es使用了叫做Levenstein edit distance的算法，其核心思想就是一个词改动多少字符就可以和另外一个词一致），从索引中返回最大编辑距离不超过某个值的那些词条。比如说为了从 `mik `得到 `mick`，需要加入一个字母（也就是说需要至少要改动一次），所以这两个词的编辑距离就是1。我们可以通过配置一系列的选项，来均衡灵活和性能：\n\n- max_edits：最大编辑距离候选建议可以具有以便被视为建议。只能是介于1和2之间的值。任何其他值都会导致抛出错误的请求错误。默认为2。\n- prefix_length：必须匹配的最小前缀字符的数量才是候选建议。默认为1.增加此数字可提高拼写检查性能。通常拼写错误不会出现在术语的开头。（旧名 `prefix_len` 已弃用）。\n- min_doc_freq：建议应出现的文档数量的最小阈值。可以指定为绝对数字或文档数量的相对百分比。这可以仅通过建议高频项来提高质量。默认为0f且未启用。如果指定的值大于1，则该数字不能是小数。分片级文档频率用于此选项。\n- max_term_freq：建议文本令牌可以存在的文档数量的最大阈值，以便包括在内。可以是表示文档频率的相对百分比数（例如0.4）或绝对数。如果指定的值大于1，则不能指定小数。默认为0.01f。这可用于排除高频术语的拼写检查。高频术语通常拼写正确，这也提高了拼写检查的性能。分片级文档频率用于此选项。\n\n## 词组建议器\n\n> 词组建议器为整个文本进行建议\n\n```text\nGET iktest/_search\n{\n  \"suggest\": {\n    \"phrase_suggest\": {\n      \"text\": \"I lore you moer than anyoeo\",\n      \"phrase\": {\n        \"field\": \"content\",\n        \"highlight\": {\n          \"pre_tag\": \"<em>\",\n          \"post_tag\": \"</em>\"\n        }\n      }\n    }\n  }\n}\n```\n\n注意点：\n\n1. 建议器的类型为：`phrase`\n\n2. 建议器返回的结果不一定就是我们想要的结果\n\n3. 对于纠错内容，我们可以直接高亮显示，但是一定要与查询时的高亮区分开\n\n   `suggest`：\n\n   ```text\n   GET iktest/_search\n   {\n     // ...\n     \"field\": \"content\",\n     \"highlight\": {\n       \"pre_tag\": \"<em>\",\n       \"post_tag\": \"</em>\"\n     }\n     // ...\n   }\n   ```\n\n   `_search`\n\n   ```text\n   GET test/users/_search\n   {\n     // ...\n     \"highlight\": {\n       \"fields\": {\n         \"message\": {}\n       }, \n       \"pre_tags\": \"<span style='color: red;'>\",\n       \"post_tags\": \"</span>\"\n     }\n     // ...\n   }\n   ```\n\n> `phrase suggester`在`term suggester`的基础上，会考虑多个`term`之间的关系，比如是否同时出现索引的原文中，临近程度，词频等\n\n## 完成建议器\n\n> 关于完成建议器，可以参考[大佬](https://www.cnblogs.com/Neeo/articles/10695019.html)的博客，我的笔记有很多也是从其博客摘抄的。\n\n## 上下文建议器\n\n> [大佬](https://www.cnblogs.com/Neeo/articles/10695019.html)的博客\n\n> ES 的笔记暂时告一段落，有时间再继续补充...","tags":["elasticsearch","建议器"],"categories":["elasticsearch"]},{"title":"wordpress - 建站笔记","url":"/2021/08/f74f8050.html"},{"title":"ES 的分词器","url":"/2021/07/2ae040ce.html","content":"\n> ES 的分词器有很多，具体资料请具体查询，而中文分词其中，常用的就是 ik分词器\n\n<!-- more -->\n\n# ik分词器简介\n\nIK Analyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始， IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。\n\nIK Analyzer 2012特性:\n\n1. 采用了特有的“正向迭代最细粒度切分算法”，支持细粒度和智能分词两种切分模式；\n\n2. 在系统环境：Core2 i7 3.4G双核，4G内存，window 7 64位， Sun JDK 1.6_29 64位 普通pc环境测试，IK2012具有160万字/秒（3000KB/S）的高速处理能力。\n\n3. 2012版本的智能分词模式支持简单的分词排歧义处理和数量词合并输出。\n\n4. 采用了多子处理器分析模式，支持：英文字母、数字、中文词汇等分词处理，兼容韩文、日文字符\n5. 优化的词典存储，更小的内存占用。支持用户词典扩展定义。特别的，在2012版本，词典支持中文，英文，数字混合词语。\n\n> 摘自[ik google code](https://code.google.com/archive/p/ik-analyzer/)\n\n# ik 分词器安装\n\n前往 [github](https://github.com/medcl/elasticsearch-analysis-ik/releases/) 下载对应版本，一定要注意对应 ES 版本\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"ik分词器github下载页面\" src=\"https://i.loli.net/2021/08/04/71sgOEpYFwaR9LD.png\" style=\"width: 100%;\">\n</div>\n\n下载完成后解压到 ES 目录下的 `plugins` 目录，然后将文件夹重命名为 `ik`，然后重启 ES 即可\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"20210804114352\" src=\"https://i.loli.net/2021/08/04/23Eop5D1iFLTXwB.png\" style=\"width: 100%;\">\n</div>\n## 测试\n\nKibana 和 ES 启动后，使用 Kibana 中进行测试：\n\n```text\nGET _analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"上海自来水来自海上\"\n}\n```\n\n如果安装成功，即可显示分词结果，如果没有安装成功，则会抛异常：\n\n```text\n{\n  \"error\" : {\n    \"root_cause\" : [\n      {\n        \"type\" : \"illegal_argument_exception\",\n        \"reason\" : \"failed to find global analyzer [ik_max_word]\"\n      }\n    ],\n    \"type\" : \"illegal_argument_exception\",\n    \"reason\" : \"failed to find global analyzer [ik_max_word]\"\n  },\n  \"status\" : 400\n}\n```\n\n# ik分词器使用\n\n## 配置文件简介\n\n- `IKAnalyzer.cfg.xml`：用来配置自定义的词库\n- `main.dic`：ik原生内置的中文词库，大约有27万多条，只要是这些单词，都会被分在一起。\n- `surname.dic`：中国的姓氏。\n- `suffix.dic`：特殊（后缀）名词，例如`乡、江、所、省`等等。\n- `preposition.dic`：中文介词，例如`不、也、了、仍`等等。\n- `stopword.dic`：英文停用词库，例如`a、an、and、the`等。\n- `quantifier.dic`：单位名词，如`厘米、件、倍、像素`等。\n\n## 使用\n\n依旧使用测试中的例子：\n\n```text\nGET _analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"上海自来水来自海上\"\n}\n```\n\n其运行结果为：\n\n```text\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"上海\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"自来水\",\n      \"start_offset\" : 2,\n      \"end_offset\" : 5,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"自来\",\n      \"start_offset\" : 2,\n      \"end_offset\" : 4,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"水\",\n      \"start_offset\" : 4,\n      \"end_offset\" : 5,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"来自\",\n      \"start_offset\" : 5,\n      \"end_offset\" : 7,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"海上\",\n      \"start_offset\" : 7,\n      \"end_offset\" : 9,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 5\n    }\n  ]\n}\n```\n\n其尽可能的包含了 `上海自来水来自海上` 这句话的所有的分词结果。我们注意到，我们发送的 GET 请求设定的 `analyzer` 属性的值是：`ik_max_word`，那么，这是什么？\n\n### ik 分词器的分词模式\n\n> ik_max_word 就是 ik 分词器提供的一种分词模式，此外还有 ik_smart\n\n1. ik_max_word\n\n   此模式下会对字段值进行最细粒度的分词，会尽可能的分出所有的结果，见上面例子\n\n2. ik_smart\n\n   此模式下会对字段值进行粗粒度的分词：\n\n   ```text\n   GET _analyze\n   {\n     \"analyzer\": \"ik_smart\",\n     \"text\": \"上海自来水来自海上\"\n   }\n   ```\n\n   结果为：\n\n   ```text\n   {\n     \"tokens\" : [\n       {\n         \"token\" : \"上海\",\n         \"start_offset\" : 0,\n         \"end_offset\" : 2,\n         \"type\" : \"CN_WORD\",\n         \"position\" : 0\n       },\n       {\n         \"token\" : \"自来水\",\n         \"start_offset\" : 2,\n         \"end_offset\" : 5,\n         \"type\" : \"CN_WORD\",\n         \"position\" : 1\n       },\n       {\n         \"token\" : \"来自\",\n         \"start_offset\" : 5,\n         \"end_offset\" : 7,\n         \"type\" : \"CN_WORD\",\n         \"position\" : 2\n       },\n       {\n         \"token\" : \"海上\",\n         \"start_offset\" : 7,\n         \"end_offset\" : 9,\n         \"type\" : \"CN_WORD\",\n         \"position\" : 3\n       }\n     ]\n   }\n   ```\n\n从运行结果中可以轻易看出两种分词模式的区别\n\n# analyze 在哪里使用\n\n此属性声明了字段分词使用什么分词器，在定义 `mapping` 时，使用该字段即可：\n\n```text\nPUT iktest\n{\n  \"mappings\": {\n    \"dynamic\": false,\n    \"properties\": {\n      \"content\": {\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\"\n      }\n    }\n  }\n}\n```\n\n在查询时，也可以使用该字段声明使用哪个分词器对关键词分词：\n\n```test\nGET iktest/_search\n{\n  \"query\": {\n    \"match\": {\n      \"content\": {\n        \"query\": \"今天不\",\n        \"analyzer\": \"ik_max_word\"\n      }\n    }\n  }\n}\n```\n\n","tags":["elasticsearch","分词器"],"categories":["elasticsearch"]},{"title":"ES 的 mapping","url":"/2021/07/5b46e255.html","content":"\n# 映射 `mapping` \n\n## 是什么\n\n之前有提到过，`mapping` 可以理解为关系型数据库中的表，更像是列的描述(create table...)\n\n**所以，其本质上就是 ES 一个索引中的各种字段的定义(描述)**\n\n<!-- more -->\n\n## 映射类型\n\n每个索引都有一个映射类型，就算我们没有创建，ES 也会帮我们创建：\n\n```text\n{\n  \"test\" : {\n    \"mappings\" : {\n      \"properties\" : {\n        \"message\" : {\n          \"type\" : \"text\",\n          \"fields\" : {\n            \"keyword\" : {\n              \"type\" : \"keyword\",\n              \"ignore_above\" : 256\n            }\n          }\n        },\n        \"message1\" : {\n          \"type\" : \"text\",\n          \"fields\" : {\n            \"keyword\" : {\n              \"type\" : \"keyword\",\n              \"ignore_above\" : 256\n            }\n          }\n        },\n        \"phone\" : {\n          \"type\" : \"long\"\n        },\n        \"sendTime\" : {\n          \"type\" : \"text\",\n          \"fields\" : {\n            \"keyword\" : {\n              \"type\" : \"keyword\",\n              \"ignore_above\" : 256\n            }\n          }\n        },\n        \"uid\" : {\n          \"type\" : \"long\"\n        }\n      }\n    }\n  }\n}\n```\n\n### 映射类型有哪些\n\n* 元字段(meta-fields)：元字段用于自定义如何处理文档关联的元数据，包括文档的 `_index`、`_type`、`_id`和`_source` 等字段\n* 字段或属性(field or properties)：映射类型包含与文档相关的字段或者属性的列表\n\n### 字段的数据类型\n\n* 简单类型：文本 `text`、关键字 `keyword`、日期 `date`、整型 `long`、浮点型 `double`、布尔 `bool` 或 `ip`\n* 复杂类型：`properties` 是可以嵌套的\n\n* 特殊类型：`geo_point`、`geo_shape` 或 `completion`\n\n其中，`text` 类型可以被分词器分词\n\n## 映射约束\n\n映射中不适合定义太多的字段，因为可能会导致内存不足或者是难以恢复的情况\n\n* `index.mapping.total_fields.limit`：索引中的最大字段数。字段和对象映射以及字段别名都计入此限制。默认值为1000\n* `index.mapping.depth.limit`：字段的最大深度，因为 `properties` 是可以嵌套的，所以需要进行限制。默认值为20\n\n* `index.mapping.nested_fields.limit`：索引中嵌套字段的最大数量，默认为50。\n\n  > ps: 我没看懂这个……\n\n`nested` 的资料：[官方文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/nested-query.html)\n\n***\n\n一个简单的例子：\n\n```text\nPUT mapping_test1\n{\n  \"mappings\": {\n    \"properties\": {\n      \"name\": {\n        \"type\": \"text\"\n      },\n      \"age\": {\n        \"type\": \"long\"\n      }\n    }\n  }\n}\n```\n\n* 文档名默认为 `_doc`\n* 插入：`POST mapping_test1/_doc`\n\n# dynamic\n\n> `mapping` 可以分为动态映射（dynamic mapping）、静态|显示 映射（explicit mapping）和 精准|严格 映射（strict mapping），由 `dynamic` 属性控制\n\n我们做一个测试：\n\n```text\nPUT {index_name}\n{\n  \"mappings\": {\n    \"dynamic\": true,\n    \"properties\": {\n      \"name\": {\n        \"type\": \"text\"\n      },\n      \"age\": {\n        \"type\": \"long\"\n      }\n    }\n  }\n}\n```\n\n我们通过此映射创建索引，`dynamic` 属性分别为：true、false、strict，然后向里面添加数据\n\n```text\nPOST {index_name}/_doc\n{\n  \"name\": \"li lei\",\n  \"age\": 26,\n  \"sex\": \"man\"\n}\n```\n\n观察是什么结果，再通过 `sex` 字段查询数据，观察是什么结果\n\n## 动态映射——`dynamic: true`\n\n> 执行上面操作步骤之后，我们发现使用 `sex` 查询文档，是可以查出来的，查看索引的 mapping，会发现 `sex` 这个字段已经添加进去了\n\n动态映射意味着如果我们添加没有设置映射的字段，elasticsearch 会自动帮我们添加映射属性，这个同样是默认值\n\n需要注意的是，`mapping` 一旦创建，就无法修改了，因为 `Lucene` 生成倒排索引后就不能改了\n\n## 静态映射——`dynamic: false`\n\n> 执行上面操作步骤之后，我们发现使用 `sex` 查询文档，没有结果，查看索引的 mapping 时，里面并没有 sex 属性\n\n静态映射意味着 elasticsearch 不会帮我们添加映射属性，所以，也不能使用该属性查询文档，但是这个属性是可以帮我们存起来的\n\n## 严格映射——`dynamic: strict`\n\n> 执行上面步骤，在向索引中添加文档时，ES 会抛异常：\n>\n> ```text\n> {\n>   \"error\" : {\n>     \"root_cause\" : [\n>       {\n>         \"type\" : \"strict_dynamic_mapping_exception\",\n>         \"reason\" : \"mapping set to strict, dynamic introduction of [sex] within [_doc] is not allowed\"\n>       }\n>     ],\n>     \"type\" : \"strict_dynamic_mapping_exception\",\n>     \"reason\" : \"mapping set to strict, dynamic introduction of [sex] within [_doc] is not allowed\"\n>   },\n>   \"status\" : 400\n> }\n> ```\n\n严格映射意味着我们必须按照 mapping 文件添加文档，不可以增加字段\n\n# `mapping` 的其他属性\n\n## `copy_to`\n\n> 该属性允许我们将多个字段的值复制到组字段中，然后将组字段作为单个字段进行查询。\n\n```text\nPUT mapping_copy\n{\n  \"mappings\": {\n    \"properties\": {\n      \"first_name\": {\n        \"type\": \"text\",\n        \"copy_to\": \"full_name\"\n      },\n      \"last_name\": {\n        \"type\": \"text\",\n        \"copy_to\": \"full_name\"\n      },\n      \"full_name\": {\n        \"type\": \"text\"\n      }\n    }\n  }\n}\n```\n\n向索引中添加文档：\n\n```text\nPOST mapping_copy/_doc\n{\n  \"first_name\": \"Li\",\n  \"last_name\": \"Lei\"\n}\n```\n\n查询：\n\n```text\nGET mapping_copy/_search\n{\n  \"query\": {\n    \"match\": {\n      \"full_name\": {\n        \"query\": \"li lei\",\n        \"operator\": \"and\"\n      }\n    }\n  }\n}\n```\n\n## 对象属性\n\n> `properties` 是可以嵌套的，意味着我们可以创建复杂对象，但是怎么使用 对象的属性的属性 进行查询？\n\n```text\nPOST mapping_object/_doc\n{\n  \"name\": \"tom\",\n  \"age\": 18,\n  \"info\": {\n    \"tel\": \"10086\"\n  }\n}\n```\n\n查询：\n\n```text\nGET mapping_object/_search\n{\n  \"query\": {\n    \"match\": {\n      \"info.tel\": \"10086\"\n    }\n  }\n}\n```\n\n嗯，万物都可点出来……\n\n## `ignore_above`\n\n> 长度超过 `ignore_above` 设置的字符串不会被索引，对于字符串数组，该属性将分别应用于每个元素。默认值为 256\n>\n> 需要注意的是，此属性只对 `keyword` 类型的字段有效\n\n```text\nPUT mapping_ignore\n{\n  \"mappings\": {\n    \"properties\": {\n      \"name\": {\n        \"type\": \"keyword\",\n        \"ignore_above\": 10\n      }\n    }\n  }\n}\n```\n\n向索引中插入文档\n\n```text\nPOST mapping_ignore/_doc\n{\n  \"name\": \"sdfflshdilfaljsdljflajds\"\n}\n\nPOST mapping_ignore/_doc\n{\n  \"name\": \"aa0\"\n}\n```\n\n当我们查询第一个文档时，是查不出来的\n\n```text\nGET mapping_ignore/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"sdfflshdilfaljsdljflajds\"\n    }\n  }\n}\n```\n\n但是第二个时可以查到的，当我们查询所有文档时，第一个第二个都可以查到\n\n","tags":["elasticsearch的mapping","映射"],"categories":["elasticsearch"]},{"title":"pl/sql 笔记","url":"/2021/07/8e65df1b.html","content":"\n# 前言\n\n> PL/SQL 是一种高级数据库程序设计语言，该专门用于在各种环境下对 ORACLE 数据库进行访问 。由于该语言集成于数据库服务器中，所以 PL/SQL 代码可以对数据进行快速高效的处理。\n\n<!-- more -->\n\n## docker 安装 oracle\n\ndocker-compose.yml\n\n>  ps：我还没有找到可以用的，暂时先空着吧……\n\n# PL/SQL 概述\n\n## 简介\n\nPLSQL 是Oracle公司在SQL基础上进行扩展而成的一种过程语言。PLSQL提供了典型的高级语言特性，包括封装，例外处理机制，信息隐藏，面向对象等；并把最新的编程思想带到了数据库服务器和工具集中\n\n## 优势\n\n与使用**数据库连接**操作数据库相比，PLSQL的优势是：SQL语言可以直接写到PLSQL的“块”中或者是PLSQL的过程、函数中。没有必要先创建Statement对象来执行SQL; 这使得PLSQL成为很强大的事务处理语言，即：使用SQL来处理数据，使用控制结构来处理业务逻辑\n\n另外一个优势是：可以减轻数据库与应用来回交互的次数，从而节省网络资源\n\n# PL/SQL 语法\n\n> PL/SQL 中不区分大小写，但是建议关键字全部使用大写\n\n## PL/SQL 的 `块`\n\n> PL/SQL是一种类PASCAL语言，每一段程序都是由 **块(Block)** 组成的，而PL/SQL中的块都必须有开始和结尾(联想一下java、c中的函数体必须有大括号包裹)\n\nPL/SQL 中的块包含：匿名块、存储过程、函数\n\n1. 匿名块\n\n   ```sql\n   [DECLARE]\n     -- 变量声明部分\n   BEGIN\n     -- 语句执行部分\n   [EXCEPTION]\n     -- 异常处理部分\n   END;\n   ```\n\n2. 存储过程\n\n   ```sql\n   PROCEDURE procedure_name IS\n     -- 变量声明部分\n   BEGIN\n     -- 语句执行部分\n   [EXCEPTION]\n     -- 异常处理部分\n   END;\n   ```\n\n3. 函数\n\n   ```sql\n   FUNCTION func_name RETURN dateType IS\n     -- 变量声明\n   BEGIN\n     -- 执行语句\n     return value;\n   [EXCEPTION]\n     -- 异常处理部分\n   END;\n   ```\n\n**注意：**\n\n1. 在 pl/sql 中，sql 语句可以写一行，但是不方便阅读，所以并不推荐这样写\n2. pl/sql中的块是可以嵌套的，就像 java 中可以有内部类一样\n\n## PL/SQL 变量\n\n### PL/SQL 中的变量类型\n\n1. 简单变量类型：大多数数据库表的字段类型都可以作为简单变量类型\n2. 用户自定义的变量：简单变量类型的组合（类似于C语言中的结构体）\n3. 引用类型：指针\n4. 大对象类型(LOB)：保存了大对象的地址\n\n### PL/SQL 变量声明\n\n1. 语法\n\n   ```sql\n   -- identifier [CONSTANT] dataType [NOT NULL] [:= | DEFAULT expr]\n   DECLARE\n     v_hiredate DATE;\n     -- plsql 中使用 := 给变量赋值\n     v_dept_no NUMBER(4) NOT NULL := 10;\n     v_location VARCHAR(2) DEFAULT NULL;\n     c_con CONSTANT NUMBER := 1;\n   ```\n\n2. 说明\n\n   1. 变量命名建议遵循通用规则，如：`v_` 开头表示**变量**，`c_` 开头表示**常量**，`p_` 开头表示参数，`_couser` 结尾表示游标等……\n   2. 建议一行声明一个变量，便于阅读\n   3. 声明但是未初始化的变量的值为 **NULL**\n   4. 在同一个块中，要避免变量的命名与数据库表中的字段名相同\n\n### PL/SQL 中的table类型（类似于数组）\n\n语法：\n\n```sql\n-- 这种结构类似于数组，可以使用下标访问，INDEX BY BINARY_INTEGER 规定了下标的数据类型是 BINARY_INTEGER\nTYPE type_name IS TABLE OF data_type [NOT NULL] [INDEX BY BINARY_INTEGER];\n```\n\n如：\n\n```sql\ndeclare\n  type emp is table of number index by binary_integer;\n  v_emp emp;\nbegin\n  v_emp(-1) := -100;\n  v_emp(-20) := -200;\n  v_emp(0) := 0;\n  v_emp(1) := 100;\n  v_emp(56) := 5600;\n  v_emp(132) := 13200;\n  dbms_output.put_line(v_emp(132));\nend;\n```\n\ntable 类型的下标可以是负数，但是不可以使用 for 循环遍历\n\n### PL/SQL 自定义变量类型（记录-record）\n\n语法：\n\n```sql\nTYPE type_name IS RECORD (\n  field1_name field1_type,\n  field2_name field2_type\n);\nidentifier type_name;\n```\n\n如：\n\n```sql\nTYPE emp_record_type IS RECORD (\n  last_name VARCHAR2(25),\n  job_id VARCHAR2(10) := 'hello',\n  salary NUMBER(8,2)\n); \nemp_record emp_record_type;\n```\n\n这个可以理解为 C 语言中的结构体\n\n### PL/SQL 特有的声明变量类型的方式\n\n1. `%TYPE`：用来声明与某变量类型一致\n\n   ```sql\n   -- identifier Table.column_name%TYPPE;\n     v_name employees.last_name%TYPE;\n   ```\n\n2. `%ROWTYPE`：用来声明与数据库表中一行数据的类型一致\n\n   ```sql\n   -- identifier table_name%ROWTYPE;\n     v_employee employees%ROWTYPE;\n   ```\n\n## PL/SQL 命令行输出\n\n> DBMS_OUTPUT.PUT_LINE()\n\n例子：\n\n```sql\nDECLARE\n  -- &p_annual_sal 表示 p_annual_sal 是需要用户从外界输入的\n  v_sal NUMBER(9,2) := &p_annual_sal;\nBEGIN\n  v_sal := v_sal/12;\n  -- plsql 中 || 用来连接字符串\n  DBMS_OUTPUT.PUT_LINE ('The monthly salary is '||TO_CHAR(v_sal));\nEND;\n```\n\n## PL/SQL 注释\n\n1. 单行注释\n\n   ```sql\n   -- 注释内容\n   ```\n\n2. 多行注释\n\n   ```sql\n   /*\n    多行注释\n    */\n   ```\n\n## PL/SQL 变量作用域\n\n> 与其他编程语言一样，plsql的变量也是有作用域的，变量只在**当前作用域(块)**中可以被访问，而在块中寻找变量时，同样遵循**就近原则**\n\n```sql\nBEGIN\n\t-- 这种写法是标签，也可以理解为 C++ 里面的标签(label)\n    <<OUTER>>\n    DECLARE\n        v_number number;\n    BEGIN\n        DECLARE\n            v_number number;\n        BEGIN\n            OUTER.v_number := 200;\n        END;\n        -- DBMS_OUTPUT.put_line 是向控制台打印的函数\n        -- 在 sql plus 中，需要设置：SET SERVEROUTPUT ON\n        DBMS_OUTPUT.put_line('v_hire_date: ' || v_number);\n    END;\nEND;\n```\n\n注意第9行代码，如果不写 `OUTER`，程序会给第7行的变量赋值，加上 `OUTER` 之后，程序会给第4行的变量赋值\n\n## PL/SQL中的sql语句\n\n### select into\n\n> 用于把从数据库查处的内容存入变量\n\n```sql\ndeclare\n  v_sum_sal NUMBER(10,2);\n  v_deptno NUMBER NOT NULL := 60;\nBEGIN\n  SELECT SUM(salary)\n  INTO v_sum_sal\n  FROM employees\n  WHERE department_id = v_deptno;\n  DBMS_OUTPUT.PUT_LINE ('The sum salary is ' || TO_CHAR(v_sum_sal));\nEND;\n```\n\n**注意**：该语句仅支持查询出一条结果进行赋值，如果查询出多条结果将会抛 `Too_many_rows` 错误\n\n### 其他语句：insert、update、delete、merge\n\n> 这些语句和平时执行时差不多，只不过是可以使用 pl/sql 中定义的变量了\n\n```sql\nDECLARE\n  v_empno employees.employee_id%TYPE := 100;\nBEGIN\n  -- merge 可以用来执行符合某种条件应该执行的语句\n  MERGE INTO copy_emp c -- 目标表\n  USING employees e -- 源表\n    ON (e.employee_id = v_empno) -- 声明条件\n  WHEN MATCHED THEN -- 条件满足时\n    UPDATE SET\n      c.first_name = e.first_name,\n      c.last_name = e.last_name,\n      c.email = e.email\n      -- ...\n  WHEN NOT MATCHED THEN -- 条件不满足时\n    INSERT VALUES(e.employee_id, e.first_name, e.last_name, e.department_id);\n  -- merge 会基于源表对目标表做 insert、update、delete 操作，所以一般用于数据同步、数据转换\nEND;\n```\n\n## PL/SQL 流程控制\n\n### 条件\n\n1. if-else\n\n   ```sql\n   IF condition THEN\n     statements;\n   [ELSIF condition THEN\n     statements;]\n   [ELSE\n     statements;]\n   END IF;\n   ```\n\n   类似于 Java 的if\n\n2. case-when\n\n   ```sql\n   CASE selector\n     WHEN expression1 THEN result1;\n     WHEN expression2 THEN result2;\n     WHEN expression3 THEN result3;\n     ...\n     WHEN expressionN THEN resultN;\n     [ELSE resultN +1;]\n   END;\n   ```\n\n   类似于 Java 中的 switch\n\n3. 需要注意对 null 的处理\n\n   ```sql\n   NULL and NULL = NULL\n   NULL and TRUE = NULL\n   NULL and FALSE = FALSE\n   NULL or NULL = NULL\n   NULL or TRUE = TRUE\n   NULL or FALSE = NULL\n   not NULL = NULL\n   ```\n\n### 循环\n\n1. 基本循环\n\n   ```sql\n   LOOP \n     statement 1;\n     ...\n     EXIT [WHEN codition]\n   END LOOP;\n   ```\n\n2. while\n\n   ```sql\n   WHILE condition LOOP\n     statement1;\n     ...\n   END LOOP;\n   ```\n\n3. for\n\n   ```sql\n   FOR counter in [RESERVE] lower_bound..upper_bound|iterator LOOP\n     statement1;\n     ...\n   END LOOP;\n   ```\n\n## PL/SQL中的游标\n\n> 游标是一个私有的SQL工作区域，Oracle数据库中有两种游标，分别是隐式游标和显式游标，隐式游标不易被用户和程序员察觉和意识到，实际上Oracle服务器使用隐式游标来解析和执行我们提交的SQL 语句；而显式游标是程序员在程序中显式声明的；通常我们说的游标均指显式游标\n\n### 隐式游标的几个属性\n\n* SQL%ROWCOUNT：sql操作影响的行数\n* SQL%FOUND：游标是否还有数据\n* SQL%NOTFOUNT：游标是否没有数据\n\n* SQL%ISOPEN：隐式游标该属性永远是 false\n\n### 显式游标\n\n> 对于返回多行结果的SQL语句的返回结果，可使用显式游标独立的处理器中每一行的数据。\n>\n> **游标需要先声明再使用**\n\n1. 显式游标一般的处理流程\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n     <img alt=\"显式游标的使用过程\" src=\"https://i.loli.net/2021/07/13/9azHtNi2nQsbkjW.png\" style=\"width: 100%;\">\n   </div>\n   \n   ```sql\n   DECLARE\n     CURSOR emp_cursor IS (SELECT * FROM test_demo_employee);\n     v_emp test_demo_employee%ROWTYPE;\n   BEGIN\n     OPEN emp_cursor;\n     LOOP\n       FETCH emp_cursor into v_emp;\n       EXIT WHEN emp_cursor%NOTFOUND;\n       dbms_output.put_line(v_emp.employee_id || '-' || v_emp.employee_name || ', ');\n     END LOOP;\n     CLOSE emp_cursor;\n   END;\n   ```\n   \n2. 显式游标的for循环\n\n   > for 循环可以省去游标的 open、close、fetch 和判断 NOTFOUND 的操作\n\n   ```sql\n   DECLARE\n     CURSOR emp_cursor IS (SELECT * FROM test_demo_employee);\n   BEGIN\n     FOR v_emp in emp_cursor LOOP\n       dbms_output.put_line(v_emp.employee_id || '-' || v_emp.employee_name || ', ');\n     END LOOP;\n   END;\n   ----------demo2----------------\n   BEGIN\n     FOR v_emp in (SELECT * FROM test_demo_employee) LOOP\n       dbms_output.put_line(v_emp.employee_id || '-' || v_emp.employee_name || ', ');\n     END LOOP;\n   END;\n   ```\n\n3. 游标的参数\n\n   > 游标是可以带有参数的，因为查询时也有条件啊\n\n   ```sql\n   -- 语法\n   -- CURSOR cursor_name [(param_name data_type, param_name data_type...)] \n   --   IS select_statemant;\n   DECLARE\n     CURSOR emp_cursor(dept_id NUMBER) IS \n       (SELECT * FROM test_demo_employee \n          -- FOR UPDATE [OF column_reference] [NOWAIT] 是为了给查询出来的行加锁\n          -- NOEAIT可以避免死锁\n          WHERE department_id = dept_id FOR UPDATE NOWAIT);\n   BEGIN\n     FOR v_emp in emp_cursor(3) LOOP\n       dbms_output.put_line(v_emp.employee_id || '-' || v_emp.employee_name || ', ');\n     END LOOP;\n   end;\n   ```\n\n4. WHERE CURRENT OF cursor\n\n   > WHERE CURRENT OF cursor 用于锁定是哪条记录，可用于更新和删除，需要注意的是此写法不可以用于参数 游标\n\n   ```sql\n   DECLARE\n     CURSOR emp_cursor IS \n       SELECT * FROM test_demo_employee FOR UPDATE NOWAIT;\n   BEGIN\n     FOR v_emp in emp_cursor LOOP\n       IF v_emp.employee_name like '%a%' THEN\n         UPDATE test_demo_employee SET email = email + '.oo' \n         WHERE CURRENT OF emp_cursor;\n       END IF;\n     END LOOP;\n   end;\n   ```\n\n## PL/SQL 例外(类似于 Java 的异常)\n\n### 例外的分类\n\nOracle 中的例外一般有两种\n\n1. Oracle 内部错误抛出的例外：这又分为预定义例外（有错误号+常量定义） 和 非预定义例外（仅有错误号，无常量定义）\n\n   oracle 预定义的常见例外可以参考大佬的博客：[https://blog.csdn.net/lord_is_layuping/article/details/5509477](https://blog.csdn.net/lord_is_layuping/article/details/5509477)\n\n2. 程序员显式的抛出的例外\n\n### 例外捕获和传递\n\n与其他语言类似，如果例外在当前块中被处理，则到此为止，否则会被传递到外层（外层BLOCK或者外层调用者函数）\n\n### 例外捕获的语法\n\n```sql\nEXCEPTION\n  WHEN exception1 [OR exception2 . . .] THEN\n    statement1;\n    statement2;\n    . . .\n  [WHEN exception3 [OR exception4 . . .] THEN\n    statement1;\n    statement2;\n    . . .]\n  -- OTHERS 必须放在最后\n  [WHEN OTHERS THEN\n    statement1;\n    statement2;\n    . . .]\n```\n\n* **others** 的处理\n\n  > Others表明我们程序员未能预计到这种错误\n\n  Oracle 提供了两个内置函数 `SQLCODE` 和 `SQLERRM` 分别用来返回Oracle 错误号和错误描述\n\n### 例外处理\n\n> 例外处理流程：声明部分：声明；程序执行部分：抛出例外；例外处理部分：处理例外；\n\n```sql\nDECLARE\n  -- 声明例外\n  e_invalid_department EXCEPTION;\nBEGIN\n  UPDATE departments\n    SET department_name = &p_department_desc\n    WHERE department_id = &p_department_number;\n  IF SQL%NOTFOUND THEN\n    -- 抛出例外\n    RAISE e_invalid_department;\n  END IF;\n  COMMIT;\nEXCEPTION\n  -- 处理例外\n  WHEN e_invalid_department THEN\n    DBMS_OUTPUT.PUT_LINE('No such department id.');\nEND;\n```\n\n### RAISE_APPLICATION_ERROR() 函数\n\n> 对于用户自定义的业务错误，也可以简单的使用 raise_application_error() 抛出例外。它无需预先定义错误，在需要抛出错误的地方直接使用此函数抛出例外即可，例外可以包含用户自定义的错误码和错误描述\n\n```sql\nDECLARE\n  CURSOR emp_cursor IS SELECT * FROM test_demo_employee;\nBEGIN\n  FOR v_emp in emp_cursor LOOP\n    IF v_emp.employee_name like '%a%' THEN\n      -- 错误码是有范围的：[-20000, -20999]\n      raise_application_error(-20006, 'raise_application_error 函数抛出例外');\n    END IF;\n  END LOOP;\nend;\n```\n\n## PL/SQL 的存储过程和函数\n\n### 存储过程\n\n1. 语法：\n\n   ```sql\n   CREATE [OR REPLACE] PROCEDURE procedure_name[(\n       parameter1 [mode1] datatype1,\n       parameter2 [mode2] datatype2,\n       . . .)]\n     IS|AS\n       PL/SQL Block;\n   ```\n\n   如：\n\n   ```sql\n   CREATE OR REPLACE PROCEDURE raise_salary(p_id IN employees.employee_id%TYPE)\n     IS\n   BEGIN\n     UPDATE employees\n       SET salary = salary * 1.10\n       WHERE employee_id = p_id;\n   END raise_salary;\n   ```\n\n2. 参数的模式\n\n   | IN                           | OUT                          | IN OUT                             |\n   | ---------------------------- | ---------------------------- | ---------------------------------- |\n   | 默认模式（不指定默认就是IN） | 必须显式指定                 | 必须显式指定                       |\n   | 用于把值传递给过程           | 用于把值从过程返回给调用环境 | 用于把值传递给过程并返回给调用环境 |\n   | 参数可以是常量、变量、表达式 | 必须是变量                   | 必须是变量                         |\n   | 可以赋默认值                 | 不可以赋默认值               | 不可以赋默认值                     |\n\n   如：\n\n   ```sql\n   CREATE OR REPLACE PROCEDURE query_emp(\n       p_id IN test_demo_employee.employee_id%TYPE,\n       p_name OUT test_demo_employee.employee_name%TYPE,\n       p_email OUT test_demo_employee.email%TYPE)\n     IS\n   BEGIN\n     SELECT employee_name, email\n       INTO p_name, p_email\n       FROM test_demo_employee\n       WHERE employee_id = p_id;\n   END query_emp;\n   ```\n\n3. 参数的传递方式\n\n   > 按顺序传递 或者 使用 `=>` 传递\n\n   ```sql\n   -- 调用上面存储过程\n   DECLARE\n     p_name test_demo_employee.employee_name%type;\n     p_email test_demo_employee.email%type;\n   BEGIN\n     query_emp(\n       p_id => '5',\n       p_name => p_name,\n       p_email => p_email\n     );\n     dbms_output.put_line(p_name || '-' || p_email);\n   END;\n   ```\n\n4. 删除存储过程\n\n   ```sql\n   drop procedure procedure_name;\n   ```\n\n### 函数\n\n1. 语法：\n\n   ```sql\n   CREATE [OR REPLACE] FUNCTION function_name[(\n       parameter1 [mode1] datatype1,\n   \tparameter2 [mode2] datatype2,\n   \t. . .)]\n     RETURN datatype\n   IS|AS\n     PL/SQL Block;\n   ```\n\n   * 与存储过程的差异在于函数有返回值了\n\n2. 在哪里可以使用：\n\n   * select 语句\n   * where 条件和 having 子句\n   * connect by、start with、order by 和 group by 子句\n   * insert 的 values 子句\n   * update 的 set 子句\n   \n3. 在 sql 中使用自定义函数的限制\n\n   1. 必须是个函数（Function）\n   2. 只能使用 IN 模式的参数\n   3. 只能接收 SQL 数据类型的参数，不能接收 PL/SQL 中特有类型的参数（record、table...）\n   4. 函数返回的数据必须是 SQL 类型的数据\n   5. 在 SQL 语句中使用的函数，不能有 DML 语句\n   6. 在 UPDATE/DELETE 中使用的函数，其内部不能有针对该表的查询语句\n   7. 在 SQL 中调用的函数，其函数体内不能有结束事务的语句：commit、rollback\n\n4. 删除存储函数\n\n   ```sql\n   DROP FUNCTION function_name;\n   ```\n\n## PL/SQL 的包\n\n> 按照业务逻辑、把相关的Func , Procedure 组织到一起，形成一个函数或者过程集合\n\n### 语法\n\n1. pl/sql 的包分为包头和包体：类似于 java 中的**接口**和**实现类**、C 中的**头文件**和 **`.c` 文件**\n\n2. sql语法\n\n   ```sql\n   -- 创建包头\n   CREATE [OR REPLACE] PACKAGE package_name AS\n     -- 函数或过程声明\n   END package_name;\n   \n   -- 创建包体\n   CREATE [OR REPLACE] PACKAGE BODY package_name AS\n     -- 函数或过程实现\n   END package_name;\n   \n   -- 删除包头和包体\n   DROP PACKAGE package_name;\n   \n   -- 仅删除包体\n   DROP PACKAGE BODY package_name;\n   ```\n\n3. package 中被调用到的函数需要更早的声明\n\n# Oracle 大对象操作\n\n> LOB：大对象类型，用于存储非结构化的大数据，比如大文本、图片、电影、音乐等\n\n## LOB 介绍\n\n1. 类型：Oracle数据库里面的LOB有四种类型\n\n   1. CLOB ：字符大对象，存储在数据库内部\n   2. NCLOB：多字节字符大对象，存储在数据库内部\n   3. BLOB：二进制大对象，存储在数据库内部\n   4. BFILE：二进制文件，存储在数据库外部\n\n2. 存储方式\n\n   LOB 分为 Value 和 Locator 两部分，Locator 存储在数据库表中\n\n   Value由其内外部类型和大小决定存储位置：\n\n   * 默认情况下，内部LOB小于4000字节会被存储在同一行上，超过部分则会存储在数据库内部的其他地方，由Oracle数据库管理\n\n## LOB 操作\n\n### 内部 LOB\n\n操作步骤\n\n1. 在表中添加LOB类型的列\n2. 在程序中声明和初始化LOB的Locator\n3. 使用 SELECT FOR UPDATE 锁定目标行，准备更新行上的LOB列（LOB的Locator）\n4. 生成LOB对象，可使用DBMS_LOB 这样的PLSQL包，也可以使用OCI,JDBC等\n5. Commit 提交更改\n\n### 外部 LOB（Bfile）\n\n> Bfile 是数据库外部文件，在数据库表上这种类型的字段实际只是存储一个 Locator\n\n1. Bfile 使用限制：\n\n   * Bfile是数据库外部文件，是只读的，所以不参与事务操作；用户必须先创建文件并放到特定的目录下，给予Oracle进程该目录和文件的读取权限\n   * 在Oracle 中删除Bfile这样的LOB数据的时候，它并没有实际的去删除对应的操作系统上的文件，实际文件的删除是DBA(系统管理员)的工作，Bfile的大小限制取决于操作系统，不受Oracle限制\n\n2. Oracle Directory\n\n   在Oracle 内部创建的 Directory 默认的所有者是sys, 并由DBA( 或者是另一个拥有 CREATE ANY DIRECTORY 权限的用户)创建；Directory 对象可以像表那样给其他用户赋权\n\n3. Bfile 使用步骤\n\n   1. 在操作系统上创建目录，并给Oracle数据库进程赋予阅读权限，把外部文件放入这个目录\n\n   2. 在Oracle数据库中表添加Bfile类型字段\n\n      ```sql\n      ALTER TABLE employees ADD emp_video BFILE;\n      ```\n\n   3. 在Oracle 数据库中创建Directory 对象\n\n      ```sql\n      CREATE DIRECTORY dir_name AS os_path;\n      ```\n\n   4. 授权读权限给特定的数据库用户\n\n      ```sql\n      GRANT READ ON DIRECTORY dir_name TO user|role|PUBLIC;\n      ```\n\n   5. 往表中插入数据时使用 BFILENAME 函数，它可以关联外部文件和表上的Bfile列\n\n      ```sql\n      -- FUNCTION BFILENAME (directory_alias IN VARCHAR2, filename IN VARCHAR2)\n      --   RETURN BFILE;\n      UPDATE employees\n      SET emp_video = BFILENAME('LOG_FILES', 'King.avi')\n      WHERE employee_id = 100;\n      ```\n\n   6. 在程序中声明和初始化LOB的Locator\n\n   7. Select 指定行上 Bfile 列 到Locator\n\n   8. 使用 DBMS_LOB 或者通过 OCI 读取Bfile (使用Locator作为文件的一个引用）\n\n# PL/SQL 内置工具包\n\n## 动态SQL\n\n> 动态 sql 实现了 plsql 程序运行期间执行自定义 sql 的能力\n\n动态 SQL 可以使用 Oracle 的内置包 `DBMS_SQL` 来执行，也可以使用 `EXECUTE IMMEDIATE` 语句执行\n\n1. DMSL_SQL\n\n   ```sql\n   CREATE OR REPLACE PROCEDURE delete_all_rows (\n       p_tab_name IN VARCHAR2, p_rows_del OUT NUMBER\n   ) IS\n       cursor_name INTEGER;\n   BEGIN\n       cursor_name := DBMS_SQL.OPEN_CURSOR;\n       DBMS_SQL.PARSE(cursor_name, 'DELETE FROM '||p_tab_name, DBMS_SQL.NATIVE );\n       p_rows_del := DBMS_SQL.EXECUTE (cursor_name);\n       DBMS_SQL.CLOSE_CURSOR(cursor_name);\n   END;\n   ```\n\n2. EXECUTE IMMEDIATE\n\n   ```sql\n   CREATE PROCEDURE del_rows (\n       p_table_name IN VARCHAR2,\n   \tp_rows_deld OUT NUMBER\n   ) IS\n   BEGIN\n       EXECUTE IMMEDIATE 'delete from '||p_table_name;\n       p_rows_deld := SQL%ROWCOUNT;\n   END;\n   ```\n\n3. 在程序中执行 DDL\n\n   > 在程序中执行DDL,可使用Oracle 内置包：DBMS_DDL\n\n   ```sql\n   -- 在程序中执行编译命令\n   DBMS_DDL.ALTER_COMPILE('PROCEDURE','A_USER','QUERY_EMP')\n   \n   -- 在程序中执行数据收集命令\n   DBMS_DDL.ANALYZE_OBJECT('TABLE','A_USER','JOBS','COMPUTE')\n   ```\n\n   详情请看官方文档：[https://docs.oracle.com/database/121/ARPLS/d_ddl.htm#ARPLS66079](https://docs.oracle.com/database/121/ARPLS/d_ddl.htm#ARPLS66079)\n\n## 定时 - JOB\n\n> JOB 可以定期执行某个程序，Oracle 提供内置包 DBMS_JOB，可完成 JOB 的定义、提交、更改、停止、移除\n\n1. 应用场景\n\n   * 每隔一周对某些表进行数据收集，以确保CBO正确\n   * 在消息处理机制中，每隔5分钟对消息队列进行扫描处理\n   * ...\n\n2. 例子\n\n   ```sql\n   DECLARE\n     jobno NUMBER;\n   BEGIN\n     DBMS_JOB.SUBMIT (\n       -- job编号，由 oracle 返回。范围为1～32767。当使用select调用dbms.submit时，该参数可以省略。\n       job => jobno,\n       -- job 做什么\n       what => 'OVER_PACK.ADD_DEPT(''EDUCATION'',2710);',\n       -- 什么时候做\n       next_date => TRUNC(SYSDATE + 1),\n       -- 执行间隔\n       interval => 'TRUNC(SYSDATE + 1)'\n     );\n     dbms_output.put_line(„job_no =„ || jobno )\n     COMMIT;\n   END;\n   ```\n\n   详情看：\n\n   1. 官网：[https://docs.oracle.com/database/121/ARPLS/d_job.htm#ARPLS66560](https://docs.oracle.com/database/121/ARPLS/d_job.htm#ARPLS66560)\n   2. 华为云文档：[https://support.huaweicloud.com/devg-dws/dws_04_0399.html](https://support.huaweicloud.com/devg-dws/dws_04_0399.html)\n\n# 数据库触发器\n\n> 对数据库的操作有很多特殊的时间点，如：before Insert、before update 等，在这些时间点，我们可以做一下操作，这些操作就被称为**触发器(Trigger)**\n\n**尽量不要添加触发器，会使数据库的维护变得困难**\n\n## 语法\n\n```sql\ncreate [or replace] trigger trigger_name timing trigger_event\non table_name\n    [for each row]\nbegin\n    -- pl/sql语句\nend\n```\n\n1. 触发时间(trigger_name)\n\n   after 和 before\n\n2. 触发事件(trigger_event)\n\n   insert、update、delete\n\n3. `for each row`\n\n   * 加上之后表明此触发器是行级，sql 每操作一行相关联记录就触发一次\n   * 不加的话表明此触发器是语句级，只会在 sql 操作的指定触发时间触发一次\n\n# 数据库对象的依赖关系\n\n数据库里面有些对象的定义是依赖于其他对象的，比如View 依赖于Table , Procedure 中有Select 其他Table或者视图的语句，可能依赖于Table 或者视图； 在这里View 或者 Procedure就被称为依赖对象，而table则被称为引用对象。\n当引用对象发生定义变更的时候，会导致其**依赖对象失效**，需要**重新编译**。\n\n# Oracle 单行函数\n\n> 仅列出常用函数\n\n## 字符函数\n\n| 函数                     | 说明                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| ASCII(X)                 | 返回字符X的ASCII码                                           |\n| CHR(X)                   | 根据ASCII码返回对应的字符                                    |\n| CONCAT(X,Y)              | 连接字符串X和Y                                               |\n| INSTR(X,STR[,START][,N)  | 从X中查找str，可以指定从start开始，也可以指定从n开始         |\n| LENGTH(X)                | 返回X的长度                                                  |\n| LPAD(STR, LEN, STR1)     | 在STR左边填充STR1，直到填充后的字符串长度为LEN               |\n| RPAD(STR, LEN, STR1)     | 在STR右边填充STR1，直到填充后的字符串长度为LEN               |\n| LOWER(X)                 | X转换成小写                                                  |\n| UPPER(X)                 | X转换成大写                                                  |\n| LTRIM(X[,TRIM_STR])      | 把X的左边截去trim_str字符串，缺省截去空格                    |\n| RTRIM(X[,TRIM_STR])      | 把X的右边截去trim_str字符串，缺省截去空格                    |\n| TRIM([TRIM_STR  FROM]X)  | 把X的两边截去trim_str字符串，缺省截去空格                    |\n| REPLACE(X,old,new)       | 在X中查找old，并替换成new                                    |\n| SUBSTR(X,start[,length]) | 返回X的字串，从start处开始，截取length个字符，缺省length，默认到结尾 |\n\n`DECODE`：类似与 case-end|switch 结构\n\n```sql\nSELECT sname, DECODE(ssex,'m','男','f','女')  as  ssex\nFROM t_student;\n```\n\n## 数字函数\n\n| 函数         | 说明                | 示例                    |\n| ------------ | ------------------- | ----------------------- |\n| ABS(X)       | X的绝对值           | ABS(-3)=3               |\n| ACOS(X)      | X的反余弦           | ACOS(1)=0               |\n| COS(X)       | 余弦                | COS(1)=0.54030230586814 |\n| CEIL(X)      | 大于或等于X的最小值 | CEIL(5.4)=6             |\n| FLOOR(X)     | 小于或等于X的最大值 | FLOOR(5.8)=5            |\n| LOG(X,Y)     | X为底Y的对数        | LOG(2, 4)=2             |\n| MOD(X,Y)     | X除以Y的余数        | MOD(8, 3)=2             |\n| POWER(X,Y)   | X的Y次幂            | POWER(2, 3)=8           |\n| ROUND(X[,Y]) | X在第Y位四舍五入    | ROUND(3.456, 2)=3.46    |\n| SQRT(X)      | X的平方根           | SQRT(4)=2               |\n| TRUNC(X[,Y]) | X在第Y位截断        | TRUNC(3.456, 2)=3.45    |\n\n ## 日期函数\n\n1. ADD_MONTHS(d,n)\n\n   在某一个日期 d 上，加上指定的月数 n，返回计算后的新日期\n\n   ```sql\n   SELECT SYSDATE,add_months(SYSDATE,5) FROM dual;\n   ```\n\n2. LAST_DAY(d)\n\n   返回指定日期当月的最后一天\n\n   ```sql\n   SELECT SYSDATE,last_day(SYSDATE) FROM dual;\n   ```\n\n3. ROUND(d[,fmt])\n\n   返回一个以 fmt 为格式的四舍五入日期值，d 是日期，fmt 是格式\n\n   模型：默认 fmt 为 DDD，即月中的某一天\n\n   * 如果 fmt 为“YEAR”则舍入到某年的 1 月 1 日，即前半年舍去，后半年作为下一年\n   * 如果 fmt 为“MONTH”则舍入到某月的 1 日，即前月舍去，后半月作为下一月\n   * 默认为“DDD”，即月中的某一天，最靠近的天，前半天舍去，后半天作为第二天\n   * 如果 fmt 为“DAY”则舍入到最近的周的周日，即上半周舍去，下半周作为下一周周日\n\n   ```sql\n   SELECT SYSDATE,ROUND(SYSDATE),ROUND(SYSDATE,'day')\n   ```\n\n4. EXTRACT(fmt FROM d)\n\n   提取日期中的特定部分\n\n   fmt 为：YEAR、MONTH、DAY、HOUR、MINUTE、SECOND。其中 YEAR、MONTH、DAY可以为 DATE 类型匹配，也可以与 TIMESTAMP 类型匹配；但是 HOUR、MINUTE、SECOND 必须与 TIMESTAMP 类型匹配\n\n   HOUR 有时区的区分\n\n   ```sql\n   SELECT SYSDATE \"date\",\n          EXTRACT(YEAR FROM SYSDATE)\"year\",\n          EXTRACT(MONTH FROM SYSDATE)\"month\",\n          EXTRACT(DAY FROM SYSDATE)\"day\",\n          EXTRACT(HOUR FROM SYSTIMESTAMP)\"hour\",\n          EXTRACT(MINUTE FROM SYSTIMESTAMP)\"minute\",\n          EXTRACT(SECOND FROM SYSTIMESTAMP)\"second\"\n   ```\n\n   \n\n## 转换函数\n\n1. TO_CHAR(d|n[,fmt])\n\n   把日期和数字转换为制定格式的字符串。Fmt是格式化字符串\n\n   日期格式：\n\n   | 参数 | 说明           |\n   | ---- | -------------- |\n   | yyyy | 年             |\n   | mm   | 月             |\n   | dd   | 日             |\n   | day  | 星期几         |\n   | hh24 | 24小时格式：时 |\n   | hh   | 12小时格式：时 |\n   | mi   | 分             |\n   | ss   | 秒             |\n\n   数字格式：\n\n   | 参数 | 示例     | 说明                             |\n   | ---- | -------- | -------------------------------- |\n   | 9    | 999      | 指定位置处显示数字               |\n   | .    | 9.9      | 指定位置返回小数点               |\n   | ,    | 99,99    | 指定位置返回一个逗号             |\n   | $    | $999     | 数字开头返回一个美元符号         |\n   | EEEE | 9.99EEEE | 科学计数法表示                   |\n   | L    | L999     | 数字前加一个本地货币符号         |\n   | PR   | 999PR    | 如果数字式负数则用尖括号进行表示 |\n\n2. TO_DATE(X,[,fmt])\n\n   把一个字符串以fmt格式转换成一个日期类型\n\n3. TO_NUMBER(X,[,fmt])\n\n   把一个字符串以fmt格式转换为一个数字\n\n## 其他函数\n\n1. NVL(X,VALUE)：如果X为空，返回value，否则返回X\n2. NVL2(x,value1,value2)：如果x非空，返回value1，否则返回value2（想一下三元表达式~）\n3. NULLIF(表达式1, 表达式2)：如果表达式1和表达式2相等则返回空值，如果表达式1和表达式2不相等则返回表达式1的结果\n\n## 聚合函数\n\n| 名称     | 作用           | 语法                     |\n| -------- | -------------- | ------------------------ |\n| AVG      | 平均值         | AVG（表达式）            |\n| SUM      | 求和           | SUM(表达式)              |\n| MIN、MAX | 最小值、最大值 | MIN(表达式)、MAX(表达式) |\n| COUNT    | 数据统计       | COUNT（表达式）          |\n\n","tags":["pl/sql","存储过程"],"categories":["pl/sql"]},{"title":"ES 的查询","url":"/2021/06/5377447a.html","content":"\n> ES 提供了两种查询方式\n> 1. 查询字符串(query string)：简单查询，就像使用传递url参数一样的传递查询参数。被称为**简单查询**或**查询字符串(query string)**方式搜索\n> 2. **DSL(domain specific language)查询**：领域专用语言，是 ES 提供的一种丰富且灵活的查询语言。该语言使用 json 请求体传递参数，通过 RESTful 请求与 ES 进行交互\n\n<!-- more -->\n\n# 准备数据\n\n```text\nPUT test/users/1\n{\n  \"uid\": 10001,\n  \"phone\": 13133334445,\n  \"message\": \"red oka!\",\n  \"sendTime\": \"2021-06-09 16:47:47\"\n}\n\nPUT test/users/2\n{\n  \"uid\": 10002,\n  \"phone\": 13133334545,\n  \"message\": \"sweet oka\",\n  \"sendTime\": \"2021-06-07 16:47:47\"\n}\n\nPUT test/users/3\n{\n  \"uid\": 10003,\n  \"phone\": 13133335445,\n  \"message\": \"niubility cat\",\n  \"sendTime\": \"2021-06-21 16:47:47\"\n}\n\nPUT test/users/4\n{\n  \"uid\": 10004,\n  \"phone\": 13133334455,\n  \"message\": \"fat cat\",\n  \"sendTime\": \"2021-06-13 16:47:47\"\n}\n\nPUT test/users/5\n{\n  \"uid\": 10005,\n  \"phone\": 13133334555,\n  \"message\": \"fat dog\",\n  \"sendTime\": \"2021-06-19 16:47:47\"\n}\n```\n\n# 查询字符串\n\n```text\nGET test/users/_search?q=message:chaim\n```\n\n对于查询，我们需要通过 `GET` 操作，使用 `_search` 来查询，查询条件就是 `message:chaim`\n\n```text\n{\n  \"took\" : 13,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 5,\n    \"successful\" : 5,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : 2,\n    \"max_score\" : 0.6931472,\n    \"hits\" : [\n      {\n        \"_index\" : \"test\",\n        \"_type\" : \"users\",\n        \"_id\" : \"4\",\n        \"_score\" : 0.6931472,\n        \"_source\" : {\n          \"uid\" : 10004,\n          \"phone\" : 13133334455,\n          \"message\" : \"chaim\",\n          \"sendTime\" : \"2021-06-13 16:47:47\"\n        }\n      },\n      {\n        \"_index\" : \"test\",\n        \"_type\" : \"users\",\n        \"_id\" : \"1\",\n        \"_score\" : 0.2876821,\n        \"_source\" : {\n          \"uid\" : 10001,\n          \"phone\" : 13133334445,\n          \"message\" : \"chaim\",\n          \"sendTime\" : \"2021-06-09 16:47:47\"\n        }\n      }\n    ]\n  }\n}\n```\n\n结果集中，需要重点关注的就是 `hits`，包含了返回的结果集——所有 `message` 属性为 `chaim` 的结果集。每个结果中，都有一个 `_score` 属性，该属性记录了结果与查询条件的匹配度，匹配度高，得分越高\n\n# 结构化查询\n\n将上面的查询改为 DSL：\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"match\": {\n      \"message\": \"chaim\"\n    }\n  }\n}\n```\n\n以上就是 DSL 一个最基本的例子了，查询出来的结果是不变的\n\n> ES 中有两个最常用的查询：`match` 和 `term`\n\n## term（精确查询）\n\n默认情况下，elasticsearch在对文档分析期间（将文档分词后保存到倒排索引中），会对文档进行分词，比如默认的标准分析器会对文档进行：\n\n* 删除大多数的标点符号\n* 将文档分解为单个词条，我们称为token\n* 将token转为小写\n\n之后，除了保存原文件，还会将分析出来的数据保存到倒排索引上\n\n如：`Something just like this!`，经过分析后：\n\n```text\nPOST _analyze\n{\n  \"analyzer\": \"standard\",\n  \"text\": \"Something just like this!\"\n}\n# 结果\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"something\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 9,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"just\",\n      \"start_offset\" : 10,\n      \"end_offset\" : 14,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"like\",\n      \"start_offset\" : 15,\n      \"end_offset\" : 19,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"this\",\n      \"start_offset\" : 20,\n      \"end_offset\" : 24,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 3\n    }\n  ]\n}\n```\n\n* 分词器有很多，之后再介绍\n\n## match（匹配）\n\n在使用**match**查询时，elasticsearch会对查询关键字进行分词，但是使用**term**不会，它会根据整个关键词进行查询：\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"term\": {\n      \"message\": \"fat oka\"\n    }\n  }\n}\n```\n\n上述查询使用term是不会有返回值的，因为我们存入的数据中没有 `message` 为 `fat oka` 的文档\n\n需要注意的是：**使用 `term` 进行查询时，<span style=\"color: red\">必须保证查询的字段不会被分词！！！</span>，即不是 text 类型**\n\n如果要使用**多个关键字**进行精确查询，ES 中可以使用 `terms` 查询：\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"terms\": {\n      \"message\": [\"fat\", \"oka\"]\n    }\n  }\n}\n```\n\n* 注意：此处可以查询出结果是因为 `fat` 和 `oka` 在文档中是存在关键词的，所以可以查出来\n\n### match(按条件查询)\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"match\": {\n      \"message\": \"sweet dog\"\n    }\n  }\n}\n```\n\n如上，查询时只需要在 `match` 中添加条件**(关键词)**即可，es 会对 match 中的关键词进行分词（将 `sweet dog` 分成 `sweet` 和 `dog`），然后进行查询：\n\n```text\n{\n  \"took\" : 3,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.3862942,\n    \"hits\" : [\n      {\n        \"_index\" : \"test\",\n        \"_type\" : \"users\",\n        \"_id\" : \"2\",\n        \"_score\" : 1.3862942,\n        \"_source\" : {\n          \"uid\" : 10002,\n          \"phone\" : 13133334545,\n          \"message\" : \"sweet oka\",\n          \"sendTime\" : \"2021-06-07 16:47:47\"\n        }\n      },\n      {\n        \"_index\" : \"test\",\n        \"_type\" : \"users\",\n        \"_id\" : \"5\",\n        \"_score\" : 1.3862942,\n        \"_source\" : {\n          \"uid\" : 10005,\n          \"phone\" : 13133334555,\n          \"message\" : \"fat dog\",\n          \"sendTime\" : \"2021-06-19 16:47:47\"\n        }\n      }\n    ]\n  }\n}\n```\n\n### match_all (查询全部)\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n`match_all` 用来查询所有的数据，以上写法相当于 `GET test/users/_search`\n\n### match_phrase(短语查询)\n\n在这之前，我们再插入几条记录\n\n```text\nPUT test/users/6\n{\n  \"uid\": 10005,\n  \"phone\": 13133334555,\n  \"message\": \"fat red cat\",\n  \"sendTime\": \"2021-06-19 16:47:47\"\n}\n\nPUT test/users/7\n{\n  \"uid\": 10005,\n  \"phone\": 13133334555,\n  \"message\": \"fat cat die!\",\n  \"sendTime\": \"2021-06-19 16:47:47\"\n}\n```\n\n然后执行：\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"match_phrase\": {\n      \"message\": \"fat cat\"\n    }\n  }\n}\n```\n\n查看结果：\n\n```sql\n{\n  \"took\" : 528,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0924653,\n    \"hits\" : [\n      {\n        \"_index\" : \"test\",\n        \"_type\" : \"users\",\n        \"_id\" : \"4\",\n        \"_score\" : 1.0924653,\n        \"_source\" : {\n          \"uid\" : 10004,\n          \"phone\" : 13133334455,\n          \"message\" : \"fat cat\",\n          \"sendTime\" : \"2021-06-13 16:47:47\"\n        }\n      },\n      {\n        \"_index\" : \"test\",\n        \"_type\" : \"users\",\n        \"_id\" : \"7\",\n        \"_score\" : 0.92097366,\n        \"_source\" : {\n          \"uid\" : 10005,\n          \"phone\" : 13133334555,\n          \"message\" : \"fat cat die!\",\n          \"sendTime\" : \"2021-06-19 16:47:47\"\n        }\n      }\n    ]\n  }\n}\n```\n\n我们可以发现，其查询出来的一定是包含 `fat cat` 的文档，所以，`match_phrase` 同样是**精确查询**：它要求 `cat` 前面那个关键词必须是 `fat`\n\n但是当我们使用 `term` 查询时，却查不出来，因为 `message` 是会被分词的，分词之后，并没有 `fat cat` 这个关键字(索引)\n\n但是有的时候，我们希望查询 `fat cat` 时，将`fat red cat` 也查出来，即：希望 `fat` 和 `cat` 中间可以有几个其他的词：\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"match_phrase\": {\n      \"message\": {\n        \"query\": \"fat cat\",\n        \"slop\": 1\n      }\n    }\n  }\n}\n```\n\n`slop` 属性规定了 `fat` 和 `cat` 中间可以有几个其他的单词，大家可以试试三个关键词会是什么样子，提前说明： `slop` 规定了多个关键词中间可以可以有几个单词，但是并没有规定那些单词的位置\n\n### match_phrase_prefix（最左前缀查询）\n\n先添加一些数据\n\n```text\nPUT test/users/8\n{\n  \"uid\": 10008,\n  \"phone\": 13133334555,\n  \"message\": \"somebody that I used to know\",\n  \"sendTime\": \"2021-06-19 16:47:47\"\n}\n\nPUT test/users/9\n{\n  \"uid\": 10009,\n  \"phone\": 13133334555,\n  \"message\": \"someone you loved\",\n  \"sendTime\": \"2021-06-19 16:47:47\"\n}\n\nPUT test/users/10\n{\n  \"uid\": 10010,\n  \"phone\": 13133334555,\n  \"message\": \"something just like this!\",\n  \"sendTime\": \"2021-06-19 16:47:47\"\n}\n\nPUT test/users/11\n{\n  \"uid\": 10011,\n  \"phone\": 13133334555,\n  \"message\": \"I don't love somebody like you!\",\n  \"sendTime\": \"2021-06-19 16:47:47\"\n}\n```\n\n`match_phrase_prefix` 用于匹配左边符合指定字符串的文档\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"match_phrase_prefix\": {\n      \"message\": \"some\"\n    }\n  }\n}\n```\n\n运行之后可以发现其返回了所有包含 `some` 的索引的文档，前缀查询还可以更进一步的搜索，如：`love some`，其要求和 `some` 最左匹配的前面的那个关键词必须是 `love`。这个特性使其多用于搜索框一边输入，一边提示可能的值的需求。\n\n这种匹配方式可以搜出大量的结果集，但是有时候我们并不想有这么多结果（搜索框的提示也不是很多很多个，为了性能，也是为了友好的交互）：`max_expansions`\n\n ```text\n GET test/users/_search\n {\n   \"query\": {\n     \"match_phrase_prefix\": {\n       \"message\": {\n         \"query\": \"some\",\n         \"max_expansions\": 1\n       }\n     }\n   }\n }\n ```\n\n当 `max_expansions` 为 1 时，查出来的是带有 `somebody` 关键词的文档，当其值为 2 时，查出来的是包含 `somebody` 和 `someone` 的文档，当其值是 3 时，查出来的是包含 `somebody`、`someone` 和 `something` 的文档，有发现什么吗？\n\n**``max_expansions` 控制着可以与前缀匹配的词的数量，它会先查找第一个与前缀 匹配的词，然后依次查找搜集与之匹配的词（按字母顺序），直到没有更多可匹配的词或当数量超过 `max_expansions` 时结束。**\n\n### multi_match（多字段查询）\n\n如果我们有一个50个字段的索引，我们要在多个字段中查询同一个关键字\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"somebody\",\n      \"fields\": [\"message\", \"sendTime\"]\n    }\n  }\n}\n```\n\n结果中包含了所有包含 `somebody` 关键字的文档，由此可以看出，多字段之间的关系是**或**\n\n多字段查询还可以当作 `match_phrase`和`match_phrase_prefix`使用，只需要指定`type`类型即可：\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"some\",\n      \"fields\": [\"message\", \"sendTime\"],\n      \"type\": \"phrase_prefix\"\n    }\n  }\n}\n```\n\n## sort（排序）\n\n```text\nGET test/users/_search\n{\n  \"sort\": {\n    \"uid\": {\n      \"order\": \"desc\"\n    }\n  }\n}\n```\n\n我们插入的数据中，`uid` 字段本身就是 long 类型，所以我们可以用 `uid` 来进行排序\n\n需要注意的是：**ES 中仅支持数字类型和日期类型的排序**\n\n## from/size（分页）\n\n```text\nGET test/users/_search\n{\n  \"from\": 1,\n  \"size\": 5\n}\n```\n\n## bool（布尔查询）\n\n> 布尔查询是最常用的**组合查询**，根据子查询的规则，只有当文档满足所有子查询条件时，elasticsearch引擎才将结果返回。布尔查询支持的子查询条件共4中：\n>\n> - must（and-与）\n> - should（or-或）\n> - must_not（not-非）\n> - filter\n\n### must、must_not、should演示一个即可\n\n再添加一条记录\n\n```text\nPUT test/users/14\n{\n  \"uid\": 10014,\n  \"phone\": 13133334555,\n  \"message\": \"you love me, but I don't love somebody!\",\n  \"message1\": \"adsaf adfsas\",\n  \"sendTime\": \"2021-06-19 16:47:47\"\n}\n```\n\n使用 bool 查询\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"should\": [\n        {\n          \"match\": {\n            \"message\": \"somebody\"\n          }\n        },\n        {\n          \"match_phrase_prefix\": {\n            \"message\": \"love\"\n          }\n        }\n      ],\n      \"must\": [\n        {\n          \"match\": {\n            \"message\": \"you\"\n          }\n        }\n      ],\n      \"minimum_should_match\": 2\n    }\n  }\n}\n```\n\n上述语句中，我们需要注意一个属性：`minimum_should_match`，这个属性规定了，查出来的结果中至少要满足几个 `should` 中的条件\n\n`minimum_should_match` 属性的详细信息：[https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-minimum-should-match.html](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-minimum-should-match.html)\n\n* 当我们不加 `minimum_should_match` 属性查询时，我们会发现 `should` 条件好像没有起作用，那是因为有几种情况下，这个属性的默认值是0\n  1. 查询上下文（query 中，确切说是 bool 中）中，同时存在 `must` 和 `should`\n  2. elasticsearch7.0开始，`filter` 中的 `bool` 同时有 `must` 和 `should`\n\n需要注意的是：**``bool` 是可以嵌套的，就像括号可以嵌套一样**\n\n### filter——过滤\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"match_phrase_prefix\": {\n            \"message\": \"some\"\n          }\n        }\n      ],\n      \"filter\": [\n        {\n          \"range\": {\n            \"uid\": {\n              \"gte\": 10010\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n`range` 表示范围内的过滤：`lt` -小于，`lte` -小于等于，`gt` -大于，`gte` -大于等于\n\n`filter` 里面同样可以写 `bool`\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"match_phrase_prefix\": {\n            \"message\": \"some\"\n          }\n        }\n      ],\n      \"filter\": [\n        {\n          \"bool\": {\n            \"must\": [\n              {\n                \"match\": {\n                  \"message\": \"you\"\n                }\n              }\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n## _source（结果过滤）\n\n如果我们只需要查询结构的某几个字段，就需要用到 `_source`\n\n```text\nGET test/users/_search\n{\n  \"_source\": [\"uid\", \"message\"]\n}\n```\n\n## highlight（高亮查询）\n\n高亮查询可以用来突出显示关键词（显示红色等）：如果不设置 `pre_tags` 和 `post_tags`，默认会添加 `em` 标签\n\n```text\nGET test/users/_search\n{\n  \"query\": {\n    \"match_phrase_prefix\": {\n      \"message\": \"some\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"message\": {}\n    }, \n    \"pre_tags\": \"<span style='color: red;'>\",\n    \"post_tags\": \"</span>\"\n  },\n  \"_source\": [\"uid\", \"message\"]\n}\n```\n\n查询结果：\n\n```text\n{\n  \"took\" : 15,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 5,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 2.885361,\n    \"hits\" : [\n      {\n        \"_index\" : \"test\",\n        \"_type\" : \"users\",\n        \"_id\" : \"9\",\n        \"_score\" : 2.885361,\n        \"_source\" : {\n          \"uid\" : 10009,\n          \"message\" : \"someone you loved\"\n        },\n        \"highlight\" : {\n          \"message\" : [\n            \"<span style='color: red;'>someone</span> you loved\"\n          ]\n        }\n      },\n      {\n        \"_index\" : \"test\",\n        \"_type\" : \"users\",\n        \"_id\" : \"12\",\n        \"_score\" : 0.9161823,\n        \"_source\" : {\n          \"uid\" : 10012,\n          \"message\" : \"you love me, but I don't love somebody!\"\n        },\n        \"highlight\" : {\n          \"message\" : [\n            \"you love me, but I don't love <span style='color: red;'>somebody</span>!\"\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n\n我们可以看到查询结果中有了 `highlight` 字段（碍于篇幅，少截了几条），里面就是高亮的字段和值\n\n## 聚合函数\n\nes中的聚合函数有：`sum`、`max`、`min`、`avg`，会使用一个，其他的也都一样\n\n我们现在求最大的 `uid`\n\n```text\nGET test/users/_search\n{ \n  \"aggs\": {\n    \"max_uid\": {\n      \"max\": {\n        \"field\": \"uid\"\n      }\n    }\n  }\n}\n```\n\n需要注意的是，聚合函数的结果会出现在最后：\n\n```text\n{\n  ...\n  \"aggregations\" : {\n    \"max_uid\" : {\n      \"value\" : 10013.0\n    }\n  }\n  ...\n}\n```\n\n使用其他聚合函数时，只需要将 `max` 换成其他的函数就好了\n\n## 分组\n\n分组统计只需要设置统计类型是 `range` 即可\n\n```text\nGET test/users/_search\n{ \n  \"aggs\": {\n    \"group_uid\": {\n      \"range\": {\n        \"field\": \"uid\",\n        \"ranges\": [\n          {\n            \"from\": 10005,\n            \"to\": 10010\n          },\n          {\n            \"from\": 10010,\n            \"to\": 10020\n          }\n        ]\n      }\n    }\n  }\n}\n```\n\n结果为组中的文档数量，统计结果包含 `from`，不包含 `to`\n\n```text\n{\n  ...\n  \"aggregations\" : {\n    \"group_uid\" : {\n      \"buckets\" : [\n        {\n          \"key\" : \"10005.0-10010.0\",\n          \"from\" : 10005.0,\n          \"to\" : 10010.0,\n          \"doc_count\" : 5\n        },\n        {\n          \"key\" : \"10010.0-10020.0\",\n          \"from\" : 10010.0,\n          \"to\" : 10020.0,\n          \"doc_count\" : 4\n        }\n      ]\n    }\n  }\n  ...\n}\n```\n\n聚合函数同样是可以嵌套的\n\n```text\nGET test/users/_search\n{\n  \"aggs\": {\n    \"group_uid\": {\n      \"range\": {\n        \"field\": \"uid\",\n        \"ranges\": [\n          {\n            \"from\": 10005,\n            \"to\": 10010\n          },\n          {\n            \"from\": 10010,\n            \"to\": 10020\n          }\n        ]\n      },\n      \"aggs\": {\n        \"max_uid\": {\n          \"max\": {\n            \"field\": \"uid\"\n          }\n        },\n        \"min_uid\": {\n          \"min\": {\n            \"field\": \"uid\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n结果：\n\n```text\n{\n  ...\n  \"aggregations\" : {\n    \"group_uid\" : {\n      \"buckets\" : [\n        {\n          \"key\" : \"10005.0-10010.0\",\n          \"from\" : 10005.0,\n          \"to\" : 10010.0,\n          \"doc_count\" : 5,\n          \"max_uid\" : {\n            \"value\" : 10009.0\n          },\n          \"min_uid\" : {\n            \"value\" : 10005.0\n          }\n        },\n        {\n          \"key\" : \"10010.0-10020.0\",\n          \"from\" : 10010.0,\n          \"to\" : 10020.0,\n          \"doc_count\" : 4,\n          \"max_uid\" : {\n            \"value\" : 10013.0\n          },\n          \"min_uid\" : {\n            \"value\" : 10010.0\n          }\n        }\n      ]\n    }\n  }\n  ...\n}\n```\n\n","tags":["elasticsearch查询方式"],"categories":["elasticsearch"]},{"title":"ES 的 CURD","url":"/2021/06/feaeef89.html","content":"\n> 作为一个存储(索引)的介质，CURD一定是最最基础的操作，而在这四个操作中，查(Read)一定是最“难”的，同时意味着“查”需要用更多的篇幅来讲解\n\n<!-- more -->\n\n# 操作前提\n\n在进行增删改查之前，建议先定义好 index 和 type|mapping\n\n```text\nPUT test\n{\n  \"settings\": {\n    \"number_of_shards\": 5,\n    \"number_of_replicas\": 1,\n    \"refresh_interval\": \"1s\"\n  },\n  \"mappings\": {\n    \"users\": {\n      \"properties\": {\n        \"uid\": {\"type\": \"long\"},\n        \"phone\": {\"type\": \"long\"},\n        \"message\": {\"type\": \"keyword\"},\n        \"sendTime\": {\n          \"type\": \"date\",\n          \"format\": \"yyyy-MM-dd HH:mm:ss\"\n        }\n      }\n    }\n  }\n}\n```\n\n# CRUD-<span style=\"color: orange\">C</span>reate\n\n> 创建文档可以使用 PUT 或 POST 操作\n\n## PUT 创建文档\n\n使用 PUT 插入文档：PUT indexName/typeName[/id]\n\n```text\nPUT test/users/1\n{\n  \"uid\": 10001,\n  \"phone\": 13133334445,\n  \"message\": \"record4\",\n  \"sendTime\": \"2021-06-09 16:47:47\"\n}\n```\n\n查询插入的文档：`GET test/users/1`\n\n```text\n{\n  \"_index\" : \"test\",\n  \"_type\" : \"users\",\n  \"_id\" : \"1\",\n  \"_version\" : 1,\n  \"found\" : true,\n  \"_source\" : {\n    \"uid\" : 10001,\n    \"phone\" : 13133334445,\n    \"message\" : \"record4\",\n    \"sendTime\" : \"2021-06-09 16:47:47\"\n  }\n}\n```\n\n## PUT 更新文档（错误示范）\n\n我们把 `message` 的值改成 `record`\n\n```text\nPOST test/users/1\n{\n  \"message\": \"record\"\n}\n```\n\n再次查询：\n\n```text\n{\n  \"_index\" : \"test\",\n  \"_type\" : \"users\",\n  \"_id\" : \"1\",\n  \"_version\" : 2,\n  \"found\" : true,\n  \"_source\" : {\n    \"message\" : \"record\"\n  }\n}\n```\n\n发现记录里面只有 `message` 的值了\n\n# CRUD-<span style=\"color: orange\">U</span>pdate\n\n> ES 使用 `_update` 更新文档，只能用 POST 操作\n\n* 更新文档之前，先将数据恢复\n\n## 使用 doc\n\n```text\nPOST test/users/1/_update\n{\n  \"doc\": {\n    \"message\": \"record\"\n  }\n}\n```\n\n更新时，将需要更新的属性放到 doc 中\n\n再次查询：\n\n```text\n{\n  \"_index\" : \"test\",\n  \"_type\" : \"users\",\n  \"_id\" : \"1\",\n  \"_version\" : 4,\n  \"found\" : true,\n  \"_source\" : {\n    \"uid\" : 10001,\n    \"phone\" : 13133334445,\n    \"message\" : \"record\",\n    \"sendTime\" : \"2021-06-09 16:47:47\"\n  }\n}\n```\n\n可以发现数据已经更新\n\n## 使用 script\n\n使用 script 更新文档可以实现某个属性的值自增，或者是添加删除属性\n\n* 手机号 +10（没有什么含义，仅作为演示用）：\n\n  ```text\n  POST test/users/1/_update\n  {\n    \"script\": {\n      \"source\": \"ctx._source.phone += params.index\",\n      \"lang\": \"painless\",\n      \"params\": {\n          \"index\": 10\n      }\n    }\n  }\n  ```\n\n* ctx变量还可以使用 `_index,_type,_id,_version,_routing,_parent,_now` 这些变量，有兴趣可以在官网查看文档\n\n## 更新文档时还可以指定符合条件的文档更新\n\n```text\nPOST test/_update_by_query\n{\n  \"query\": {\n    // 查询条件\n  },\n  \"script\": { // 使用脚本执行更新的具体操作\n    \"source\": \"ctx._source['message']='record2update'\"\n  }\n}\n```\n\n查询条件后面篇幅会讲述\n\n# CRUD-<span style=\"color: orange\">D</span>elete\n\n> ES 使用 DELETE 删除文档\n\n## 使用 DELETE 操作删除指定 ID 文档\n\n```text\n// DELETE indexName/typeName/id\nDELETE test/users/1\n```\n\n## 条件删除\n\n使用 POST 操作：`POST test/users/_delete_by_query`\n\n```text\nPOST test/users/_delete_by_query\n{\n  \"query\": {\n    // 查询条件\n  }\n}\n```\n\n# CRUD-<span style=\"color: orange\">R</span>ead\n\n> ES 中通过 GET 操作查询文档\n\n通过 GET 查询指定文档：`GET test/users/1`\n\n查询结果：\n\n```text\n{\n  \"_index\" : \"test\",\n  \"_type\" : \"users\",\n  \"_id\" : \"1\",\n  \"_version\" : 6,\n  \"found\" : true,\n  \"_source\" : {\n    \"uid\" : 10001,\n    \"phone\" : 13133334465,\n    \"message\" : \"record\",\n    \"sendTime\" : \"2021-06-09 16:47:47\"\n  }\n}\n```\n\n下篇继续……\n\n","tags":["ES的CURD"],"categories":["ElasticSearch"]},{"title":"ES 入门","url":"/2021/06/feaeef89.html","content":"\n# 安装\n\n## Java安装\n\n* elasticsearch 需要 Java 的环境，我们一般需要安装 JDK1.8 或以上版本，Java 的安装步骤不再展示（参考[菜鸟教程](https://www.runoob.com/java/java-environment-setup.html)）……\n\n<!-- more -->\n\n## Elasticsearch安装\n\n### 官网下载安装包安装\n\n1. 访问官网下载安装包\n\n   可以在 [官网](https://www.elastic.co/cn/start) 直接下载，也可以选择 [Elasticsearch](https://www.elastic.co/cn/downloads/past-releases#elasticsearch) 和 [Kibana](https://www.elastic.co/cn/downloads/past-releases#kibana) 版本下载，也可以在官方 [github](https://github.com/elastic/elasticsearch/releases) 下载源码\n\n> Kibana 是 Elastic 公司提供的免费且开放的用户界面，方便用户对 Elastic 进行各种操作\n\n2. 解压之后，在 bin 目录运行 elasticsearch.bat 即可\n\n3. 运行完成之后，访问 127.0.0.1:9200，出现如下界面表示运行成功\n\n   <div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n       <img alt=\"20210614205247\" src=\"https://i.loli.net/2021/06/14/oyxaB4VSnRrIhcO.png\" style=\"width: 100%;\">\n   </div>\n   \n4. ES目录介绍（需要我们关注的有四个）\n\n   | 目录    | 作用                                   |\n   | ------- | -------------------------------------- |\n   | bin     | 存放了启动及设置ES的入口（可执行文件） |\n   | config  | 存放了ES的配置的信息                   |\n   | data    | 存放数据                               |\n   | logs    | 存放了ES运行过程中产生的日志信息       |\n   | plugins | ES支持的各种插件存放在该目录中         |\n\n### docker-compose 安装\n\n1. 准备配置文件\n\n   * elasticsearch.yml：可以参考下载下来的包中的 config 中的 `elasticsearch.yml` 文件\n   * kibana.yml：同理，参考下载下来的包中的 config 中的 `kibana.yml` 文件\n\n2. 编写docker-compose\n\n   ```yml\n   version: '3.6'\n   services:\n     elasticsearch:\n       image: elasticsearch:7.7.0\n       container_name: elasticsearch\n       environment:\n         - \"cluster.name=elasticsearch\" #设置集群名称为elasticsearch\n         - \"discovery.type=single-node\" #以单一节点模式启动\n         - \"ES_JAVA_OPTS=-Xms2048m -Xmx2048m\" #设置使用jvm内存大小\n       volumes:\n         - ./data/elasticsearch/plugins:/usr/share/elasticsearch/plugins #插件文件挂载\n         - ./data/elasticsearch/data:/usr/share/elasticsearch/data #数据文件挂载\n         - ./data/elasticsearch/config/elastic-search.yml:/usr/share/elasticsearch/config/elasticsearch.yml #配置文件挂载\n       ports:\n         - 9200:9200\n         - 9300:9300\n     kibana:\n       image: kibana:7.7.0\n       container_name: kibana\n       depends_on:\n         - elasticsearch #kibana在elasticsearch启动之后再启动\n       environment:\n         - \"elasticsearch.hosts=http://192.168.91.128:9200\" #设置访问elasticsearch的地址\n       volumes:\n         - ./data/kibana/config:/usr/share/kibana/config #配置文件挂载\n       ports:\n         - 5601:5601\n   ```\n\n3. 启动，访问 http://ip:port 验证是否安装成功\n\n   > 1. 启动前需要将配置文件复制到相对应的挂载目录(volumes)中，然后才可以成功启动容器\n   > 2. 这个docker-compose是一个单一节点的案例\n\n### ik 分词器下载安装\n\n从 [github](https://github.com/medcl/elasticsearch-analysis-ik/releases) 选择相对应的版本下载，然后放在目录 `plugins/ik` 下面，重启ES就好了\n\n# Elasticsearch配置文件解析\n\n> ES 的配置文件在 config 文件夹下，值得关注的有`elasticsearch.yml`、`jvm.options`、`log4j2.properties`，但是我们需要关注的仅仅是 `elasticsearch.yml`，`jvm.options` 在JVM的笔记中会详细解释，`log4j2.properties` 里面存储了日志打印的信息，一般不用管，而且在 `elasticsearch.yml` 中同样可以进行日志的配置 \n\n## `elasticsearch.yml`\n\n```text\n# ES的官方文档地址：https://www.elastic.co/guide/en/elasticsearch/reference/index.html\n#----------------------------------- 集群相关 ------------------------------------\n# 集群名称，默认就是 elasticsearch\ncluster.name: my-application\n\n#----------------------------------- 节点相关 ------------------------------------\n# 当前节点名字，如果不配置，系统会随机指定名字\nnode.name: node-1\n# 设置节点是否可以成为主节点，默认为true\nnode.master: true\n# 设置节点是否存储数据，默认为true\nnode.data: true\n#===========================================\n# master 和 data 配置可以产生一些奇异的效果\n# 1). 当master为false，而data为true时，该节点将会专门用来存储数据\n# 2). 当master为true，而data为false时，该节点具有成为 master 节点的资格\n# 3). 当master为false，data也为false时，该节点是一个 client (客户端)，主要用来处理用户的请求，进行负载均衡，或者是进行请求结果的计算\n#===========================================\n\n# ----------------------------- 日志和持久化相关 ---------------------------------\n# 数据文件存储目录，可以设置多个路径，用【逗号】隔开 \npath.data: /path/to/data1,/path/to/data2\n# 日志文件存储目录\npath.logs: /path/to/logs\n# 临时文件目录\npath.work: /path/to/work\n# 配置文件目录\npath.conf: /path/to/conf\n# 插件安装路径\npath.plugins: /path/to/plugins\n\n# ----------------------------------- 内存配置 -----------------------------------\n# 锁定物理内存地址，防止es内存被交换出去，也就是避免es使用swap交换分区。频繁的交换，会导致IOPS变高。\nbootstrap.memory_lock: true\n# 要确保堆大小设置为系统可用内存的一半\n\n# ---------------------------------- 网络配置 -----------------------------------\n# 本机绑定ip地址，默认0.0.0.0\nnetwork.host: 192.168.0.1\n# 本机绑定端口，默认9200\nhttp.port: 9200\n\n# ----------------------------- 集群节点服务发现配置 ------------------------------\n# 设置一个集群中主节点的数量，其意义在于防止脑裂，规定集群只有在发现有 这个多 结点的时候，才可以选主节点\ndiscovery.zen.minimum_master_nodes: 1\n#\n# 设置ping其他节点时的超时时间，网络比较慢时可将该值设大：\ndiscovery.zen.ping.timeout: 3s\n# 设置新节点被启动时能够发现的主节点列表（主要用于不同网段机器连接）：\ndiscovery.zen.ping.unicast.hosts: [\"host1\", \"host2:port\", \"host3[portX-portY]\"]\n```\n\n* 更多配置请访问[官方文档](https://www.elastic.co/guide/index.html)\n\n## `jvm.options` \n\n对于学习来说，这个配置文件中我们只需要关注两个参数即可\n\n```text\n-Xms4g\n-Xmx4g\n```\n\n* 这两个参数用于设置 JVM 的内存，两个值设置为一致大小可以防止内存抖动（一个很正常的现象），ES学习时推荐设置512M就基本足够了\n\n# ES 的数据结构设计\n\n## 逻辑设计\n\n> 包含**文档**、**类型**、**索引**，可以理解为分别对应关系型数据库的 *记录（行）*、*表（更像是表中的列的描述）*、*数据库*，但是区别在于：<br>\n> 关系型数据库中一个数据库中可以有多张表，但是 ES 从 6 开始，建议一个索引中只能有一个类型，在未来版本中会规定一个索引只有一个类型\n\n### 文档（document）\n\n`elasticsearch` 是面向文档的，意味着它搜索和索引数据的最小单位就是文档。文档有几个属性：\n\n* 文档是 `key-value` 的形式，需要同时有值\n* 文档中可以包含另一个文档，可以理解为 json 的 value 也可以是一个 json\n* 结构灵活。文档中，字段不需要预先定义，可以忽略某个字段，甚至可以可以动态的添加字段\n* 无模式。文档的字段对应的值可以是任意类型\n  * 有一点需要注意，尽管文档是无模式的，但是字段的类型依旧很重要，明确的类型可以提高存储和索引时的效率\n\n### 类型（type）\n\n> 类型规定了文档的字段的**类型**\n\n类型中对于字段的定义称为映射，比如将 `name` 映射为字符串类型，`age` 映射为整型\n\nES 中的文档是无模式的，当文档中的字段没有映射类型时，ES 会猜该字段是什么类型。但是 ES 猜的那个类型也不一定是我们想要的类型，所以比较好的办法的是提前定义好所需要的映射\n\n### 索引\n\nelasticsearch 的索引是一个非常大的文档集合，存储了文档和定义好的映射（如果有）\n\n## 物理设计\n\n> 节点和分片\n\nes 是支持集群部署的，一个集群包含至少一个节点，一个节点就是一个 es 的实例（进程）。节点内可以有多个索引\n\n一个索引默认有5个分片（primary shard），每个分片又有一个副本（replica shard）\n\n当集群有三个节点时：\n\n![es node clus](https://img2018.cnblogs.com/blog/1168165/201903/1168165-20190321171753955-918996558.png)\n\n可以看到主分片和对应的副本分片不会分布在同一节点上，这样就算某个节点挂了，数据也不会丢失\n\n实际上一个分片就是一个 Lucene 的索引，一个*倒排索引*的目录\n\n### 倒排索引\n\n**索引**可以理解为目录，一般是类似于 *标题——页码* 的 `key-value` 结构。但是当我们使用关键词进行搜索时，就需要扫描索引库的所有文档，当文档很多时，这样的索引结构根本无法满足近实时的需求\n\n**倒排索引**是将原本的索引结构转换为 *关键词——文档ID* 的映射结构，每个关键词都对应**包含此关键词的文档的 id 列表**\n\n#### 举个栗子\n\n比如说，我们现在有两个文档，分别包含如下内容：\n\n```text\n# 文档1\nIt is never too late to mend.\n# 文档2\nIt is never too late to learn.\n```\n\n倒排索引创建后，是这样子的：\n\n| term  | doc1 | doc2 |\n| ----- | ---- | ---- |\n| It    | √    | √    |\n| is    | √    | √    |\n| never | √    | √    |\n| too   | √    | √    |\n| late  | √    | √    |\n| to    | √    | √    |\n| mend  | √    | ×    |\n| learn | ×    | √    |\n\n现在，我们搜索 `to learn`，只需要搜索每个词条包含的文档就好了\n\n| term  | doc1 | doc2 |\n| ----- | ---- | ---- |\n| to    | √    | √    |\n| learn | ×    | √    |\n| total | 1    | 2    |\n\n可以看出，两个文档都有匹配的地方，第 2 个文档匹配度更高\n\n# ES 的简单操作\n\n> 本文中，ES的操作在 Kibana 中进行：Kibana -> Dev Tools -> Console\n>\n> ES 提供了基于 RESTful 的 API，本节也会基于 HTTP 的方法分类\n\n## PUT\n\n> PUT 在 RESTful 语义中表示资源的全量更新，在 ES 中可以增加索引、映射，创建或全量更新文档\n>\n> 在 Kibana 中，PUT/POST/GET……操作可以小写，但是为了重点表示其是一个操作，建议使用大写\n\n### PUT 操作增加索引\n\n* 请求：\n\n  ```text\n  PUT test\n  {\n    \"settings\": {\n      \"number_of_shards\": 5,\n      \"number_of_replicas\": 1,\n      \"refresh_interval\": \"1s\"\n    },\n    \"mappings\": {\n      \"_doc\": {\n        \"properties\": {\n          \"uid\": {\"type\": \"long\"},\n          \"phone\": {\"type\": \"long\"},\n          \"message\": {\"type\": \"keyword\"},\n          \"sendTime\": {\n            \"type\": \"date\",\n            \"format\": \"yyyy-MM-dd HH:mm:ss\"\n          }\n        }\n      }\n    }\n  }\n  ```\n\n  * 需要注意的是，ES 中的时区默认是国际标准时区，我们是东8区\n  * 此请求中，包含了映射\n\n* 响应\n\n  ```text\n  {\n    \"acknowledged\" : true,\n    \"shards_acknowledged\" : true,\n    \"index\" : \"test\"\n  }\n  ```\n\n### PUT 增加文档\n\n* 请求：\n\n  ```text\n  PUT test/users/2\n  {\n    \"uid\": 10001,\n    \"phone\": 13133334445,\n    \"message\": \"record4\",\n    \"sendTime\": \"2021-06-09 16:47:47\"\n  }\n  ```\n\n* 响应\n\n  ```text\n  {\n    \"_index\" : \"test\",\n    \"_type\" : \"users\",\n    \"_id\" : \"2\",\n    \"_version\" : 1,\n    \"result\" : \"created\",\n    \"_shards\" : {\n      \"total\" : 2,\n      \"successful\" : 1,\n      \"failed\" : 0\n    },\n    \"_seq_no\" : 0,\n    \"_primary_term\" : 1\n  }\n  ```\n\n  * 响应体中的 `result` 字段在第一次执行的时候是 `created`，表示此次操作是文档创建。第二次执行时是 `updated`，表示此次操作是文档更新\n\n## POST\n\n> PUT 在 RESTful 语义中表示资源的添加，在 ES 中可以创建或更新文档\n\n### POST 增加文档\n\n* 请求：\n\n  ```text\n  POST test/users/2\n  {\n    \"uid\": 10001,\n    \"phone\": 13133334445,\n    \"message\": \"record4\",\n    \"sendTime\": \"2021-06-09 16:47:47\"\n  }\n  ```\n\n* 响应\n\n  * 响应结果与 PUT 操作增加文档一致\n\n## GET\n\n> GET 在RESTful 中表示查询资源，在 ES 中同样表示查询\n\n### GET 操作查看索引信息\n\n* 请求：\n\n  ```text\n  GET test\n  ```\n\n  只需要 GET 后面跟上索引的名字就行了\n\n* 响应\n\n  ```text\n  {\n    \"test\" : {\n      \"aliases\" : { },\n      \"mappings\" : {\n        \"users\" : {\n          \"properties\" : {\n            \"message\" : {\n              \"type\" : \"keyword\"\n            },\n            \"phone\" : {\n              \"type\" : \"long\"\n            },\n            \"sendTime\" : {\n              \"type\" : \"date\",\n              \"format\" : \"yyyy-MM-dd HH:mm:ss\"\n            },\n            \"uid\" : {\n              \"type\" : \"long\"\n            }\n          }\n        }\n      },\n      \"settings\" : {\n        \"index\" : {\n          \"refresh_interval\" : \"1s\",\n          \"number_of_shards\" : \"5\",\n          \"provided_name\" : \"test\",\n          \"creation_date\" : \"1624526067403\",\n          \"number_of_replicas\" : \"1\",\n          \"uuid\" : \"zf2LNEBnTk27P_8Gm9yc5A\",\n          \"version\" : {\n            \"created\" : \"6050499\"\n          }\n        }\n      }\n    }\n  }\n  ```\n\n  * 响应体中包含索引的详细信息\n\n### GET查询所有文档\n\n* 请求：\n\n  ```text\n  GET _search\n  ```\n\n* 响应\n\n  ```text\n  {\n    \"took\" : 0,\n    \"timed_out\" : false,\n    \"_shards\" : {\n      \"total\" : 6,\n      \"successful\" : 6,\n      \"skipped\" : 0,\n      \"failed\" : 0\n    },\n    \"hits\" : {\n      \"total\" : 3,\n      \"max_score\" : 1.0,\n      \"hits\" : [\n        {\n          \"_index\" : \".kibana_1\",\n          \"_type\" : \"doc\",\n          \"_id\" : \"space:default\",\n          \"_score\" : 1.0,\n          \"_source\" : {\n            \"space\" : {\n              \"name\" : \"Default\",\n              \"description\" : \"This is your default space!\",\n              \"color\" : \"#00bfb3\",\n              \"_reserved\" : true\n            },\n            \"type\" : \"space\",\n            \"updated_at\" : \"2021-06-24T09:05:12.000Z\"\n          }\n        },\n        {\n          \"_index\" : \".kibana_1\",\n          \"_type\" : \"doc\",\n          \"_id\" : \"config:6.5.4\",\n          \"_score\" : 1.0,\n          \"_source\" : {\n            \"config\" : {\n              \"buildNum\" : 18878\n            },\n            \"type\" : \"config\",\n            \"updated_at\" : \"2021-06-24T09:05:37.978Z\"\n          }\n        },\n        {\n          \"_index\" : \"test\",\n          \"_type\" : \"users\",\n          \"_id\" : \"2\",\n          \"_score\" : 1.0,\n          \"_source\" : {\n            \"uid\" : 10001,\n            \"phone\" : 13133334445,\n            \"message\" : \"record4\",\n            \"sendTime\" : \"2021-06-09 16:47:47\"\n          }\n        }\n      ]\n    }\n  }\n  ```\n\n  * 响应中包含了es中所有的文档信息，会进行分页\n\n## DELETE\n\n> GET 在RESTful 中表示删除资源，在 ES 中同样表示删除，可以删除索引、文档\n\n### DELETE 删除索引\n\n* 请求：\n\n  ```text\n  DELETE test\n  ```\n\n  DELETE 后面加索引名即可\n\n* 响应\n\n  ```text\n  {\n    \"acknowledged\" : true\n  }\n  ```\n\n  表示删除成功\n\n","tags":["ES安装及入门"],"categories":["ElasticSearch"]},{"title":"ES 介绍","url":"/2021/06/af0250b2.html","content":"# 前言\n\n> 现在，你还离得开搜索吗？无论是Google还是百度提供的搜索入口，还是项目自己的搜索，比如QQ提供的搜索入口等等，都大大的方便了我们的工作、生活。但是你有没有想过——搭建属于自己的搜索服务，应用于你的博客项目、公司项目……\n> 无论你想不想，都要学习！因为随着公司业务的增长，数据也爆炸性增长。对于数据的处理、日志分析，如果还采用传统的方法，这恐怕是灾难性的。所以，我们是时候学习一个先进的搜索引擎了。\n\n<!-- more -->\n\n# Elasticsearch是什么\n\n> Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。<br>\n> 无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。<br>\n> 但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。<br>\n> Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n\n我们可以这样描述ES：\n\n* 分布式的实时文件存储，每个字段都被索引并可被搜索\n\n* 分布式的实时分析搜索引擎\n\n* 可以扩展到上百台服务器，处理PB级结构化或非结构化数据。\n\n通过 RESTFul API 接口，与其他语言集成也变得很容易。\n\n上手elasticsearch非常容易，它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。\n随着越学越深入，还可以利用Elasticsearch更多高级的功能，整个引擎可以很灵活地进行配置。可以根据自身需求来定制属于自己的Elasticsearch。\n\n# ES的历史\n\n多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。\n直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便Java程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。\n\n后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做Elasticsearch。\n第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。\nShay的妻子依旧等待着她的食谱搜索……\n\n# elasticsearch：面向文档\n\n我们知道，关系型数据库以表和记录行的形式存储数据，但是在elasticsearch中，是以文档的形式存储数据。\n\n但区别在于，文档要比数据表的行更加灵活。因为文档可以是多层次的，它（文档）鼓励你将属于一个逻辑实体的数据保存在同一个文档中，而不是散落在各个表的不同行中。这样查询效率很高，因为我们无需连接其他的表，我们学习关系型数据库时，一定知道连表查询（尤其是连接多张表）是多么的费时吧！\n\n我们将在后续文章做更多的讲解。\n\n# 成熟的案例\n\n* 维基百科使用Elasticsearch来进行全文搜做并高亮显示关键词，以及提供search-as-you-type、did-you-mean等搜索建议功能。\n* 英国卫报使用Elasticsearch来处理访客日志，以便能将公众对不同文章的反应实时地反馈给各位编辑。\n* StackOverflow将全文搜索与地理位置和相关信息进行结合，以提供more-like-this相关问题的展现。\n* GitHub使用Elasticsearch来检索超过1300亿行代码，可以参考[A Whole New Code Search](https://github.blog/2013-01-23-a-whole-new-code-search/)\n* 每天，Goldman Sachs使用它来处理5TB数据的索引，还有很多投行使用它来分析股票市场的变动。\n* 苏宁在大数据平台使用es存储600TB数据，集群规模包括：搭建超过500+物理机，30万shards，80000index。\n* 腾讯在日志实时分析中采用es，处理高并发100W/S，PE级数据。\n* 更多[参考](https://elasticsearch.cn/slides/category-38)\n\n# ES应该怎么学？\n\n除了万能的百度和Google 之外，我们还有一些其他的学习途径：\n\n* elasticsearch[官方文档](https://www.elastic.co/guide/index.html)：官方的永远是最权威的\n\n* elasticsearch[博客](https://www.elastic.co/cn/blog?ultron=cn-es-getting-started-webinar&blade=touch&hulk=email&mkt_tok=eyJpIjoiWXpBeE9UbG1OemMwTnpBNCIsInQiOiI5SUlMWkNjaXZPRWxOb3B2ZnUyOVZDcFwvTDQ2MXVTUEdPcnpPR1RobDc4NEtURTAwZWkrVDZKSDVPemdVb0drbk5QXC9rVkpCZWVUcTRYMkEzazVKdzdKV2JGT01IWW1yMTZwdjlOcDdOeUYzWGdjZ2ZDSTQyN2J5bWNWVlNmdUdNIn0%3D)：这个吧，看看就行\n\n* 各类学习视频：B站等\n","tags":["ES介绍"],"categories":["ElasticSearch"]},{"title":"markdown 语法高级","url":"/2021/06/c82e120e.html","content":"# Markdown 进阶语法\n\n## 待办事项\n\n制作待办事项 To-do List\n\n<!-- more -->\n\n```text\n- [x] 已完成项目1\n  - [x] 已完成事项1\n  - [x] 已完成事项2\n- [ ] 待办事项1\n- [ ] 待办事项2\n```\n\n- [x] 已完成项目1\n  - [x] 已完成事项1\n  - [x] 已完成事项2\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n## 高效绘图\n\n## 流程图\n\n```text\ngraph TD\n\tA[christmas] --> B(Go sgopping)\n\tB --> C{Let me think}\n\tC -->|One| D[Laptop]\n\tC -->|Two| E[iPhone]\n\tC -->|Three| F[Car]\n```\n\n```mermaid\ngraph TD\n\tA[christmas] --> B(Go sgopping)\n\tB --> C{Let me think}\n\tC -->|One| D[Laptop]\n\tC -->|Two| E[iPhone]\n\tC -->|Three| F[Car]\n```\n\n## 序列图\n\n```text\nsequenceDiagram\n\tloop every day\n\t\tAlice ->> John: hello John, how are you?\n\t\tJohn -->> Alice: Great!\n\tend\n```\n\n```mermaid\nsequenceDiagram\n\tloop every day\n\t\tAlice ->> John: hello John, how are you?\n\t\tJohn -->> Alice: Great!\n\tend\n```\n\n## 甘特图\n\n```text\ngantt\ndateFormat YYYY-MM-DD\ntitle 产品计划表\nsection 初期阶段\n明确需求：2016-03-01, 10d\nsection 中期阶段\n跟进开发：2016-03-11, 15d\nsection 后期阶段\n走查测试：2016-03-20, 9d\n```\n\n```mermaid\ngantt\ndateFormat YYYY-MM-DD\ntitle 产品计划表\nsection 初期阶段\n明确需求: 2016-03-01, 10d\nsection 中期阶段\n跟进开发: 2016-03-11, 15d\nsection 后期阶段\n走查测试: 2016-03-20, 9d\n```\n\n## 书写数学公式\n\ninline math：`$\\dfrac{\\tfrac{1}{2}[1-(\\tfrac{1}{2})^n]}{1-\\tfrac{1}{2}} = s_n$`：$\\dfrac{\\tfrac{1}{2}[1-(\\tfrac{1}{2})^n]}{1-\\tfrac{1}{2}} = s_n$ \n\nmath block：\n\n```text\n$$\t\t\t\t\n\\dfrac{\\tfrac{1}{2}[1-(\\tfrac{1}{2})^n]}{1-\\tfrac{1}{2}} = s_n\n$$\n```\n\n$$\n\\dfrac{\\tfrac{1}{2}[1-(\\tfrac{1}{2})^n]}{1-\\tfrac{1}{2}} = s_n\n$$\n\n","tags":["markdown语法进阶"],"categories":["markdown"]},{"title":"markdown 语法基础","url":"/2021/06/ed4ad577.html","content":"> slogan：Markdown 让你爱上写作\n\n# 什么是 Markdown\n\nMarkdown 是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 **GitHub** 和技术问答网站 **StackOverFlow** 的御用书写格式\n\n<!-- more -->\n\n# Markdown 简明版使用指南\n\n## 标题\n\n标题是每篇文章必备而且最常用的格式，在 Markdown 中，如果想将一段文字定义为标题，只需要 `在这段文字前面加上 #，再在 # 后加一个空格` 即可。还可增加二、三、四、五、六级标题，总共六级，只需要增加 # ，`增加一个 # ，标题字号相应降低一级`。如图：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img src=\"https://i.loli.net/2021/08/03/PQRtAfVgNsMb36F.png\" style=\"width: 100%;\" alt=\"markdown标题\" >\n</div>\n\n## 列表\n\n列表格式也很常用，它可以让你的文稿变得井井有条。在 Markdown 中，你只需要在文字前面加上 `-` 就可以了；如果你希望是有序列表，在文字前面加上 `1. 2. 3. 即可`\n\n> **注意：** `-`、`1.` 和文字之间要保留一个字符的空格\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"markdown列表\" src=\"https://i.loli.net/2021/08/03/CXmLT7p8FBcbDsY.png\" style=\"width: 100%;\">\n</div>\n\n## 引用\n\n如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。在引用文字前加上 `>` 并与文字保留一个字符的空格，即可。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"markdown引用\" src=\"https://i.loli.net/2021/08/03/7N5OdHGtART9FCj.png\" style=\"width: 100%;\">\n</div>\n\n## 粗体和斜体\n\nMarkdown 的粗体和斜体也非常简单：\n\n- 用两个 `*` 包含一段文本就是粗体的语法\n- 用一个 `*` 包含一段文本就是斜体的语法\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"markdown粗体和斜体\" src=\"https://i.loli.net/2021/08/03/oLW5h9v7nxMdysi.png\" style=\"width: 100%;\">\n</div>\n\n## 代码高亮\n\n* 使用三个 \\` (英文状态下，tab上面的那个键) 来表示这是一段代码，如下图所示\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"markdown代码高亮\" src=\"https://i.loli.net/2021/08/03/Wy89Tv4KBjYlXSm.png\" style=\"width: 100%;\">\n</div>\n\n## 链接与图片\n\n- 链接：在 Markdown 中，插入链接只需要使用 `[显示文本](链接地址)` 即可\n- 图片：在 Markdown 中，插入图片只需要使用 `![显示文本](图片链接地址)` 即可\n\n> **注意：** 插入图片的语法和链接的语法很像，只是前面多了一个 `!`\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"markdown链接与图片\" src=\"https://i.loli.net/2021/08/03/QXR3UF8wYjpI4g1.png\" style=\"width: 100%;\">\n</div>\n\n## 分割线\n\n分割线的语法只需要另起一行，连续输入三个星号 `***` 即可分割两段文字内容。\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"markdown分割线\" src=\"https://i.loli.net/2021/08/03/8FgZqKDAh2OeI9B.png\" style=\"width: 100%;\">\n</div>\n\n## 表格\n\n当你需要在 Markdown 文稿中键入表格，代码如下：\n\n<div style=\"max-width: 75%; margin: auto; opacity: 0.95;\">\n  <img alt=\"markdown表格\" src=\"https://i.loli.net/2021/08/03/edYMQx2u9EJbPA6.png\" style=\"width: 100%;\">\n</div>\n","tags":["markdown基础"],"categories":["markdown"]},{"title":"JAVA8 新特性","url":"/2021/06/14af17e0.html","content":"> Java7 和 Java8 有很多新的不同，这里仅仅说API层面，其重点是StreamAPI和Lambda表达式，这两种写法可以让我们就像说话一样的编程\n\n<!-- more -->\n\n# 接口的默认方法和静态方法\n\n## 默认方法\n\n> 其实默认方法是 `Java` 更新中很*无可奈何*的扩展机制，因为对于大多数的接口来说，其已经有很多的实现，但是对于需要在接口上新添加的方法来说，不论是对于使用方还是jdk本身来说，其每个实现类都增加实现是一件工程量很大的事情，如果有默认实现可以减少很多的工程量。\n\n1. 正常使用\n\n   Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：\n\n   ```java\n   interface A {\n       double methodA(int a);\n\n       default double method(int a) {\n           return Math.sqrt(a);\n       }\n   }\n\n   class interAImpl implements interA {\n       @Override\n       public void methodA() {\n           // 默认方法直接像普通方法一样调用即可\n           this.method();\n       }\n   }\n   ```\n2. 两个接口中同名同参方法的覆盖\n\n   > 如果一个接口中定义了一个默认方法，而另一个父类或接口中也定义了一个同名同参的方法（无法构成重载）\n   >\n\n   ```java\n   interface InterA {\n       void methodA();\n\n       default void method() {\n           System.out.println(\"接口的默认实现方法：interA#method\");\n       }\n   }\n\n   interface InterB {\n       void methodB();\n\n       void method();\n   }\n\n   class InterAImpl implements InterA {\n       @Override\n       public void methodA() {}\n\n       @Override\n       public void method() {}\n   }\n   ```\n\n   * **类优先**原则\n\n     1. 选择父类中的方法。如果一个父类中提供了具体实现，那么接口中具有相同名称和参数的默认方法将会被忽略\n\n        ```java\n        // 类只需实现 methodB 即可\n        class InterAB extends InterAImpl implements InterB {\n\n            @Override\n            public void methodB() {}\n        }\n        ```\n     2. 接口冲突。如果一个父接口提供了一个默认方法，而另一个父接口也提供了一个具有相同名称和参数列表的方法（不论是否为默认方法），那么必须覆盖此方法来解决冲突\n\n        ```java\n        interface InterC extends InterA, InterB {\n            @Override\n            default void method() {\n                // 通过这种写法可以调用指定父接口中的默认方法，必须是默认方法\n                InterA.super.method();\n                // InterB.super.method();\n            }\n        }\n\n        class InterABImpl implements InterA, InterB {\n\n            @Override\n            public void methodA() {}\n\n            @Override\n            public void method() {\n                InterA.super.method();\n            }\n\n            @Override\n            public void methodB() {}\n        }\n        ```\n\n## 静态方法\n\nJava8中允许添加静态方法，但是静态方法必须提供实现。调用时使用静态类的调用方式即可\n\n```java\ninterface InterD {\n    static void staticMethod() {\n        System.out.println(\"InterD#staticMethod run...\");\n    }\n}\n```\n\n# Lambda 表达式\n\nLambda 的本质是一个匿名内部类，我们可以把Lambda表达式理解为是一段可传递的代码（将代码像数据一样传递，就像js里面的**hock/钩子**函数），可以写出更简洁、更灵活的代码。作为一种紧凑的代码风格，它使Java语言的表达能力得到了提升。Java中的lambda表达式可以理解为原来的匿名内部类的一个语法糖\n\n```java\n// 原来的匿名内部类\nComparator<Integer> comparator = new Comparator<Integer>() {\n    @Override\n    public int compare(Integer a, Integer b) {\n        return Integer.compare(a, b);\n    }\n};\n\n// 使用 lambda 表达式的匿名内部类\nComparator<Integer> comparator2 = (a, b) -> Integer.compare(a, b);\n```\n\n## lambda 表达式代替匿名内部类的必要条件\n\n1. 此匿名内部类的类型必须是**接口**\n2. 此接口必须**有且仅有一个待实现的方法**（可以使用 @FunctionalInterface 进行编译时检查）\n\n## lambda 表达式语法\n\n1. 基础语法\n\n   Java8 引入了 **箭头/Lambda 操作符(`->`)**，它将 lambda 表达式分为左右两部分：\n\n   * 左侧：lambda 表达式的参数列表\n   * 右侧：lambda 表达式中所需执行的代码，即：lambda 体\n\n   ```text\n   (参数列表) -> {\n       lambda体\n   }\n   ```\n2. 特殊格式\n\n   * 左侧的参数列表是有类型的，但是一般可以不用写，因为Java会自动做**类型推断**\n\n     ```java\n     Comparator<Integer> comparator2 = (Integer a, Integer b) -> Integer.compare(a, b);\n     Comparator<Integer> comparator2 = (a, b) -> Integer.compare(a, b);\n     ```\n   * 左侧没有参数时，`()` 不可以省略\n\n     ```java\n     Runnable run = () -> {\n         SecureRandom random = new SecureRandom();\n         System.out.println(random.nextInt());\n     };\n     ```\n   * 左侧只有一个参数时，`()` 可以省略\n\n     ```java\n     Consumer<String> consumer = s -> System.out.println(s);\n     ```\n   * 右侧只有一行代码时，不论是方法需不需要返回值，`{}` 都可以省略\n\n     ```java\n     Comparator<Integer> comparator = (a, b) -> Integer.compare(a, b);\n     Runnable run = () -> System.out.println(\"runnable\");\n     ```\n\n## 四大核心函数式接口\n\n1. 供给型接口\n\n   ```java\n   @FunctionalInterface\n   public interface Supplier<T> {\n       // 返回 T 类型的数据\n       T get();\n   }\n   ```\n2. 消费型接口\n\n   ```java\n   @FunctionalInterface\n   public interface Consumer<T> {\n       // 接收 T 类型参数，执行逻辑\n       void accept(T t);\n   }\n   ```\n3. 函数型接口\n\n   ```java\n   @FunctionalInterface\n   public interface Function<T, R> {\n       // 接受 T 类型参数，返回 R 类型结果\n       R apply(T t);\n   }\n   ```\n4. 断言/谓语 型接口\n\n   ```java\n   @FunctionalInterface\n   public interface Predicate<T> {\n       // 接受 T 类型参数，返回布尔值\n       boolean test(T t);\n   }\n   ```\n\n* 其他的就是这四个接口的子类，比如二元操作等等\n\n## 方法引用\n\n如果某个 lambda 表达式中的逻辑已经有实现了，就可以使用方法引用进一步简化\n\n### 语法格式\n\n1. 对象::实例方法名\n\n   ```java\n   PrintStream printStream = System.out;\n   Runnable runnable = printStream::println;\n   ```\n2. 类::静态方法名\n\n   ```java\n   Comparator<Integer> comparator3 = Integer::compare;\n   ```\n3. 类::实例方法名\n\n   ```java\n   // BiPredicate<String, String> biPredicate = (s, s2) -> s.equals(s2);\n\n   BiPredicate<String, String> biPredicate = String::equals;\n   ```\n\n**注意：**\n\n* lambda 中的参数和返回类型需要与抽象方法中的参数列表和返回类型一致\n* 若 lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用 `ClassNamw::实例方法名`\n\n## 构造器引用\n\n`ClassNamw::new`：表示的就是创建对象，但是要求该对象必须有相应的构造器\n\n```java\n// 代表返回 SecureRandom 类型的对象\nSupplier<SecureRandom> supplier = SecureRandom::new;\n```\n\n# StreamAPI\n\n> Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合处理的操作，可以执行复杂的查找、过滤、和映射数据等操作。\n> 使用 Stream 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。同时，它还提供了**并行操作**，简单的说：\n> StreamAPI 提供了一种高效且易于使用的数据处理方式，尤其是对于大集合数据的处理性能很高\n\n## Stream 操作\n\n1. 创建 Stream 流：从一个数据源中获取流\n\n   ```java\n   // 将集合转化为流\n   List<String> list = new ArrayList<>(Arrays.asList(\"11\", \"123\", \"dg\", \"dr\", \"df00\"));\n   Stream<String> stream = list.stream();\n   // 将数组转化为流\n   Stream<String> stream1 = Arrays.stream(new String[]{\"1\", \"2\", \"34\", \"21\", \"54\", \"1\", \"23\"});\n   // Stream.of()\n   Stream<String> stream2 = Stream.of(\"132\", \"ad\", \"re\");\n   // 创建无限流：通过 generate()、iterate() 创建\n   Stream<Double> stream3 = Stream.generate(Math::random); // 参数是一个供给型接口 supplier，用来传入元素的生成逻辑\n   Stream<Integer> stream4 = Stream.iterate(0, integer -> integer += 2); // 第一个参数是一个种子（开始值），第二个参数是一个 函数型接口 Function，用来传入生成逻辑\n   // int、long、double 的 stream: IntStream、LongStream、DoubleStream\n   // 可以调用 of()、generate()、iterate()等方法获取对应的流\n   // IntStream 和 LongStream 还可以通过 range() 和 rangeClose() 来获取流\n   // 除了 of() 其他方法都会源源不断的产生数据（无限流），需要使用 limit() 指定产生数据的数量\n   ```\n2. 中间操作（仅展示常用方法）：操作的中间链，对数据源的数据进行操作。每一次中间操作都会返回一个新的流\n\n   :::tip\n   stream所有的中间操作都是需要接受一个 lambda 表达式（匿名内部类）的\n   :::\n\n   1. 筛选和切片\n\n      * `filter(Predicata p)`：执行断言型接口，从流中过滤掉不符合条件元素\n      * `distinct()`：去除流种重复的元素（需要元素实现 `equals()` 和 `hashCode()`）\n      * `limit(long maxSize)`：截断流，使其元素不超过给定数量。多用于无限流\n      * `skip(long n)`：跳过元素，返回扔掉前 n 个元素的流，若流中元素不足 n 个，则返回空流，与 limit(n) 互补\n   2. 映射\n\n      * `map(Function f)`：接受一个函数作为参数，该函数会被应用到每一个元素，并将其映射为一个新的元素\n      * `mapToDouble(ToDoubleFunction f)`：接受一个函数作为参数，该函数会被应用到每一个元素，并产生一个新的 DoubleStream\n      * `mapToInt(ToIntStream f)`：接受一个函数作为参数，该函数会被应用到每一个元素，并产生一个新的 IntStream\n      * `mapToLong(ToLongStream f)`：接受一个函数作为参数，该函数会被应用到每一个元素，并产生一个新的 LongStream\n      * `flatMap(Function f)`：接受一个函数作为参数，该函数会被应用到每一个元素使其转换为一个流，最后会将这些流连接为一个流\n\n      ```java\n      List<String> list = new ArrayList<>(Arrays.asList(\"11\", \"123\", \"dg\", \"dr\", \"df00\"));\n      list.stream().map(String::toUpperCase).forEach(s -> System.out.print(s + \" \"));\n      System.out.println(\"\\n========\");\n      list.stream().flatMap(s -> Arrays.stream(s.split(\"\"))).forEach(chars -> System.out.print(chars + \" \"));\n      ```\n\n      运行结果\n\n      ```text\n      11 123 DG DR DF00 \n      ========\n      1 1 1 2 3 d g d r d f 0 0 \n      ```\n   3. 排序\n\n      * `sorted(Comparator<? super T> comparator)`：按照指定的比较器排序\n   4. 其他操作\n\n      * `peek(Consumer<? super T> action)`：可以从流中获取元素对其进行操作，该方法主要是用来调试的\n3. 终止操作：执行中间链，并产生结果\n\n   1. 查找和匹配\n\n      * `allMatch(Predicate<? super T> predicate)`：判断流中所有元素是否与 lambda 匹配\n      * `anyMatch(Predicate<? super T> predicate)`：判断流中是否存在元素与 lambda 匹配\n      * `noneMatch(Predicate<? super T> predicate)`：判断流中所有元素是否不与 lambda 匹配\n      * `findFirst()`：返回流中的第一个元素，无序流将随机返回元素\n      * `findAny()`：随机返回流中的元素\n      * `count()`：返回流中元素总数\n      * `max(Comparator<? super T> comparator)`：返回流中元素的最大值\n      * `min(Comparator<? super T> comparator)`：返回流中元素的最小值\n      * `forEach(Consumer<? super T> action)`：遍历\n      * `forEachOrdered(Consumer<? super T> action)`：顺序遍历\n   2. 归约\n\n      * `reduce(T identity, BinaryOperator<T> accumulator)`：遍历将流中元素并将其结合起来，得到一个值，返回 T\n      * `reduce(BinaryOperator<T> accumulator)`：遍历流中元素并将其结合起来，得到一个值，返回 `Optional<T>`\n   3. 聚合\n\n      * `collet(Collector c)`：将流聚合为指定形式\n\n        参数：\n\n        * `Collector.toList()`：将流中元素收集到List\n        * `Collector.toSet()`：将流中元素收集到Set\n        * ......\n      * **`Collector` 中实现了很多聚合操作，还有 `groupBy()`、`mapping()` 等方法**\n\n# Optional类\n\n> `Optional<T>` 是一个容器类，代表一个值存在或不存在，可以和那程度上避免空指针异常（NPE），其主要应用于用于**链式编程**中的判空\n\n## 常用方法\n\n* `of(T value)`：返回带有指定的当前非空值的Optional。传入值为空抛出空指针异常。\n* `ofNullable(T value)`：返回一个描述指定值的Optional，传入 null 返回一个空的Optional\n* `empty()`：返回一个空的Optional\n* `isPresent()`：判断值是否存在（最恶心的API）\n* `get()`：如果此Optional存在值，则返回该值，否则抛出NoSuchElementException（第二恶心的API）\n* `ifPresent(Consumer<? super T> consumer)`：如果对象存在，执行 consumer\n\n  ```java\n  void ifPresentTest() {\n      // 这一行的 打印语句 并不会执行\n      Optional.empty().ifPresent(System.out::println);\n      Optional.of(\"present\").ifPresent(System.out::println);\n  }\n  ```\n* `orElse(T t)`：如果有值返回值，否则返回 t\n* `orElseGet(Supplier<? extends T> other)`：如果有值返回值，否则执行 other 返回值\n\n  ```java\n  void orElseTest() {\n      Optional.of(\"123\").orElse(createObject());\n      System.out.println(\"=========\");\n      Optional.of(\"123\").orElseGet(this::createObject);\n  }\n\n  public String createObject() {\n      System.out.println(\"createObject run...\");\n      return \"object\";\n  }\n  ```\n\n  先比较一下执行结果\n\n  ```text\n  createObject run...\n  =========\n  ```\n\n  * 从结果可以知道，`orElse()` 不论 `Optional` 容器中是否为 null，都会运行一下 `createObject()` 获取对象，但是 `Optional` 在容器为 null 的情况下不会执行*供给型接口*的方法\n* `orElseThrow(Supplier<? extends X> exceptionSupplier)`：值不存在抛出异常\n* `filter(Predicate<? super T> predicate)`：如果存在一个值，并且该值与给定 predicate 匹配，则返回描述该值的Optional，否则返回一个空的Optional\n* `map(Function f)`：如果有值，对其进行处理，并返回处理后的Optional，否则，返回空Optional\n* `flatMap(Function<? super T, Optional<U>> mapper)`：与 map() 类似，但是要求 mapper 返回的值必须是Optional\n\n# 新的日期API\n\n> Java原来的 Date API 是公认的设计很“垃圾”的API，month参数从0开始，year默认加1970，而且加减时间是在修改原来的值……\n> 新的日期时间API在 **`java.time`** 包下\n\n## `LocalDate`：包含年月日\n\n```java\n// LocalDate date = LocalDate.parse(\"2018-08-30\");\nLocalDate date = LocalDate.of(2018, 8, 30); // 2018-08-30\nint year = date.getYear(); // 2018\nint year1 = date.get(ChronoField.YEAR); // 2018\nint month = date.getMonth().getValue(); // 8\nint month1 = date.get(ChronoField.MONTH_OF_YEAR); // 8\nint day = date.getDayOfMonth(); // 30\nint day1 = date.get(ChronoField.DAY_OF_MONTH); // 30\n// 当前日期属于该月第几周\nint weekOfMonth = date.get(ChronoField.ALIGNED_WEEK_OF_MONTH); // 4\n// 查看该月有多少天\nint days = date.lengthOfMonth(); // 31\n// 是否是闰年\nboolean isLeap = date.isLeapYear(); // false\n// 查看当天 年月日\nLocalDate today = LocalDate.now(); // 2018-08-30\n```\n\n## `LocalTime`：包含时分秒\n\n```java\n// LocalTime time = LocalTime.parse(\"17:18:54\");\nLocalTime time = LocalTime.of(17, 18, 54); // 17:18:54\nint hour = time.getHour(); // 17\nint minute = time.getMinute(); // 18\nint second = time.getSecond(); // 54\n```\n\n## `LocalDateTime`：包含年月日时分秒\n\n```java\nLocalDateTime ldt1 = LocalDateTime.of(2018, 9, 30, 17, 18, 54); // 2018-09-30T17:18:54\nLocalDateTime ldt2 = LocalDateTime.of(date, time); // 2018-09-30T17:18:54\n// LocalDateTime 转化为 LocalDate 或 LocalTime，转化后包含的信息减少了\nLocalDate date1 = ldt1.toLocalDate(); // 2018-09-30\nLocalTime time1 = ldt1.toLocalTime(); // 17:18:54\n// LocalTime 和 LocalDate 转化为 LocalDateTime 需要补上缺少的信息\nLocalDateTime ldt3 = date.atTime(time); // 2019-09-30T17:18:54\nLocalDateTime ldt4 = date.atTime(17, 18, 54); // 2019-09-30T17:18:54\nLocalDateTime ldt5 = time.atDate(date); // 2019-09-30T17:18:54\n```\n\n## `Instance`：从 Unix 元年（1970年1月1日 0时0分0秒）到某个时间的时间戳\n\n```java\nvoid instantTest() {\n    Instant instant = Instant.now();\n    // 转换为毫秒值\n    System.out.println(instant.toEpochMilli());\n}\n```\n\n## 日期操作\n\n1. 算时间差：\n\n   1. Duration：计算两个LocalTime或者LocalDateTime的时间差\n\n      ```java\n      LocalTime time2 = LocalTime.of(23, 59, 59);\n      Duration duration = Duration.between(time1, time2);\n      long seconds = duration.getSeconds(); // 13565\n      // 手动创建 Duration 对象\n      Duration threeMinutes = Duration.ofMinutes(3);\n      threeMinutes = Duration.of(3, ChronoUnit.MINUTES);\n      ```\n   2. Period：计算两个LocalDate之间的时长\n\n      ```java\n      LocalDate date2 = LocalDate.of(2018, 10, 31);\n      Period period = Period.between(date1, date2);\n      int monthsBetween = period.getMonths(); // 1\n      int daysBetween = period.getDays(); // 1\n      // 手动创建 Period\n      Period tenDays = Period.ofDays(10);\n      Period threeWeeks = Period.ofWeeks(3);\n      Period twoYearsSixMonthsOneDay = Period.of(2, 6, 1);\n      ```\n2. 时间比较\n\n   ```java\n   LocalDate date15 = LocalDate.of(2018,9,31);\n   date.isEqual(date15); // false\n   date.isAfter(date15); // false\n   date.isBefore(date15); // true\n   // 比较 月日\n   LocalDate birthday = LocalDate.of(1999, 9, 9);\n   MonthDay monthDay = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());\n   MonthDay currentMonthDay = MonthDay.from(LocalDate.now());\n   if (currentMonthDay.equals(monthDay)) {\n       System.out.println(\"happy birthday!\");\n   }\n   ```\n3. 时间加减\n\n   ```java\n   LocalTime localTime = LocalTime.now();\n   // 加 2 小时\n   final LocalTime plusHoursTime = localTime.plusHours(2);\n   // 减 2 小时\n   final LocalTime minusHoursTime = localTime.minusHours(2);\n   LocalDate localDate = LocalDate.now();\n   // 加 1 周\n   final LocalDate plusDate = localDate.plus(1, ChronoUnit.WEEKS);\n   ```\n\n   * 其他两个类都差不多\n4. 格式化：DateTimeFormatter\n\n   ```java\n   void dateTimeFormatterTest() {\n       LocalDateTime time = LocalDateTime.now();\n       DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n       System.out.println(time.format(dateTimeFormatter));\n   }\n   ```\n\n> 新的日期 API\n","tags":["Java8新特性"],"categories":["Java新特性"]},{"title":"linux 脚本","url":"/2021/01/3353fd6d.html","content":"# linux命令\n\n> 需要注意的是，linux中，几乎所有的命令都可以使用 `man` 命令查看其详细信息，如参数等等...\n\n## 常用命令\n\n1. 关机：`shutdown -h`，`halt`，`init 0`，`poweroff`\n\n2. 重启：`shutdown -r`，`reboot`，`init 6`\n\n<!-- more -->\n\n3. pwd：查看当前工作目录\n\n4. ls：查看目录内容\n\n   * -l：列表显示\n   * -a：显示所有，包括隐藏文件\n   * -h：人性化显示\n   * -d：只显示目录，不查看内容\n\n   目录结构：linux的目录是从 '/' 开始的，是根目录\n\n   ```text\n   /bin：大部分的系统命令\n   /boot：启动相关目录\n   /dev：设备文件目录，linux下面所有的设备都是文件\n   /etc：配置文件目录，几乎所有的配置都在这个目录下面\n   /home：普通用户的 家 目录，一个用户对应一个文件夹\n   /lib：库文件目录\n   /lib64：64位库文件目录\n   /lost+found：系统异常时临时保存数据，用于恢复操作\n   /media：媒体目录（CD、光盘等）\n   /mnt：挂载目录，通用的挂载点（U盘、磁盘等）\n   /opt：安装系统非必需软件目录\n   /proc：虚拟文件系统，会映射硬件信息\n   /root：root用户的 家 目录\n   /sbin：超级用户才可以执行的命令目录\n   /selinux：linux的一套安全机制，非常复杂，通常不用\n   /srv：存放本机或本机服务器的数据或服务\n   /sys：也是虚拟文件系统，可能随时销毁\n   /tmp：临时文件\n   /usr：存放用户安装的应用程序\n   /var：系统产生的不可自动销毁的文件。如：日志、缓存等\n   ```\n\n5. 注意事项：\n\n   * 命令格式：命令 [选项] [参数]\n\n   * 出问题查看帮助文档：\n     1. 命令自带的帮助文档，一般是 `-h` 或 `–help`\n     2. 找那个男人！`man` 命令\n\n## vim终端编辑器\n\n### 介绍：\n\n> vim是对vi的扩展被誉为“终端编辑器之神”\n\n### 安装：\n\ncentos：`yum install -y vim`\n\nubuntu：`apt install -y vim`\n\n### 工作模式\n\n* 阅读(正常)模式、插入模式、编辑模式\n\n  ```shell\n  $ vim filename # 打开文件，文件不存在则创建，同时进入阅读模式\n                 # esc 切换到正常模式\n                 # shift+zz：保存退出\n  $ vim filename +n # 打开文件，定位到第 n 行\n  $ vim filename + # 打开文件，定位到末尾\n  ```\n  \n  正常模式下的快捷命令：\n\n  ```text\n  gg # 定位到首行\n  G # 定位到尾行\n  ngg # 定位到n行\n  ^ # 定位到行首\n  $ # 定位到行尾\n  yy # 复制光标所在行\n  p # 粘贴\n  nyy # 复制光标所在的n行\n  dd # 删除光标所在行\n  ndd # 删除光标所在的n行\n  u # 撤销：undo\n  ctrl + r # redo\n  ```\n\n* 插入模式\n\n  ```text\n  i：在光标处插入\n  I：在行首插入\n  a：在光标下一个字符处插入\n  A：在行尾插入\n  o：在光标下一行插入空行\n  O：在光标上一行插入空行\n  s：删除光标所在字符并插入\n  S：删除光标所在行并插入\n  ```\n\n* 编辑模式：是对整个文件进行操作，如保存等\n\n  ```text\n  正常模式下输入英文冒号进入编辑模式\n  :w --> 保存\n  :q --> 退出\n  :wq --> 保存退出 == shift + zz\n  :x --> 保存退出\n  :q! --> 强制退出\n  :set nu\t--> 显示行号\n  :set nonu --> 隐藏行号\n  :行号 --> 定位到指定行号\n  /内容 --> 查找指定内容，n一个，N上一个\n  :%s/原内容/新内容 --> 替换原内容为新内容，全部替换\n  :m,ns/原内容/新内容 --> 替换[m, n]行的原内容为新内容\n  ```\n\n## 文件及文件夹操作\n\n```shell\n$ touch filename1 filename2... # 创建文件\n$ rm filename... # 删除文件。-f：强制删除; -r：递归删除\n$ cp source-path target-path # 拷贝(重命名)\n$ mv source-path target-path # 移动(重命名)\n$ mkdir # 创建文件夹 -p:创建多级目录\n$ rmdir # 删除文件夹，但是只能删除空文件夹\n```\n\n## 查看文件\n\n```shell\n$ cat filename # 从上往下查看文件内容（mao 一眼）\n$ tac filename # 从下往上查看文件内容（反着 mao 一眼）\n$ head -n filename # 查看文件开头n行，默认10行\n$ tail -n filaneme # 查看文件末尾n行，默认10行\n$ more filename # 查看文件，首页充满屏幕，回车下行，空格下页，看到结尾自动结束，q退出查看\n$ less filename # 查看文件，首页充满屏幕，回车下行，空格下页，看到结尾不会自动结束，q退出查看，可以上下箭头翻页\n$ nl filename # 同cat，显示行号\n$ wc filename # 统计文件信息：行数 | 单词数 | 字节数 | 文件名\n# 说明：more和less更多是结合管道使用，如 ls /etc | more\n# \"|\" 就是管道\n```\n\n## 用户及用户组\n\n```shell\n# ============用  户============\n$ whoami # 我是谁！\n$ useradd user # 创建用户\n               #    -d：指定家目录\n               #    -u：指定用户id（默认大于500）\n               #    -g：指定组id（默认大于500）\n               #    -s：指定shell解释器\n$ passwd user # 设置指定用户的密码，若不指定设置\n$ userdel user # 删除用户，-rf删除用户相关目录，否则需要手动删除\n$ su - # 切换到指定用户，不指定默认切换到root用户。如果不加 \"-\", 只会切换目录及用户身份，但是不会切换环境\n# ============用户组===========\n$ groupadd group-name # 创建用户组\n$ groupdel group-name # 删除用户组\n$ gpasswd -a user group-name # 将用户添加到组\n$ gpasswd -d user group-name # 将用户从组中删除\n$ chgrp group-name file # 改变文件所属组\n$ chown user[:group-name] file # 改变文件拥有者[及组]\n# ===========涉及文件==========\n$ /etc/passwd # 存放用户信息\n$ /etc/group # 存放用户组信息\n$ /etc/shadow # 存放用户密码\n# ===========用户身份=========\n#     #：root用户\n#     $：普通用户\n```\n\n## 文件权限管理\n\n* linux下，文件的权限有：所有者、所属组、其他人 的区分\n\n  * `ls -l` 就能看到\n\n    ```text\n    -rw-r--r-- root root ...\n    第一位是文件类型 -文件 d文件夹 l软链接\n    后面9列表示权限，三个一组，分别是：所有者 所属组 其他人\n    ```\n\n* 权限有：读(r)、写(w)、执行(x)\n\n* 使用 `chmod` 命令修改文件的权限\n\n  * 格式：`chmod [身份] [修改] [权限] 文件`\n    * 身份：u-所有者；g-所属组；o-其他；a-all\n    * 修改：+ 添加；- 去掉；= 设置\n    * 权限：r(100) w(010) x(001) -(000)\n  * 例如：\n    * `chmod u+w 1.txt` ：为所有者添加写权限\n    * `chmod 754 1.txt` ：设置权限为 所有者rwx，所属组wx，其他人r\n\n## 链接文件\n\n* 软链接：类似于windows下面的快捷方式\n* 硬链接：修改文件时会同步修改目标文件，注意，存在两个文件！！！\n* 命令： `$ ln [-s] 源文件 文件名 # 创建链接到源文件的软链接，不加 -s 就是创建的硬链接` \n\n## 文件查找\n\n```shell\n$ tree / # 查看目录结构，-L指定层级深度: tree / -L 2\n$ find # 查找文件，用法相当灵活，但是效率不高\n       # -name：指定名字\n       # -type：指定类型，b块设备 c字符设备 d文件 p管道 l链接...\n       # -size：指定大小，单位K/M/G，+大于 -小于\n       # -perm：指定权限\n       # -user：指定用户\n       # -group：指定组\n       # -maxdepth：指定最大层级深度\n       # ...\n       # 如：find / -name 1.txt 从 / 下面开始找名字为 1.txt 的文件\n$ whereis 程序名 # 查找程序使用\n$ which 命令 # 专用于查找命令\n\n$ alias # 给某个程序取别名 alias ls='ls --color=auto'\n$ unalias # 取消取别名\n\n$ grep # 正则匹配查找\n       # -i：忽略大小写\n       # -n：显示行号\n       # grep root /etc/passwd 查找该文件下包含root的行\n       # ls /bin | grep '^m' 查找bin下m开头的命令\n```\n\n## 磁盘挂载\n\n* 磁盘的使用流程：磁盘 => 分区 => 格式化 => 挂载\n* 磁盘的文件系统有很多，如果不支持需要装驱动\n\n```shell\n$ fdisk -l # 查看分区\n$ mount # 查看所有的挂载信息\n$ mount [-t 文件系统] 磁盘分区 挂载点 # 将磁盘挂载到挂载点。挂载点就是挂载到哪个目录\n$ umount 磁盘分区或挂载点 # 取消挂载\n# /etc/fstab 中记录了开机就要挂载的磁盘的信息\n$ df [磁盘] -h # 查看磁盘分区使用情况，默认当前磁盘\n$ du [目录] -h # 查看指定目录的使用情况，默认当前目录\n```\n\n## 管道\n\n* `|` ：就是将前一个命令的输出作为后一个命令的输入\n* 实例：\n  * `ls -l /etc | more`\n  * `ls /etc | grep '^vi'`\n* 注意：有些命令是不接受管道参数的，可以使用 `xargs` 使用\n  * `find -type d | xargs rm -r`\n\n## 重定向\n\n* 打开任意程序，系统就会自动创建三个文件流：标准输入(0)、标准输出(1)、标准错误(2)\n  * 这三个文件流默认指向终端\n* 输出重定向：\n  * `ls /etc > 1.txt` ：将 ls 输出的内容保存到 1.txt 中，文件不存在会创建，存在会覆盖\n  * `echo 'abc' >> 1.txt`：将 'abc' 输出到 1.txt 中，`>>` 表示追加\n* 错误重定向：\n  * `ls /abc 2> 2.txt`：将错误输出重定向到 2.txt 中\n\n* 全部重定向：\n  * `ls /abc . &>3.txt`：将所有输出重定向到 2.txt 中\n\n## 系统服务\n\n```shell\n$ ping 地址 # ping 地址，检测是否连通\n$ ifconfig # 查看网卡信息，也可以设置，但是一般不用这个设置\n$ ifup 网卡名 # 启动网卡\n$ ifdown 网卡名 # 关闭网卡\n$ service network start|stop|restart # 服务 network 启动|停止|重启\n$ systemctl start|stop|restart network # 新系统 network 启动|停止|重启\n$ netstat # 查看监听端口信息\n$ free # 查看内存使用情况\n$ w # what 简写，查看系统正在做什么\n$ top # 查看所有执行的程序，是w的详细版，3秒刷新一次\n$ vmstat # 查看虚拟内存的使用情况\n$ ps # 查看进程信息，通常使用参数 aux 查看所有|显示用户|不在终端的\n$ kill -9 pid # 通过进程id杀进程\n```\n\n## 压缩解压\n\n### zip/unzip\n\n* `zip zip-name file1 file2 file3...` \n* `unzip zip-name`  \n\n### gzip/gunzip\n\n* 压缩时不能压缩目录，会删除源文件。压缩文件后缀 gz\n\n* `gzip 1.txt` ：将 1.txt 压缩成 1.txt.gz\n* `gunzip 1.txt.gz`：将 1.txt.gz 解压\n* `gzip -d 1.txt.gz`：功能同 gunzip\n\n### bzip2/bunzip2\n\n* 用法同上，后缀bz2\n* 说明：-k 参数可以在操作后保留原文件\n\n### 打包解包工具：tar\n\n* 本身只提供打包解包功能，后缀是 .tar\n  * 说明：tar.gz简写为tgz，tar.bz2可以简写为tbz2或tbz\n* 参数很多，1、2、3不能同时使用\n  1. -c：打包\n  2. -x：拆包\n  3. -t：查看内容，不拆包\n  4. -f：指定文件\n  5. -v：显示详细信息\n  6. -z：使用gzip/gunzip工具\n  7. -j：使用bzip2/bunzip2工具\n\n## 软件安装\n\n### 源码安装：需要对应的编译工具\n\n1. 配置：configure\n2. 编译：make\n3. 安装：make install\n\n### rpm安装\n\n1. 介绍：rpm 时 RPM Package Manager的缩写，也是后缀，还是命令\n2. 命令参数：\n   * -i：安装\n   * -e：卸载\n   * -v：显示详细信息\n   * -h：像是安装进度\n   * -u：升级\n   * -q：查询\n3. 例子\n   * `rpm -ivh XXX.rpm` \n\n### yum/apt等安装\n\n1. 说明：yum/apt是最简单的安装方式，不用考虑复杂的包依赖关系\n2. 命令（apt）：\n   1. 安装：`install`\n   2. 卸载：`remove`\n\n## 特殊命令\n\n1. `seq m n`：产生从m到n的整数\n\n   ```shell\n   seq 1 10\n   ```\n\n2. `expr`：将表达式进行运算\n\n   ```shell\n   expr 2 \\* 3\n   expr 2 + 3\n   ```\n\n3. `sed` ：处理文件流\n\n   * 格式：`sed [参数] 指令 文件`\n\n   * 参数：\n\n     1. -n：结合命令p使用，用于打印内容，如 `1p` `3p` `^p` `$p` ` 5,$p` `3,7p` 等\n     2. -i：默认不加，即不会修改文件内容，加上该参数会真的修改文件\n\n   * 命令：\n\n     1. p：结合 n 打印内容\n     2. a：增加\n     3. d：删除\n     4. c：取代\n     5. s：替换，支持正则\n\n   * 实例：\n\n     ```shell\n     # 打印\n     $ sed -n '2p' test.txt # 打印第2行\n     $ sed -n '2,$p' test.txt # 打印2到最后一行\n     # 增加\n     $ sed '1a xxx' test.txt # 在1行后面添加 xxx\n     $ sed '3,5a xxx' test.txt # 在3-5行每行下面添加 xxx\n     # 删除\n     $ sed '2d' test.txt # 删除第2行内容\n     $ sed '2,5d' test.txt # 删除2-5行内容\n     # 取代\n     $ sed '2c xxx' test.txt # 将第2行替换为xxx\n     $ sed '2,5c xxx' test.txt # 将2-5行整体替换为xxx\n     # 替换\n     $ sed 's/af/xxx/g' test.txt # 将所有的af替换为xxx\n     $ sed 's/a\\w*f/xxx/g' test.txt # 将所有的匹配 a\\w*f 的内容替换为xxx\n     $ sed '5,7s/af/xxx/g' test.txt # 将5-7行的af替换为xxx\n     ```\n\n# shell脚本\n\n## 认识shell\n\n1. shell是介于用户和内核之间的一个工具用户的操作通过shell进行解析，然后传递给内核\n\n2. shell有两种表现形式：交互式（单步执行），脚本式（文本执行）\n3. 我们通常说的shell编程时指第二种\n4. shell类型\n   1. bash（linux默认）、ash、csh、ksh等\n   2. 环境变量 $SHELL 标明了系统使用的shell类型\n   3. /etc/shells定义了系统可用的shell\n\n## Hello World\n\n```shell\n#! /bin/bash\n\necho 'hello world!'\n```\n\n* 添加执行权限：`chmod u+x 文件名`\n* 执行：\n  1. 找到文件直接执行，需要添加执行权限，当前目录下： `./文件名`\n  2. 使用shell直接执行，无需添加执行权限：`/bin/bash 文件名`\n\n## 书写shell\n\n### 规范\n\n1. 指定shell解析器：`#! /bin/bash`\n2. 注释符号：`#`\n3. 非常严格的使用习惯\n\n### 变量\n\n1. 声明：`name=\"123\"` 等号两边不能有空格\n\n2. 回收：`unset name` 回收后就取不到变量的值了\n\n3. 声明为只读：`readonly name` 声明为只读后变量的值就不能修改了\n\n4. 使用变量：\n\n   1. 字符串内：`\"${name} jdioafsfdlasd\"`\n\n   2. 字符串外：`$name`\n\n      **注意：**加大括号的使用方式在哪里都不会有问题\n\n### 变量类型\n\n1. 本地变量：只能在shell脚本内部使用\n2. 环境变量：在整个系统中都可以使用，通常全部大写，使用最多的是 `PATH`\n   * 修改：\n     1. 系统：`/etc/profile`\n     2. 用户：`~/.bash_profile`\n   * 导出：`export PATH=$PATH:/root/shell`\n3. 位置变量\n   * `$0`：脚本文件的名字\n   * `$1-$9` ：接收的参数\n4. 特殊变量\n   * `$*`：接受的所有参数\n   * `$#`：参数的个数\n\n### 文件包含\n\n1. `. 文件名`：包含当前目录的文件\n2. `source 文件名`：包含当前目录的文件\n\n### 字符串\n\n1. 双引号：可以使用除`$`, `\"`, `\\`, ` 外的所有字符\n\n2. 单引号：所有的字符都当作字符处理，不解析变量\n\n3. 反引号：表示命令执行的结果\n\n   * ```shell\n     echo `pwd` # /root/shell\n     ```\n\n### 字符串操作\n\n```shell\n#! /bin/bash\n\nstr=\"abcdefghijkl\"\n\necho ${#str} # 12：取字符串的长度\necho ${str:3:2} # de：从字符串3索引位置截取2个字符\nprintf \"hello %s %d\\n\" \"world\" 123456 # 格式化输出\n```\n\n### 数组操作\n\n```shell\n#! /bin/bash\n\narray=(a b c d)\n\necho ${array[0]}\necho ${array[1]}\n```\n\n### 运算\n\n1. 数值比较\n\n   1. -lt：小于\n   2. -le：小于等于\n   3. -gt：大于\n   4. -ge：大于等于\n   5. -eq：等于\n   6. -nq：不等于\n\n2. 字符串比较：\n\n   1. =：等于\n   2. !=：不等于\n   3. -n：字符串长度不为0，结果为真\n   4. -z：字符串长度为0，结果为真\n\n3. 文件判断：前提是文件存在\n\n   1. -f：普通文件\n   2. -d：目录文件\n   3. -w：文件可写\n   4. -x：文件可执行\n   5. -s：文件至少有一个字符\n   6. -c：字符设备\n   7. -b：块设备\n\n4. 逻辑判断：\n\n   1. -a (&&)：and，逻辑与\n\n      ```shell\n      [ 2 -gt 1 -a 3 -lt 4 ]\n      [ 3 -lt 4 ] && [ 2 -gt 1 ]\n      ```\n\n   2. -o (||)：or，逻辑或\n\n   3. ! ：逻辑非\n\n5. 命令：\n\n   * test：可以测试比较结果，但是true为0，false为1\n   * 简写形式：`[ 表达式 ]` \n\n### 分支结构\n\n1. if\n\n   ```shell\n   #! /bin/bash\n   \n   if [ 2 -lt 3 ]; then\n       echo '2 < 3'\n   fi\n   ```\n\n2. if-else\n\n   ```shell\n   #! /bin/bash\n   \n   if [ $1 = \"abc\" ]; then\n       echo \"abc\"\n   else\n       echo \"not abc\"\n   fi\n   ```\n\n3. if-else if-else\n\n   ```shell\n   #! /bin/bash\n   \n   read -p \"input a str: \" ch # 从终端读取字符\n   \n   if [ '1' = $ch ]; then\n       echo \"$ch 1\"\n   elif [ '2' = $ch ]; then\n       echo \"$ch 2\"\n   else if [ '3' = $ch ]; then\n       echo \"$ch 3\"\n   else\n       echo \"$ch other\"\n   fi\n   fi\n   ```\n\n4. case\n\n   ```shell\n   #! /bin/bash\n   \n   read -p \"input a str: \" c\n   \n   case $c in \n   [a-z])\n       echo \"character\"\n   ;;\n   [1-9])\n       echo \"number\"\n   ;;\n   *)\n       echo \"others\"\n   ;;\n   esac\n   ```\n\n### 循环结构\n\n#### for 循环\n\n1. 基本用法\n\n   ```shell\n   #! /bin/bash\n   \n   for x in a b c\n   do\n       echo $x\n   done\n   ```\n\n2. 打印1-10\n\n   ```shell\n   #! /bin/bash\n   \n   for x in `seq 1 10`\n   do\n       echo $x\n   done\n   ```\n\n3. 计算1-10的和\n\n   ```shell\n   #! /bin/bash\n   \n   for x in `seq 1 10`\n   do\n       let sum+=$x\n   done\n   echo $sum\n   ```\n\n4. 打印1-10（2）\n\n   ```shell\n   #! /bin/bash\n   \n   for ((i=1;i<10;i++))\n   do\n       echo $i\n   done\n   ```\n\n5. 打印根目录下的文件和文件夹\n\n   ```shell\n   #! /bin/bash\n   \n   for x in /*\n   do\n       echo $x\n   done\n   ```\n\n#### while循环\n\n```shell\n#! /bin/bash\n\ni=1\nwhile [ $i -le 10 ]\ndo\n    echo $i\n    # i=$[$i+1] # 变量计算的几种写法...\n    # let i+=1\n    ((i++))\ndone\n```\n\n#### until循环\n\n```shell\n#! /bin/bash\n\ni=1\nuntil [ $i -gt 10 ]\ndo\n    echo $i\n    ((i++))\ndone\n```\n\n#### break\n\n```shell\n#! /bin/bash\n\nwhile : # while的死循环写法\ndo\n    read -p \"input a char: \" ch\n    case $ch in \n        # [1-5]) 1-5\n        1|3|5)\n            echo \"1-5\"\n        ;;\n        *)\n            echo \"other\"\n            break\n        ;;\n    esac\ndone\n```\n\n#### continue\n\n```shell\n#! /bin/bash\n\ni=0\nwhile [ $i -le 10 ]\ndo\n    if [ $[$i%3] -eq 0 ]; then\n        ((i++))\n        continue;\n    fi\n    echo $i\n    ((i++))\ndone\n```\n\n### 函数\n\n1. 简单\n\n   ```shell\n   #! /bin/bash\n   \n   test()\n   {\n       echo \"hello function!\"\n   }\n   test\n   ```\n\n2. 带参数\n\n   ```shell\n   #! /bin/bash\n   \n   test()\n   {\n       echo $0\n       echo $1\n       echo $2\n       echo $#\n       echo $*\n   }\n   test 123 abc\n   ```\n\n3. 带返回值\n\n   ```shell\n   #! /bin/bash\n   \n   test()\n   {\n       return 123\n   }\n   test\n   echo $? # 通过 #? 获取函数的返回值\n   ```\n\n### 黑洞文件\n\n> /dev/null\n\n* 说明：该文件无论怎么读取或者写入都是空的\n* 作用：将任意内容写入以屏蔽错误、清空文件内容等\n* 实例：`cat /dev/null > xx.log`","tags":["linux","shell","linux 脚本"],"categories":["linux","linux shell"]},{"title":"docker-compose","url":"/2021/01/85512bce.html","content":"# 为什么要用docker\n\n* 一个完整的环境应该包括**应用节点（app）**、**数据库（MySQL）**、**缓存（`redis`）**，为了管理方便，是否可以将这些节点全部**构建在一个容器**中运行呢？答案是可以的，但是并不推荐这么做，因为它违背了Docker**运行环境隔离**的设计初衷。\n\n  * 每个节点都有自己的运行环境，如果合在一起，那么他们的环境也要撮合在一起\n\n* **怎么简化多节点项目环境的维护呢？**\n  \n  * 使用docker-compose：通过`docker-compose.yml`描述项目中各节点的容器信息及依赖信息，然后通过docker-compose一件构建或启动\n\n<!-- more -->\n\n# 命令及常用yml文件配置     \n\n## 安装docker-compose（推荐参考官方文档：[官方文档链接](https://docs.docker.com/compose/install/)）\n\n1. 下载：下载当前稳定版本\n\n   ```shell\n   sudo curl -L \"https://get.daocloud.io/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)\" -o  /usr/local/bin/docker-compose\n   \n   # 下面的很慢\n   sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n   ```\n\n2. 将可执行权限应用于二进制文件：\n\n   ```shell\n   sudo chmod +x /usr/local/bin/docker-compose\n   ```\n\n   * **注意**：如果命令`docker-compose`在安装后失败，请检查您的路径。您也可以创建指向`/usr/bin`或路径中任何其他目录的符号链接。\n\n3. 测试安装\n\n   ```shell\n   $ docker-compose --version\n   docker-compose version 1.25.0, build 1110ad01\n   ```\n\n## 命令：docker-compose\n\n* 这是用`docker-compose --help`命令获取到的命令\n\n  ```text\n  build               Build or rebuild services\n  bundle              Generate a Docker bundle from the Compose file\n  config              Validate and view the Compose file\n  create              Create services\n  down                Stop and remove containers, networks, images, and volumes\n  events              Receive real time events from containers\n  exec                Execute a command in a running container\n  help                Get help on a command\n  images              List images\n  kill                Kill containers\n  logs                View output from containers\n  pause               Pause services\n  port                Print the public port for a port binding\n  ps                  List containers\n  pull                Pull service images\n  push                Push service images\n  restart             Restart services\n  rm                  Remove stopped containers\n  run                 Run a one-off command\n  scale               Set number of containers for a service\n  start               Start services\n  stop                Stop services\n  top                 Display the running processes\n  unpause             Unpause services\n  up                  Create and start containers\n  version             Show the Docker-Compose version information\n  ```\n\n* 常用命令\n\n  ```shell\n  docker-compose up -d nginx            # 构建建启动nignx容器\n  docker-compose exec nginx bash        # 登录到nginx容器中\n  docker-compose down                   # 删除所有nginx容器,镜像\n  docker-compose ps                     # 显示所有容器\n  docker-compose restart nginx          # 重新启动nginx容器\n  docker-compose run --no-deps --rm php-fpm php -v # 在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器\n  docker-compose build nginx            # 构建镜像\n  docker-compose build --no-cache nginx # 不带缓存的构建。\n  docker-compose logs nginx             # 查看nginx的日志 \n  docker-compose logs -f nginx          # 查看nginx的实时日志\n  docker-compose config -q              # 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。 \n  docker-compose events --json nginx    # 以json的形式输出nginx的docker日志\n  docker-compose pause nginx            # 暂停nignx容器\n  docker-compose unpause nginx          # 恢复ningx容器\n  docker-compose rm nginx               # 删除容器（删除前必须关闭容器）\n  docker-compose stop nginx             # 停止nignx容器\n  docker-compose start nginx            # 启动nignx容器\n  ```\n\n## 配置（只列出常用的，详细信息参考  [官方文档](https://docs.docker.com/compose/compose-file/)）\n\n1. 配置文件：实际上就是docker运行命令的参数\n\n   ```yml\n   version: \"3.3\"\n     services:\n       nginx: # 服务名\n         image: nginx # 镜像名\n         post: # 映射端口：数组形式\n           - \"80:80\"\n         links: # 链接了那个容器：可以写容器名，可以写ip\n           - app\n         volumes: # 数据卷，不解释了\n           - \"./nginx.conf.d/:/etc/nginx/conf.d/\"\n       app: # 服务名\n         image: luban/app\n   ```\n\n## 案例\n\n1. redis\n\n   ```yml\n   version: '3.6'\n     services:\n       redis:\n       image: redis:5.0.0\n       container_name: redis\n       command: redis-server --requirepass ann-zhgy\n       ports:\n         - \"6379:6379\"\n       volumes:\n         - ./data:/data\n   ```\n\n2. nexus\n\n   ```yml\n   version: '3.3'\n     services:\n     nexus:\n       restart: always\n       image: sonatype/nexus3\n       container_name: nexus\n       ports:\n         - 8081:8081\n       volumes:\n         - ./data:/nexus-data\n     volumes:\n     data:\n   ```\n   注意：新版本密码在 cat /var/lib/docker/volumes/nexus_data/_data/admin.password\n\n3. gitlab\n\n   ```yml\n   version: '3.3'\n     services:\n       web:\n         image: 'twang2218/gitlab-ce-zh'\n         restart: always\n         hostname: 'ip'\n         environment:\n           TZ: 'Asia/Shanghai'\n           GITLAB_OMNIBUS_CONFIG: |\n             external_url 'http://ip'\n             gitlab_rails['gitlab_shell_ssh_port'] = 2222\n             unicorn['port'] = 8888\n             nginx['listen_port'] = 80\n         ports:\n           - '8673:80'\n           - '4433:443'\n           - '2222:22'\n         volumes:\n           - ./config:/etc/gitlab\n           - ./data:/var/opt/gitlab\n           - ./logs:/var/log/gitlab\n   ```","tags":["docker","docker-compose","docker一键构建并启动"],"categories":["docker-compose"]},{"title":"docker","url":"/2021/01/f255ffad.html","content":"\n# Docker简介\n\n## docker是什么\n\n> Docker 是一个开源的**应用容器引擎**，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。<right-bq>——[百度百科](https://baike.baidu.com/item/Docker)</right-bq>\n\n<!-- more -->\n\n## docker解决的问题\n\n1. 开发环境、测试环境、生产环境不一致\n2. 项目迁移困难\n3. 更轻松地维护和扩展\n\n## docker与虚拟机相比的优势\n\n1. 传统虚拟机对资源利用率并不高，因为他是在系统上模拟出一套完整的系统，docker直接运行于宿主机，资源利用率高\n2. docker启动在秒级， 虚拟机在分钟级\n3. docker硬盘使用大小MB级，虚拟机一般为GB级\n4. 一台服务器一般可以支持上千个docker容器，但是仅能支持几十个虚拟机\n\n# 基本组成\n\n## 镜像（image）\n\n1. Docker镜像是什么\n   * Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n2. **分层存储**\n   * 在 Docker 设计时，充分利用 **UnionFS（联合文件系统）** 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。\n   * 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n   * 分层存储的特征使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。\n\n## 容器(可以看成一个简易的linux环境)\n\n* 镜像（`Image`）和容器（`Container`）的关系，就像是面向对象程序设计中的 `类` 和 `实例` 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n* 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 [命名空间](https://en.wikipedia.org/wiki/Linux_namespaces)。因此容器可以拥有自己的 `root` 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。\n* 每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 **容器存储层**。\n* 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n* 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 **数据卷（Volume）**、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。\n* 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。\n\n## 仓库\n\n* 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，[Docker Registry](https://yeasy.gitbooks.io/docker_practice/repository/registry.html) 就是这样的服务。\n* 一个 **Docker Registry** 中可以包含多个 **仓库**（`Repository`）；每个仓库可以包含多个 **标签**（`Tag`）；每个标签对应一个镜像。\n* 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 `latest` 作为默认标签。\n\n## docker架构\n\n1. 架构图\n\n   ![docker架构图](https://i.loli.net/2021/01/17/sR1weMvSoH7mhlA.jpg)\n\n# 安装\n\n\n## ubuntu\n\n1. 卸载旧版本\n\n   ```shell\n   $ sudo apt remove docker docker-engine docker.io\n   ```\n\n2. 安装\n   1. 方式一：使用 apt 安装\n\n      * 由于 `apt` 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。\n   \n        ```shell\n        $ sudo apt update\n        $ sudo apt install -y apt-transport-https ca-certificates curl software-properties-common\n        ```\n   \n      * 为了确认所下载软件包的合法性，需要添加软件源的 `GPG` 密钥\n      \n        ```shell\n        $ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n        \n        # 官方源\n        # $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add \n        ```\n      \n      * 向 `source.list` 中添加 Docker 软件源\n      \n        ```shell\n        $ sudo add-apt-repository \\\n            \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\\n            $(lsb_release -cs) \\\n            stable\"\n        \n        # 官方源\n        # $ sudo add-apt-repository \\\n        #    \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n        #    $(lsb_release -cs) \\\n        #    stable\"\n        ```\n   \n      * 更新`apt`软件包缓存，并安装`docker-ce`:\n   \n        ```shell\n        $ sudo apt update\n        \n        $ sudo apt -y install docker-ce docker-ce-cli containerd.io\n        ```\n   **注意：** 所有的官方源速度会比较慢\n\n   2. 使用脚本自动安装\n\n      * 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通   过 `--mirror` 选项使用国内源进行安装：\n\n        ```shell\n        $ curl -fsSL get.docker.com -o get-docker.sh\n        $ sudo sh get-docker.sh --mirror Aliyun\n        # $ sudo sh get-docker.sh --mirror AzureChinaCloud\n        ```\n\n        执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。\n\n3. 启动`docker-ce`\n\n   ```shell\n   $ sudo systemctl enable docker\n   $ sudo systemctl start docker\n   ```\n\n4. 测试docker安装\n\n   ```shell\n   docker --version\n   ```\n\n* 参照[官方文档](https://docs.docker.com/install/linux/docker-ce/ubuntu/)\n\n## centos\n\n1. 卸载旧版本\n\n   ```shell\n   $ sudo yum remove docker \\\n                     docker-client \\\n                     docker-client-latest \\\n                     docker-common \\\n                     docker-latest \\\n                     docker-latest-logrotate \\\n                     docker-logrotate \\\n                     docker-selinux \\\n                     docker-engine-selinux \\\n                     docker-engine\n   ```\n\n2. 安装\n\n   1. 使用yum安装\n\n      1. 安装依赖包\n\n         ```shell\n         $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n         ```\n\n      2. 配置国内源   \n\n         ```shell\n         $ sudo yum-config-manager \\\n             --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo\n         \n         # 官方源\n         # $ sudo yum-config-manager \\\n         #     --add-repo \\\n         #     https://download.docker.com/linux/centos/docker-ce.repo\n         ```\n   \n      3. 安装`docker-ce`\n\n         ```shell\n         $ sudo yum makecache fast\n         $ sudo yum install docker-ce\n         ```\n\n   2. 使用脚本自动安装\n\n      ```shell\n      $ curl -fsSL get.docker.com -o get-docker.sh\n      $ sudo sh get-docker.sh --mirror Aliyun\n      # $ sudo sh get-docker.sh --mirror AzureChinaCloud\n      ```\n\n3. 启动`docker-ce`\n\n   ```shell\n   $ sudo systemctl enable docker\n   $ sudo systemctl start docker\n   ```\n\n4. 测试docker安装\n\n   ```shell\n   docker --version\n   ```\n\n* 参照[官方文档](https://docs.docker.com/install/linux/docker-ce/centos/)\n\n# 案例：hello-world\n\n## 配置阿里云镜像加速服务\n\n* 前往[阿里云官网](https://promotion.aliyun.com/ntms/act/kubernetes.html)，登录账号，搜索 -->容器镜像服务，然后点进去，按提示操作，之后可以找到镜像加速器，按提示操作即可\n\n  ![image](https://i.loli.net/2021/01/17/jzAF2ULyYHIxaJQ.png)\n\n## 运行hello-world\n\n1. 命令：\n   ```shell\n   sudo docker run hello-world\n   ```\n\n2. 第一次运行时，容器会在阿里云仓库中拉取hello-world镜像，然后再运行\n\n## 运行原理\n\n* Docker是一个基于C/S架构的系统，docker的守护进程运行在主机上，然后通过Socket链接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器（可以有很多）。**容器是一个运行时环境，就是docker logo的鲸鱼上的集装箱。**\n\n  ![docker运行原理图](https://i.loli.net/2021/01/17/V1lKkuh7i3ypJMa.png)\n\n# 常用命令\n\n## 帮助命令\n\n   ```shell\n   docker version  # 显示版本号\n   docker info  # 显示docker\n   docker --help  # 重要!!显示docker所有的命令\n   ```\n\n\n## 镜像命令\n\n```shell\ndocker images  # 列出docker的所有镜像\n# OPTIONS说明\n#\t-a: 列出本地所有镜像\n#\t-q: 只显示镜像ID\n#\t--digests: 显示镜像的摘要信息\n#\t--no-trunc: 显示完整镜像信息\n\ndocker search XXX镜像名  # 到docker hub上查找某个镜像\n# OPTION说明\n#\t--no-trunc: 显示完整镜像描述\n# \t-s: 列出收藏数不小于指定值的镜像\n#\t--automated: 只列出automated build类型的镜像(自动构建)\n\ndocker pull XXX镜像名[:TAG]  # 从配置的仓库(阿里云|网易云)拉取latest版本\n# 如: docker pull tomcat  ----> docker pull tomcat:latest\n\ndocker rmi XXX镜像名|XXX镜像ID  # 删除某个镜像\ndocker rmi -f XXX镜像名|XXX镜像ID  # 删除单个镜像, -f表示强制删除\ndocker rmi -f XXX镜像名1|XXX镜像1的ID XXX镜像名2|XXX镜像2的ID  # 删除多个镜像\ndocker rmi -f $(docker images -qa)  # 删除全部镜像\n```\n\n## 容器命令(有镜像才能创建并运行容器，这是根本前提)\n\n```shell\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]  # 新建并启动容器\n# OPTINS说明\n#\t--name=\"容器名字\": 为容器指定一个名称\n#\t-d: 后台运行容器, 并返回容器ID, 即: 启动守护式容器; 不加该参数即为启动交互式容器\n# \t-i: 以交互模式运行容器, 通常与 -t 一起使用\n#\t-t: 为容器重新分配一个伪输入终端, 通常与 -i 一起使用\n#\t-P: 随机端口映射\n# \t-p: 指定端口映射, 有以下四种格式\n#\t\tip:hostPort:containerPort\n#\t\tip::containerPort\n#\t\thostPort:containerPort\n#\t\tcontainerPort\n\ndocker ps [OPTIONS]  # 列出所有正在运行的容器\n# OPTIONS说明(常用)\n# \t-a: 列出当前所有正在运行的和曾经运行过的容器\n# \t-l: 显示最近创建的容器\n#\t-n: 显示最近n个创建的容器(n后面加数字)\n#\t-q: 静默模式, 只显示容器编号\n#\t--no-trunc: 不截断输出\n\nexit  # 退出并关闭容器\n# ctrl + p + q ====> 容器不停止退出\n\ndocker restart 容器ID  # 重启容器\n\ndocker stop 容器ID|容器名  # 停止容器\n\ndocker kill 容器ID|容器名  # 强制停止\ndocker rm 容器ID  # 删除已停止的容器, -f 强制删除\ndocker rm -f $(docker ps -aq)  # 强制删除所有容器\ndocker ps -aq | xargs docker rm  # 删除所有容器\n```\n\n## 注意点\n\n```shell\ndocker run -d 容器名 # docker启动守护式容器\n      # 但是，当我们这样运行centos再执行`docker ps`时，会发现 centos并没有运行（已经退出）\n      # 很重要的一点是：**docker容器后台运行，就必须有一个前台进程**\n      # 容器运行的命令如果不是那些**一直挂起的命令(如：top、tail)**，就会自动退出，因为这个容器觉得无事可做，所以它就自杀了\n      # 最佳的解决方案是：将你要运行的程序以前台进程的形式运行；如：执行\ndocker run -d centos /bin/sh -c \"while true;do echo hello;sleep 2;done\"\n      # 目的是让centos容器的终端一直在运行就行\ndocker logs -f -t --tail 容器ID # 查看容器日志\n      # -f: 跟随最新的日志打印\n      # -t: 加入时间戳\n      # --tail 数字: 显示最后多少条\n\ndocker top 容器ID # 查看容器内运行的进程\n\ndocker inspect 容器ID # 查看容器内部细节\n\n# 进入正在运行的容器并以命令行交互\ndocker attach 容器ID  # 直接进入容器启动命令的终端, 不会启动新的进程\ndocker exec -it 容器ID bashShell  # 在容器中打开新的终端, 并且可以启动新的进程\n      # 需要注意的是: docker exec -it 容器ID /bin/bash 和 docker attach 容器ID效果一样\n      # exec 比 attach的功能更强大\n\ndocker cp 容器ID:容器内路径 主机目的路径 # 从容器内拷贝文件到主机上\n```\n\n* 其他docker常用命令参考[链接](https://www.cnblogs.com/ann-zhgy/p/11981434.html)\n\n* 完整命令查看[官方文档](https://docs.docker.com/engine/reference/run/)\n\n# docker镜像\n\n## 是什么(参考概念): 对概念的解释\n\n1. UnionFS(联合文件系统): \n   * 联合文件系统是一种用分层、轻量级并且高性能的文件系统，它支持**对文件系统的修改作为一次提交 来一层层的叠加(就像千层饼一样)**，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。联合文件系统是Docker镜像的基础。镜像可以通过分层来进行集成，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。\n   * 特性：一次加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终文件系统会包含所有底层文件和目录。\n\n## 镜像加载原理\n\n1. 原理\n   * docker的镜像由一层一层的文件系统组成，这种层级的文件系统叫做UnionFS。\n   * bootfs(boot file system)主要包含**bootloader**和**kernel**, bootloader主要是**引导加载kernel**, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。\n   * rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 \n   * ![图解](https://i.loli.net/2021/01/17/OfBoQ4CZak97hXy.png)\n\n2. **那么平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？**\n   * 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。\n\n3. 需要注意的是：\n   * 当我们使用docker pull镜像时，会出现pull很多文件，其原因就是UnionFS\n   * ![linux的UnionFS](https://i.loli.net/2021/01/17/YzxfyOig51ANmrq.png)\n\n4. 好处：**共享资源**\n   * 有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。\n\n## docker镜像特点\n\n* docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像顶部，这一层称为**容器层**，容器层下面那一层称为**镜像层**\n\n## 补充：镜像的commit\n\n```shell\ndocker commit 容器ID  # 提交容器副本使之成为镜像\ndocker commit -m=\"提交的描述信息\" -a=\"作者信息\" 容器ID 要创建的目标镜像名:[标签名]\n```\n\n# docker容器数据卷\n\n## 是什么\n\n1. 有时候我们会有以下需求\n   * docker将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的\n   * 有可能希望容器之间共享数据\n2. 所以为了保存数据，我们就需要用到容器数据卷\n3. 容器数据卷有点类似于redis的rdb和aof文件，但是我们可以理解为插在电脑上的优盘和硬盘\n\n## 特点\n\n1. 数据卷可在容器之间共享或重用数据\n2. 卷中的更改可以直接生效\n3. 数据卷中的更改不会包含在镜像的更新中\n4. 数据卷的生命周期一直持续到没有容器使用它为止\n\n## 容器内添加\n\n### 命令添加\n\n1. 命令\n\n   ```shell\n   docker run -it -v /宿主机目录:/容器内目录 镜像名\n   ```\n\n2. 查看数据卷是否挂载成功\n\n   ```shell\n   docker inspect 容器ID\n   ```\n\n3. 命令（设置权限）\n\n   ```shell\n   docker run -it -v /宿主机目录:/容器内目录:ro 镜像名  # ro代表readonly：只读\n   ```\n\n### DockerFile添加\n\n1. 在根目录下新建myDocker文件夹并进入 ====> 可在DockerFile中使用VOLUME指令来给镜像添加一个或多个数据卷\n\n   ```shell\n   VOLUME[\"/dataVolumeContainer\",\"/dataVolumeContainer2\",\"/dataVolumeContainer3\"]\n   ```\n\n   \n\n2. file构建\n\n   ```shell\n   # volume test\n   FROM centos\n   VOLUME [\"/dataVolumeContainer1\",\"/dataVolumeContainer2\"]\n   CMD echo \"finished,--------success1\"\n   CMD /bin/bash\n   ```\n\n3. build后生成镜像\n\n   ```shell\n   docker build -f /myDocker/dockerfile2 -t 镜像名[:标签名]\n   # -f 表示文件 ===> file\n   # -t 表示为镜像设置镜像名[:标签名]\n   ```\n\n4. run容器\n\n5. 容器内的数据卷默认映射在主机的`/var/lib/docker/columes/容器ID/_data`中\n\n### 注意\n\n* Docker挂载主机目录Docker访问出现 cannot open directory .: Permission denied\n* 解决办法：在挂载目录后多加一个`--privileged=true`参数即可\n\n## 数据卷容器\n\n1. 是什么\n\n   * 命名的容器挂载数据卷，其它容器通过挂载这个容器(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器\n   * 就像是redis的主从复制和Java的继承，子容器可以共享父容器的数据，相当于**多台电脑共享一块硬盘**\n\n2. **容器间传递共享**\n\n   * 前提条件：在上次操作构建好的有数据卷的docker镜像的基础上操作\n\n   1. 先启动一个父容器\n\n      ```shell\n      docker run -it --name dc01 myCentos\n      ```\n\n   2. 创建新容器继承子容器\n\n      ```shell\n      docker run -it --name dc02 --volumes-from dc01 myCentos\n      ```\n\n   3. 这个数据卷的生命周期：从开始创建直到没有任何容器使用它\n\n# dockerfile解析\n\n## 是什么\n\n* Dockerfile是用来构建Docker镜像的构建文件、是由一系列参数和命令构成的脚本\n* 构建三步骤\n  1. 编写Dockerfile文件\n  2. docker build\n  3. docker run\n* 文件什么样？例如：\n  * [centos](https://github.com/CentOS/sig-cloud-instance-images/blob/0510c8e67cb3a48db178a8302157cdf7d9e99a0c/docker/Dockerfile)\n  * [tomcat](https://github.com/docker-library/tomcat/blob/ac840829bd52309030c8811d292776888109df63/8.5/jdk8/openjdk/Dockerfile)\n\n## Dockerfile构建过程解析\n\n1. Dockerfile内容基础知识\n   1. 每条保留字指令都必须为大写字母且后面至少跟随一个参数\n   2. 指令从上到下执行\n   3. \\# 表示注释\n   4. 每条指令都会创建一个新的镜像层，并对镜像进行提交\n2. Docker执行Dockerfile的大致流程\n   1. docker从基础镜像运行一个容器\n   2. 执行一条指令并对容器作出修改\n   3. 执行类似`docker commit`的操作提交一个新的镜像层\n   4. docker再基于刚创建的镜像运行一个新容器\n   5. 执行docker的下一条指令直到所有指令执行结束\n3. 小结\n   * 从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，\n     * Dockerfile是软件的原材料\n     * Docker镜像是软件的交付品\n     * Docker容器则可以认为是软件的运行态。\n   * Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。\n     1. Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;\n     2. Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;\n     3. Docker容器，容器是直接提供服务的。\n\n## docker指令\n\n```shell\nFROM\t\t# 指定基础镜像，指明当前镜像是基于那个镜像的\nMAINTAINER\t# 镜像维护者的姓名和邮箱地址\nRUN\t\t\t# 容器构建时需要运行的命令\nEXPOSE\t\t# 当前容器对外暴露的端口\nWORKDIR\t\t# 指定在创建容器后，终端默认登陆进来的工作目录，就是一个落脚点（web中的index）\nENV\t\t\t# 用来在构建镜像的过程中设置环境变量\n\t\t\t# \t定义：ENV myPath /usr/test\n\t\t\t# \t使用：$myPath\nADD\t\t\t# 将宿主目录下的文件拷贝到镜像，并自动处理（URL、压缩包）\nCOPY\t\t# 类似ADD。将从构建上下文目录中<源路径>的文件/目录复制到新一层的镜像内的<目标路径>位置\n\t\t\t# \tCOPY src(宿主机路径) dest(容器路径)\n\t\t\t# \tCOPY[\"src\",\"dest\"]\nVOLUME\t\t# 容器数据卷，用于保存和持久化操作\nCMD\t\t\t# 指定一个容器启动时要运行的命令\n\t\t\t# 一个文件中可以存在多个，但是只有最后一个有效，CMD会被 docker run 之后的参数替换\n\t\t\t# 以tomcat为例：执行 docker run -it tomcat ls -l\n\t\t\t# 会列出tomcat目录的所有文件和目录，然后tomcat不会启动\n\t\t\t\nENTRYPOINT\t# 和CMD一样\n\t\t\t# 但是 docker run 之后的参数会被当作参数传递给 ENTRYPOINT，之后形成新的命令组合\n\t\t\t\nONBUILD\t\t# 当构建一个被继承的Dockerfile时运行命令。即：会在子镜像构建时首先执行操作；类似于触发器\n```\n\n* 详情查看[官网](https://docs.docker.com/engine/reference/builder/)\n\n## 案例\n\n1. 自定义centOS使其拥有vim和ifconfig\n\n```dockerfile\n# scratch相当于Java中的Object, 实际上是一个空镜像. 这里使用centos, 因为是在其基础上重新构建的\nFROM centos\n\n# 定义一个环境变量便于引用\nENV myPath /tmp\n# 引用已定义的环境变量\nWORKDIR $myPath\n\nRUN yum -y update\n# 容器构建时要运行的命令: 安装vim\nRUN yum install -y vim\n# 安装net-tools, 使其支持ifconfig\nRUN yum install -y net-tools\n\n# 对外暴露80端口\nEXPOSE 80\n\n# 构建时执行该命令: 输出定义的环境变量\nCMD echo $myPath\n# 构建时执行作为构建完成的标志\nCMD echo \"build success------------------ok\"\n# 每次创建并运行容器后执行此命令: 进入终端窗口\nCMD /bin/bash\n```\n\n2. cmd：查询ip\n\n```dockerfile\nFROM centos\nRUN yum -y install curl\nCMD [\"curl\",\"-s\",\"http://ip.cn\"]\n```\n\n3. entrypoint：查询ip\n\n```dockerfile\nFROM centos\nRUN yum -y install curl\nENTRYPOINT [\"curl\",\"-s\",\"http://ip.cn\"]\n```\n\n4. onbuild\n\n```dockerfile\nFROM centos\nRUN yum -y install curl\nENTRYPOINT [\"curl\",\"-s\",\"http://ip.cn\"]\nONBUILD RUN echo \"father images onbuild -------\"\n```\n\n5. tomcat部署应用\n\n```dockerfile\nFROM tomcat\n\nENV home /usr/local/tomcat\nADD sram_ssm.war $home/webapps/\nEXPOSE 8080\nCMD [\"catalina.sh\", \"run\"]\n```\n","tags":["docker","容器引擎"],"categories":["docker"]},{"title":"Hello World","url":"/2021/01/4a17b156.html","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["blog","Quick Start","passwd-a"],"categories":["Quick Start","Introduce"]}]